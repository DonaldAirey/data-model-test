// <auto-generated />
#nullable enable
namespace UnitTest
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Threading;
    using System.Transactions;
    using DotNext.Threading;

    /// <summary>
    /// An action on a row.
    /// </summary>
    public enum DataAction
    {
        /// <summary>
        /// Add an item.
        /// </summary>
        Add,
        /// <summary>
        /// Remove an item.
        /// </summary>
        Remove,
        /// <summary>
        /// Update an item.
        /// </summary>
        Update,
    }

    /// <summary>
    /// An object that can be enlisted in a transaction.
    /// </summary>
    public class EnlistmentNotification : IEnlistmentNotification
    {
        /// <summary>
        /// The asynchronous transaction.
        /// </summary>
        private readonly AsyncTransaction asyncTransaction;

        /// <summary>
        /// The original <see cref="IEnlistmentNotification"/> object.
        /// </summary>
        private readonly IEnlistmentNotification enlistmentNotification;

        /// <summary>
        /// Initializes a new instance of the <see cref="EnlistmentNotification"/> class.
        /// </summary>
        public EnlistmentNotification(IEnlistmentNotification enlistmentNotification)
        {
            ArgumentNullException.ThrowIfNull(AsyncTransaction.Current);
            this.asyncTransaction = AsyncTransaction.Current;
            this.enlistmentNotification = enlistmentNotification;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            AsyncTransaction.Current = this.asyncTransaction;
            this.enlistmentNotification.Commit(enlistment);
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            AsyncTransaction.Current = this.asyncTransaction;
            this.enlistmentNotification.Prepare(preparingEnlistment);
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            AsyncTransaction.Current = this.asyncTransaction;
            this.enlistmentNotification.Rollback(enlistment);
        }
    }

    /// <summary>
    /// An asynchronous transaction.
    /// </summary>
    public class AsyncTransaction : IDisposable
    {
        /// <summary>
        /// The local asynchronous transaction.
        /// </summary>
        private static readonly AsyncLocal<AsyncTransaction?> asyncTransaction = new AsyncLocal<AsyncTransaction?>();

        /// <summary>
        /// The cancellation token source.
        /// </summary>
        private readonly CancellationTokenSource? cancellationTokenSource = null;

        /// <summary>
        /// The unique identifier.
        /// </summary>
        private readonly Guid identifier = Guid.NewGuid();

        /// <summary>
        /// The transaction.
        /// </summary>
        private readonly Transaction? transaction;

        /// <summary>
        /// The transaction scope.
        /// </summary>
        private readonly TransactionScope transactionScope;

        /// <summary>
        /// Initializes a new instance of the <see cref="AsyncTransaction"/> class.
        /// </summary>
        public AsyncTransaction(CancellationToken cancellationToken = default)
        {
            if (cancellationToken == default)
            {
                this.cancellationTokenSource = new CancellationTokenSource();
                cancellationToken = cancellationTokenSource.Token;
            }

            this.CancellationToken = cancellationToken;
            AsyncTransaction.asyncTransaction.Value = this;
            this.transactionScope = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled);
            this.transaction = Transaction.Current;
            ArgumentNullException.ThrowIfNull(this.transaction);
            this.transaction.TransactionCompleted += this.OnTransactionCompleted;
        }

        /// <summary>
        /// Gets the cancellation token.
        /// </summary>
        public CancellationToken CancellationToken { get; }

        /// <summary>
        /// Gets the current asynchronous transaction.
        /// </summary>
        public static AsyncTransaction? Current
        {
            get
            {
                return AsyncTransaction.asyncTransaction.Value;
            }

            set
            {
                AsyncTransaction.asyncTransaction.Value = value;
            }
        }

        /// <summary>
        /// Gets the read locks.
        /// </summary>
        public Dictionary<object, AsyncReaderWriterLock> ReadLocks { get; } = new Dictionary<object, AsyncReaderWriterLock>();

        /// <summary>
        /// Gets the write locks.
        /// </summary>
        public Dictionary<object, AsyncReaderWriterLock> WriteLocks { get; } = new Dictionary<object, AsyncReaderWriterLock>();

        /// <summary>
        /// Indicates that all operations within the scope are completed successfully.
        /// </summary>
        public void Complete()
        {
            this.transactionScope.Complete();
        }

        /// <inheritdoc/>
        public void Dispose()
        {
            foreach (var asyncReaderWriterLock in this.ReadLocks.Values)
            {
                asyncReaderWriterLock.Release();
            }

            foreach (var asyncReaderWriterLock in this.WriteLocks.Values)
            {
                asyncReaderWriterLock.Release();
            }

            this.transactionScope.Dispose();
            AsyncTransaction.asyncTransaction.Value = null;
        }

        /// <summary>
        /// Enlists a volatile resource manager to participate in a transaction.
        /// </summary>
        /// <param name="enlistmentNotification">An object that implements the <see cref="IEnlistmentNotification"/> interface to receive two-phase commit notifications.</param>
        /// <returns>An <see cref="Enlistment"/> object that describes the enlistment.</returns>
        public Enlistment EnlistVolatile(IEnlistmentNotification enlistmentNotification)
        {
            ArgumentNullException.ThrowIfNull(this.transaction);
            return this.transaction.EnlistVolatile(new EnlistmentNotification(enlistmentNotification), EnlistmentOptions.None);
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is AsyncTransaction other && this.identifier == other.identifier;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.identifier.GetHashCode();
        }

        /// <summary>
        /// Handles the completion of the transaction.
        /// </summary>
        /// <param name="sender">The object that originated the event.</param>
        /// <param name="transactionEventArgs">The event data.</param>
        private void OnTransactionCompleted(object? sender, TransactionEventArgs transactionEventArgs)
        {
            if (this.cancellationTokenSource != null)
            {
                this.cancellationTokenSource.Cancel();
            }
        }
    }

    /// <summary>
    /// Represents errors that occurs when trying to establish a relationship in a data model.
    /// </summary>
    public class ConcurrencyException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ConcurrencyException"/> class.
        /// </summary>
        public ConcurrencyException() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConcurrencyException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public ConcurrencyException(string message) : base(message)
        {
        }
    }

    /// <summary>
    /// Represents errors that occurs when trying to establish a relationship in a data model.
    /// </summary>
    public class ConstraintException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ConstraintException"/> class.
        /// </summary>
        public ConstraintException() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConstraintException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public ConstraintException(string message) : base(message)
        {
        }
    }

    /// <summary>
    /// The state of an <see cref="Enlistment"/>.
    /// </summary>
    public class EnlistmentState
    {
        /// <summary>
        /// Gets the commit stack.
        /// </summary>
        public Stack<Action> CommitStack { get; } = new Stack<Action>();

        /// <summary>
        /// Gets the rollback stack.
        /// </summary>
        public Stack<Action> RollbackStack { get; } = new Stack<Action>();
    }

    /// <summary>
    /// Arguments describing an event that changed a row.
    /// </summary>
    public class RowChangedEventArgs(DataAction dataAction, object row) : EventArgs
    {
        /// <summary>
        /// Gets the action that caused the change.
        /// </summary>
        public DataAction DataAction { get; } = dataAction;

        /// <summary>
        /// Gets the row.
        /// </summary>
        public object Row { get; } = row;
    }
}

namespace UnitTest.Master
{
    using System;
    using System.Collections;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using System.Text.Json.Serialization;
    using System.Threading.Tasks;
    using System.Transactions;
    using DotNext.Threading;
    using Microsoft.AspNetCore.Authorization;
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.EntityFrameworkCore;
    using Microsoft.Extensions.Configuration;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.Logging;
    using UnitTest;

    /// <summary>
    /// A Account row.
    /// </summary>
    public class Account
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Account"/> class.
        /// </summary>
        public Account()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Account"/> class.
        /// </summary>
        /// /// <param name="account">The account.</param>
        public Account(Account account)
        {
            this.AccountId = account.AccountId;
            this.Name = account.Name;
            this.Orders.UnionWith(account.Orders);
            this.Positions.UnionWith(account.Positions);
            this.RowVersion = account.RowVersion;
        }

        /// <summary>
        /// Gets or sets the AccountId.
        /// </summary>
        [JsonPropertyName("accountId")]
        public System.Guid AccountId { get; set; }

        /// <summary>
        /// Gets or sets the Name.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Gets the child <see cref="Order"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Order> Orders { get; } = new HashSet<Order>();

        /// <summary>
        /// Gets the child <see cref="Position"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Position> Positions { get; } = new HashSet<Position>();

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Shallow copy of a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The destination <see cref="Account"/> row.</param>
        public void CopyFrom(Account account)
        {
            this.AccountId = account.AccountId;
            this.Name = account.Name;
            this.Orders.Clear();
            this.Orders.UnionWith(account.Orders);
            this.Positions.Clear();
            this.Positions.UnionWith(account.Positions);
            this.RowVersion = account.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Account other && this.AccountId == other.AccountId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AccountId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Account"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Accounts(Fixture fixture) : IEnlistmentNotification, IEnumerable<Account>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<System.Guid, Account> dictionary = new Dictionary<System.Guid, Account>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Account"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Account> DeletedRows { get; } = new LinkedList<Account>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                ArgumentNullException.ThrowIfNull(asyncTransaction);
                if (asyncTransaction == null)
                {
                    return null;
                }

                if (asyncTransaction.CancellationToken.IsCancellationRequested)
                {
                    throw new OperationCanceledException();
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The <see cref="Account"/> row.</param>
        /// <returns>The added <see cref="Account"/> row.</returns>
        public async Task<Account> AddAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            await account.EnterWriteLockAsync().ConfigureAwait(false);
            var originalRow = new Account(account);
            enlistmentState.RollbackStack.Push(() => account.CopyFrom(originalRow));
            account.RowVersion = this.fixture.IncrementRowVersion();
            this.dictionary.Add(account.AccountId, account);
            enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(account.AccountId));
            var clonedRow = new Account(account);
            enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
            return clonedRow;
        }

        /// <summary>
        /// Adds a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The collection of <see cref="Account"/> rows.</param>
        /// <returns>The added <see cref="Account"/> rows.</returns>
        public async Task<IEnumerable<Account>> AddAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Account>();
            foreach (var account in accounts)
            {
                await account.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Account(account);
                enlistmentState.RollbackStack.Push(() => account.CopyFrom(originalRow));
                account.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Add(account.AccountId, account);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(account.AccountId));
                var clonedRow = new Account(account);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                addedRows.Add(clonedRow);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.CommitStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Account"/> row using the unique key.
        /// </summary>
        /// <param name="accountId">The accountId.</param>
        /// <returns>The found <see cref="Account"/> row, or null if not found.</returns>
        public Account? Find(System.Guid accountId)
        {
            return this.dictionary.TryGetValue(accountId, out var account) ? account : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Account> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The collection of <see cref="Account"/> rows to load.</param>
        public void Load(IEnumerable<Account> accounts)
        {
            foreach (var account in accounts)
            {
                this.dictionary.Add(account.AccountId, account);
                this.fixture.RowVersion = account.RowVersion;
                this.OnRowChanged(DataAction.Add, account);
            }
        }

        /// <summary>
        /// Handles the <see cref="Account"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="account">The <see cref="Account"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Account account)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, account));
                }
                finally
                {
                }
            }

            if (dataAction == DataAction.Remove)
            {
                this.DeletedRows.AddFirst(account);
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The collection of <see cref="Account"/> rows.</param>
        /// <returns>The patched <see cref="Account"/> rows.</returns>
        public async Task<(IEnumerable<Account> AddedRows, IEnumerable<Account> UpdatedRows)> PatchAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Account>();
            var updatedRows = new List<Account>();
            foreach (var account in accounts)
            {
                if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Account(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (account.RowVersion != foundRow.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    foundRow.AccountId = account.AccountId;
                    foundRow.Name = account.Name;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    var clonedRow = new Account(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    await account.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Account(account);
                    enlistmentState.RollbackStack.Push(() => account.CopyFrom(originalRow));
                    account.RowVersion = this.fixture.IncrementRowVersion();
                    this.dictionary.Add(account.AccountId, account);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(account.AccountId));
                    var clonedRow = new Account(account);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                    addedRows.Add(clonedRow);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The <see cref="Account"/> row.</param>
        /// <returns>The added or updated <see cref="Account"/> row.</returns>
        public async Task<(Account? AddedRow, Account? UpdatedRow)> PutAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Account(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (account.RowVersion != foundRow.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                foundRow.AccountId = account.AccountId;
                foundRow.Name = account.Name;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                var clonedRow = new Account(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return (AddedRow: null, UpdatedRow: clonedRow);
            }
            else
            {
                await account.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Account(account);
                enlistmentState.RollbackStack.Push(() => account.CopyFrom(originalRow));
                account.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Add(account.AccountId, account);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(account.AccountId));
                var clonedRow = new Account(account);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                return (AddedRow: clonedRow, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">A collection of <see cref="Account"/> rows.</param>
        /// <returns>The removed <see cref="Account"/> rows.</returns>
        public async Task<IEnumerable<Account>> RemoveAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Account>();
            foreach (var account in accounts)
            {
                if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Account(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (foundRow.RowVersion != account.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    if (foundRow.Orders.Any())
                    {
                        throw new ConstraintException("The remove action conflicted with the constraint AccountOrderIndex");
                    }

                    if (foundRow.Positions.Any())
                    {
                        throw new ConstraintException("The remove action conflicted with the constraint AccountPositionIndex");
                    }

                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    this.dictionary.Remove(foundRow.AccountId);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Add(foundRow.AccountId, foundRow));
                    var clonedRow = new Account(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                    removedRows.Add(clonedRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The <see cref="Account"/> row.</param>
        /// <returns>The removed <see cref="Account"/> row.</returns>
        public async Task<Account?> RemoveAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Account(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (foundRow.RowVersion != account.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                if (foundRow.Orders.Any())
                {
                    throw new ConstraintException("The remove action conflicted with the constraint AccountOrderIndex");
                }

                if (foundRow.Positions.Any())
                {
                    throw new ConstraintException("The remove action conflicted with the constraint AccountPositionIndex");
                }

                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Remove(foundRow.AccountId);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Add(foundRow.AccountId, foundRow));
                var clonedRow = new Account(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                return clonedRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.RollbackStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Account"/> row in the table.
        /// </summary>
        /// <param name="accounts">The account row.</param>
        public async Task<IEnumerable<Account>> UpdateAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Account>();
            foreach (var account in accounts)
            {
                if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Account(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (account.RowVersion != foundRow.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    foundRow.AccountId = account.AccountId;
                    foundRow.Name = account.Name;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    var clonedRow = new Account(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Account"/> row in the table.
        /// </summary>
        /// <param name="account">The account row.</param>
        public async Task<Account> UpdateAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Account(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (account.RowVersion != foundRow.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                foundRow.AccountId = account.AccountId;
                foundRow.Name = account.Name;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                var clonedRow = new Account(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return clonedRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// Controller for <see cref="Account"/> rows.
    /// </summary>
    [Route("fixture/[controller]")]
    [ApiController]
    [Authorize]
    public partial class AccountsController : ControllerBase
    {
        private readonly Fixture fixture;
        private readonly FixtureContext fixtureContext;
        private readonly ILogger logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="AccountsController"/> class.
        /// </summary>
        /// <param name="fixture">The data model.</param>
        /// <param name="fixtureContext">The DbContext for the data model.</param>
        /// <param name="logger">The log device.</param>
        public AccountsController(Fixture fixture, FixtureContext fixtureContext, ILogger<AccountsController> logger)
        {
            this.fixture = fixture;
            this.fixtureContext = fixtureContext;
            this.logger = logger;
        }

        /// <summary>
        /// Removes a <see cref="Account"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="account">The <see cref="Account"/> row to be deleted.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete("{accountId}")]
        public async Task<IActionResult> DeleteAccount([FromRoute] System.Guid accountId, [FromBody] Account account)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Accounts.EnterWriteLockAsync().ConfigureAwait(false);
                if (this.fixture.Accounts.Find(accountId) != null)
                {
                    var removedRow = await this.fixture.Accounts.RemoveAsync(account).ConfigureAwait(false);
                    if (removedRow != null)
                    {
                        this.fixtureContext.Accounts.Remove(account);
                        await this.fixtureContext.SaveChangesAsync();
                    }

                    asyncTransaction.Complete();
                }

                return this.Ok(account);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">A collection of <see cref="Account"/> rows.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete]
        public async Task<IActionResult> DeleteAccounts([FromBody] IEnumerable<Account> accounts)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Accounts.EnterWriteLockAsync().ConfigureAwait(false);
                var deletedRows = await this.fixture.Accounts.RemoveAsync(accounts).ConfigureAwait(false);
                this.fixtureContext.Accounts.RemoveRange(deletedRows);
                await this.fixtureContext.SaveChangesAsync();
                asyncTransaction.Complete();
                return this.Ok(deletedRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a specific <see cref="Account"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <returns>The row matching the key or NotFound.</returns>
        [HttpGet("{accountId}")]
        public async Task<IActionResult> GetAccount([FromRoute] System.Guid accountId)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Accounts.EnterReadLockAsync().ConfigureAwait(false);
                var existingRow = this.fixture.Accounts.Find(accountId);
                if (existingRow == null)
                {
                    return this.NotFound();
                }

                await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                return this.Ok(new Account(existingRow));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <returns>A collection of <see cref="Account"/> rows.</returns>
        [HttpGet]
        public async Task<IActionResult> GetAccounts()
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Accounts.EnterReadLockAsync().ConfigureAwait(false);
                var existingRows = new List<Account>();
                foreach (var existingRow in this.fixture.Accounts)
                {
                    await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                    existingRows.Add(new Account(existingRow));
                }

                return this.Ok(existingRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Patches the <see cref="Account"/> table.
        /// </summary>
        /// <param name="accounts">A collection of <see cref="Account"/> rows.</param>
        /// <returns>The result of applying the patch action.</returns>
        [HttpPatch]
        public async Task<IActionResult> PatchAccountsAsync([FromBody] IEnumerable<Account> accounts)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Accounts.EnterWriteLockAsync().ConfigureAwait(false);
                (var addedRows, var updatedRows) = await this.fixture.Accounts.PatchAsync(accounts).ConfigureAwait(false);
                this.fixtureContext.Accounts.AddRange(addedRows);
                this.fixtureContext.Accounts.UpdateRange(updatedRows);
                await this.fixtureContext.SaveChangesAsync().ConfigureAwait(false);
                asyncTransaction.Complete();
                return this.Ok(addedRows.Concat(updatedRows));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Puts the <see cref="Account"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="account">The <see cref="Account"/> row.</param>
        /// <returns>The result of applying the put action.</returns>
        [HttpPut("{accountId}")]
        public async Task<IActionResult> PutAccount([FromRoute] System.Guid accountId, [FromBody] Account account)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Accounts.EnterWriteLockAsync().ConfigureAwait(false);
                (var addedRow, var updatedRow) = await this.fixture.Accounts.PutAsync(account).ConfigureAwait(false);
                if (addedRow != null)
                {
                    this.fixtureContext.Add(addedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Complete();
                    return this.Ok(addedRow);
                }

                if (updatedRow != null)
                {
                    this.fixtureContext.Update(updatedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Complete();
                    return this.Ok(updatedRow);
                }

                throw new InvalidOperationException();
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }
    }

    /// <summary>
    /// A Asset row.
    /// </summary>
    public class Asset
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Asset"/> class.
        /// </summary>
        public Asset()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Asset"/> class.
        /// </summary>
        /// /// <param name="asset">The asset.</param>
        public Asset(Asset asset)
        {
            this.AssetId = asset.AssetId;
            this.Name = asset.Name;
            this.Orders.UnionWith(asset.Orders);
            this.Positions.UnionWith(asset.Positions);
            this.Quotes.UnionWith(asset.Quotes);
            this.RowVersion = asset.RowVersion;
        }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Name.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Gets the child <see cref="Order"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Order> Orders { get; } = new HashSet<Order>();

        /// <summary>
        /// Gets the child <see cref="Position"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Position> Positions { get; } = new HashSet<Position>();

        /// <summary>
        /// Gets the child <see cref="Quote"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Quote> Quotes { get; } = new HashSet<Quote>();

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Shallow copy of a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The destination <see cref="Asset"/> row.</param>
        public void CopyFrom(Asset asset)
        {
            this.AssetId = asset.AssetId;
            this.Name = asset.Name;
            this.Orders.Clear();
            this.Orders.UnionWith(asset.Orders);
            this.Positions.Clear();
            this.Positions.UnionWith(asset.Positions);
            this.Quotes.Clear();
            this.Quotes.UnionWith(asset.Quotes);
            this.RowVersion = asset.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Asset other && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Asset"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Assets(Fixture fixture) : IEnlistmentNotification, IEnumerable<Asset>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<System.Guid, Asset> dictionary = new Dictionary<System.Guid, Asset>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Asset"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Asset> DeletedRows { get; } = new LinkedList<Asset>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                ArgumentNullException.ThrowIfNull(asyncTransaction);
                if (asyncTransaction == null)
                {
                    return null;
                }

                if (asyncTransaction.CancellationToken.IsCancellationRequested)
                {
                    throw new OperationCanceledException();
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The <see cref="Asset"/> row.</param>
        /// <returns>The added <see cref="Asset"/> row.</returns>
        public async Task<Asset> AddAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            await asset.EnterWriteLockAsync().ConfigureAwait(false);
            var originalRow = new Asset(asset);
            enlistmentState.RollbackStack.Push(() => asset.CopyFrom(originalRow));
            asset.RowVersion = this.fixture.IncrementRowVersion();
            this.dictionary.Add(asset.AssetId, asset);
            enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(asset.AssetId));
            var clonedRow = new Asset(asset);
            enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
            return clonedRow;
        }

        /// <summary>
        /// Adds a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The collection of <see cref="Asset"/> rows.</param>
        /// <returns>The added <see cref="Asset"/> rows.</returns>
        public async Task<IEnumerable<Asset>> AddAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                await asset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Asset(asset);
                enlistmentState.RollbackStack.Push(() => asset.CopyFrom(originalRow));
                asset.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Add(asset.AssetId, asset);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(asset.AssetId));
                var clonedRow = new Asset(asset);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                addedRows.Add(clonedRow);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.CommitStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Asset"/> row using the unique key.
        /// </summary>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Asset"/> row, or null if not found.</returns>
        public Asset? Find(System.Guid assetId)
        {
            return this.dictionary.TryGetValue(assetId, out var asset) ? asset : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Asset> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The collection of <see cref="Asset"/> rows to load.</param>
        public void Load(IEnumerable<Asset> assets)
        {
            foreach (var asset in assets)
            {
                this.dictionary.Add(asset.AssetId, asset);
                this.fixture.RowVersion = asset.RowVersion;
                this.OnRowChanged(DataAction.Add, asset);
            }
        }

        /// <summary>
        /// Handles the <see cref="Asset"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="asset">The <see cref="Asset"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Asset asset)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, asset));
                }
                finally
                {
                }
            }

            if (dataAction == DataAction.Remove)
            {
                this.DeletedRows.AddFirst(asset);
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The collection of <see cref="Asset"/> rows.</param>
        /// <returns>The patched <see cref="Asset"/> rows.</returns>
        public async Task<(IEnumerable<Asset> AddedRows, IEnumerable<Asset> UpdatedRows)> PatchAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Asset>();
            var updatedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Asset(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (asset.RowVersion != foundRow.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    foundRow.AssetId = asset.AssetId;
                    foundRow.Name = asset.Name;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    var clonedRow = new Asset(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    await asset.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Asset(asset);
                    enlistmentState.RollbackStack.Push(() => asset.CopyFrom(originalRow));
                    asset.RowVersion = this.fixture.IncrementRowVersion();
                    this.dictionary.Add(asset.AssetId, asset);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(asset.AssetId));
                    var clonedRow = new Asset(asset);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                    addedRows.Add(clonedRow);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The <see cref="Asset"/> row.</param>
        /// <returns>The added or updated <see cref="Asset"/> row.</returns>
        public async Task<(Asset? AddedRow, Asset? UpdatedRow)> PutAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Asset(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (asset.RowVersion != foundRow.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                foundRow.AssetId = asset.AssetId;
                foundRow.Name = asset.Name;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                var clonedRow = new Asset(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return (AddedRow: null, UpdatedRow: clonedRow);
            }
            else
            {
                await asset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Asset(asset);
                enlistmentState.RollbackStack.Push(() => asset.CopyFrom(originalRow));
                asset.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Add(asset.AssetId, asset);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(asset.AssetId));
                var clonedRow = new Asset(asset);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                return (AddedRow: clonedRow, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">A collection of <see cref="Asset"/> rows.</param>
        /// <returns>The removed <see cref="Asset"/> rows.</returns>
        public async Task<IEnumerable<Asset>> RemoveAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Asset(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (foundRow.RowVersion != asset.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    if (foundRow.Orders.Any())
                    {
                        throw new ConstraintException("The remove action conflicted with the constraint AssetOrderIndex");
                    }

                    if (foundRow.Positions.Any())
                    {
                        throw new ConstraintException("The remove action conflicted with the constraint AssetPositionIndex");
                    }

                    if (foundRow.Quotes.Any())
                    {
                        throw new ConstraintException("The remove action conflicted with the constraint AssetQuoteIndex");
                    }

                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    this.dictionary.Remove(foundRow.AssetId);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Add(foundRow.AssetId, foundRow));
                    var clonedRow = new Asset(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                    removedRows.Add(clonedRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The <see cref="Asset"/> row.</param>
        /// <returns>The removed <see cref="Asset"/> row.</returns>
        public async Task<Asset?> RemoveAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Asset(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (foundRow.RowVersion != asset.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                if (foundRow.Orders.Any())
                {
                    throw new ConstraintException("The remove action conflicted with the constraint AssetOrderIndex");
                }

                if (foundRow.Positions.Any())
                {
                    throw new ConstraintException("The remove action conflicted with the constraint AssetPositionIndex");
                }

                if (foundRow.Quotes.Any())
                {
                    throw new ConstraintException("The remove action conflicted with the constraint AssetQuoteIndex");
                }

                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Remove(foundRow.AssetId);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Add(foundRow.AssetId, foundRow));
                var clonedRow = new Asset(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                return clonedRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.RollbackStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Asset"/> row in the table.
        /// </summary>
        /// <param name="assets">The asset row.</param>
        public async Task<IEnumerable<Asset>> UpdateAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Asset(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (asset.RowVersion != foundRow.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    foundRow.AssetId = asset.AssetId;
                    foundRow.Name = asset.Name;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    var clonedRow = new Asset(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Asset"/> row in the table.
        /// </summary>
        /// <param name="asset">The asset row.</param>
        public async Task<Asset> UpdateAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Asset(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (asset.RowVersion != foundRow.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                foundRow.AssetId = asset.AssetId;
                foundRow.Name = asset.Name;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                var clonedRow = new Asset(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return clonedRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// Controller for <see cref="Asset"/> rows.
    /// </summary>
    [Route("fixture/[controller]")]
    [ApiController]
    [Authorize]
    public partial class AssetsController : ControllerBase
    {
        private readonly Fixture fixture;
        private readonly FixtureContext fixtureContext;
        private readonly ILogger logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="AssetsController"/> class.
        /// </summary>
        /// <param name="fixture">The data model.</param>
        /// <param name="fixtureContext">The DbContext for the data model.</param>
        /// <param name="logger">The log device.</param>
        public AssetsController(Fixture fixture, FixtureContext fixtureContext, ILogger<AssetsController> logger)
        {
            this.fixture = fixture;
            this.fixtureContext = fixtureContext;
            this.logger = logger;
        }

        /// <summary>
        /// Removes a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="asset">The <see cref="Asset"/> row to be deleted.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete("{assetId}")]
        public async Task<IActionResult> DeleteAsset([FromRoute] System.Guid assetId, [FromBody] Asset asset)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Assets.EnterWriteLockAsync().ConfigureAwait(false);
                if (this.fixture.Assets.Find(assetId) != null)
                {
                    var removedRow = await this.fixture.Assets.RemoveAsync(asset).ConfigureAwait(false);
                    if (removedRow != null)
                    {
                        this.fixtureContext.Assets.Remove(asset);
                        await this.fixtureContext.SaveChangesAsync();
                    }

                    asyncTransaction.Complete();
                }

                return this.Ok(asset);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">A collection of <see cref="Asset"/> rows.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete]
        public async Task<IActionResult> DeleteAssets([FromBody] IEnumerable<Asset> assets)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Assets.EnterWriteLockAsync().ConfigureAwait(false);
                var deletedRows = await this.fixture.Assets.RemoveAsync(assets).ConfigureAwait(false);
                this.fixtureContext.Assets.RemoveRange(deletedRows);
                await this.fixtureContext.SaveChangesAsync();
                asyncTransaction.Complete();
                return this.Ok(deletedRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a specific <see cref="Asset"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <returns>The row matching the key or NotFound.</returns>
        [HttpGet("{assetId}")]
        public async Task<IActionResult> GetAsset([FromRoute] System.Guid assetId)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Assets.EnterReadLockAsync().ConfigureAwait(false);
                var existingRow = this.fixture.Assets.Find(assetId);
                if (existingRow == null)
                {
                    return this.NotFound();
                }

                await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                return this.Ok(new Asset(existingRow));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <returns>A collection of <see cref="Asset"/> rows.</returns>
        [HttpGet]
        public async Task<IActionResult> GetAssets()
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Assets.EnterReadLockAsync().ConfigureAwait(false);
                var existingRows = new List<Asset>();
                foreach (var existingRow in this.fixture.Assets)
                {
                    await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                    existingRows.Add(new Asset(existingRow));
                }

                return this.Ok(existingRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Patches the <see cref="Asset"/> table.
        /// </summary>
        /// <param name="assets">A collection of <see cref="Asset"/> rows.</param>
        /// <returns>The result of applying the patch action.</returns>
        [HttpPatch]
        public async Task<IActionResult> PatchAssetsAsync([FromBody] IEnumerable<Asset> assets)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Assets.EnterWriteLockAsync().ConfigureAwait(false);
                (var addedRows, var updatedRows) = await this.fixture.Assets.PatchAsync(assets).ConfigureAwait(false);
                this.fixtureContext.Assets.AddRange(addedRows);
                this.fixtureContext.Assets.UpdateRange(updatedRows);
                await this.fixtureContext.SaveChangesAsync().ConfigureAwait(false);
                asyncTransaction.Complete();
                return this.Ok(addedRows.Concat(updatedRows));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Puts the <see cref="Asset"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="asset">The <see cref="Asset"/> row.</param>
        /// <returns>The result of applying the put action.</returns>
        [HttpPut("{assetId}")]
        public async Task<IActionResult> PutAsset([FromRoute] System.Guid assetId, [FromBody] Asset asset)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Assets.EnterWriteLockAsync().ConfigureAwait(false);
                (var addedRow, var updatedRow) = await this.fixture.Assets.PutAsync(asset).ConfigureAwait(false);
                if (addedRow != null)
                {
                    this.fixtureContext.Add(addedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Complete();
                    return this.Ok(addedRow);
                }

                if (updatedRow != null)
                {
                    this.fixtureContext.Update(updatedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Complete();
                    return this.Ok(updatedRow);
                }

                throw new InvalidOperationException();
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }
    }

    /// <summary>
    /// A Fixture.
    /// </summary>
    public class Fixture
    {
        /// <summary>
        /// The master row version.
        /// </summary>
        private long rowVersion = 0;

        /// <summary>
        /// Initializes a new instance of the <see cref="Fixture"/> class.
        /// </summary>
        /// <param name="logger">The log device.</param>
        public Fixture(ILogger<Fixture> logger)
        {
            this.Logger = logger;
            this.Accounts = new Accounts(this);
            this.Assets = new Assets(this);
            this.Orders = new Orders(this);
            this.Positions = new Positions(this);
            this.Quotes = new Quotes(this);
        }

        /// <summary>
        /// Gets the <see cref="Accounts"/> table.
        /// </summary>
        public Accounts Accounts { get; }

        /// <summary>
        /// Gets the <see cref="Assets"/> table.
        /// </summary>
        public Assets Assets { get; }

        /// <summary>
        /// Gets the log device.
        /// </summary>
        internal ILogger Logger { get; }

        /// <summary>
        /// Gets the <see cref="Orders"/> table.
        /// </summary>
        public Orders Orders { get; }

        /// <summary>
        /// Gets the <see cref="Positions"/> table.
        /// </summary>
        public Positions Positions { get; }

        /// <summary>
        /// Gets the <see cref="Quotes"/> table.
        /// </summary>
        public Quotes Quotes { get; }

        /// <summary>
        /// Gets or sets the master row version.
        /// </summary>
        public long RowVersion
        {
            get
            {
                return System.Threading.Interlocked.Read(ref this.rowVersion);
            }

            set
            {
                if (this.rowVersion < value)
                {
                    System.Threading.Interlocked.Exchange(ref this.rowVersion, value);
                }
            }
        }

        /// <summary>
        /// Increment the master row version.
        /// </summary>
        /// <returns>The incremented row version.</returns>
        public long IncrementRowVersion()
        {
            return System.Threading.Interlocked.Increment(ref this.rowVersion);
        }
    }

    /// <summary>
    /// The Entity Framework DbContext for the Fixture.
    /// </summary>
    public class FixtureContext : DbContext
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FixtureContext"/> class.
        /// </summary>
        /// <param name="contextOptions">The options for bulding the DbContext.</param>
        public FixtureContext(DbContextOptions<FixtureContext> contextOptions) : base(contextOptions)
        {
        }

        /// <summary>
        /// Gets or sets the <see cref="Account"/> set.
        /// </summary>
        public virtual DbSet<Account> Accounts { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="Asset"/> set.
        /// </summary>
        public virtual DbSet<Asset> Assets { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="Order"/> set.
        /// </summary>
        public virtual DbSet<Order> Orders { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="Position"/> set.
        /// </summary>
        public virtual DbSet<Position> Positions { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="Quote"/> set.
        /// </summary>
        public virtual DbSet<Quote> Quotes { get; set; }

        /// <summary>
        /// Loads the <see cref="Fixture"/>.
        /// </summary>
        /// <param name="fixture">The data model.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task LoadAsync(Fixture fixture)
        {
            fixture.Accounts.Load(await this.Accounts.ToListAsync().ConfigureAwait(false));
            fixture.Assets.Load(await this.Assets.ToListAsync().ConfigureAwait(false));
            fixture.Orders.Load(await this.Orders.ToListAsync().ConfigureAwait(false));
            fixture.Positions.Load(await this.Positions.ToListAsync().ConfigureAwait(false));
            fixture.Quotes.Load(await this.Quotes.ToListAsync().ConfigureAwait(false));
        }

        /// <inheritdoc/>
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Account>().ToTable("Account");
            modelBuilder.Entity<Account>().Property(a => a.AccountId).IsRequired();
            modelBuilder.Entity<Account>().Property(a => a.Name).IsRequired().HasMaxLength(128);
            modelBuilder.Entity<Account>().Property(a => a.RowVersion).IsRequired();
            modelBuilder.Entity<Account>().Ignore(a => a.Orders).Ignore(a => a.Positions);
            modelBuilder.Entity<Account>().HasKey(a => a.AccountId);
            modelBuilder.Entity<Asset>().ToTable("Asset");
            modelBuilder.Entity<Asset>().Property(a => a.AssetId).IsRequired();
            modelBuilder.Entity<Asset>().Property(a => a.Name).IsRequired().HasMaxLength(128);
            modelBuilder.Entity<Asset>().Property(a => a.RowVersion).IsRequired();
            modelBuilder.Entity<Asset>().Ignore(a => a.Orders).Ignore(a => a.Positions).Ignore(a => a.Quotes);
            modelBuilder.Entity<Asset>().HasKey(a => a.AssetId);
            modelBuilder.Entity<Order>().ToTable("Order");
            modelBuilder.Entity<Order>().Property(o => o.AccountId).IsRequired();
            modelBuilder.Entity<Order>().Property(o => o.AssetId).IsRequired();
            modelBuilder.Entity<Order>().Property(o => o.Quantity).HasColumnType("decimal(21,6)").IsRequired();
            modelBuilder.Entity<Order>().Property(o => o.RowVersion).IsRequired();
            modelBuilder.Entity<Order>().Ignore(o => o.Account).Ignore(o => o.Asset);
            modelBuilder.Entity<Order>().HasKey(o => new { o.AccountId, o.AssetId });
            modelBuilder.Entity<Position>().ToTable("Position");
            modelBuilder.Entity<Position>().Property(p => p.AccountId).IsRequired();
            modelBuilder.Entity<Position>().Property(p => p.AssetId).IsRequired();
            modelBuilder.Entity<Position>().Property(p => p.Quantity).HasColumnType("decimal(21,6)").IsRequired();
            modelBuilder.Entity<Position>().Property(p => p.RowVersion).IsRequired();
            modelBuilder.Entity<Position>().Ignore(p => p.Account).Ignore(p => p.Asset);
            modelBuilder.Entity<Position>().HasKey(p => new { p.AccountId, p.AssetId });
            modelBuilder.Entity<Quote>().ToTable("Quote");
            modelBuilder.Entity<Quote>().Property(q => q.AssetId).IsRequired();
            modelBuilder.Entity<Quote>().Property(q => q.Last).HasColumnType("decimal(21,6)").IsRequired();
            modelBuilder.Entity<Quote>().Property(q => q.RowVersion).IsRequired();
            modelBuilder.Entity<Quote>().Ignore(q => q.Asset);
            modelBuilder.Entity<Quote>().HasKey(q => q.AssetId);
        }
    }

    /// <summary>
    /// Used to configure the MVC environment.
    /// </summary>
    public static class MvcCoreMvcBuilderExtensions
    {
        /// <summary>
        /// Adds the <see cref="Fixture"/> controllers to the application.
        /// </summary>
        /// <returns>The <see cref="IMvcBuilder"/>.</returns>
        public static IMvcBuilder AddFixtureControllers(this IMvcBuilder builder)
        {
            return builder.AddApplicationPart(Assembly.GetExecutingAssembly());
        }
    }

    /// <summary>
    /// A Order row.
    /// </summary>
    public class Order
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Order"/> class.
        /// </summary>
        public Order()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Order"/> class.
        /// </summary>
        /// /// <param name="order">The order.</param>
        public Order(Order order)
        {
            this.Account = order.Account;
            this.AccountId = order.AccountId;
            this.Asset = order.Asset;
            this.AssetId = order.AssetId;
            this.Quantity = order.Quantity;
            this.RowVersion = order.RowVersion;
        }

        /// <summary>
        /// Gets or sets the parent <see cref="Account"/> row.
        /// </summary>
        [JsonIgnore]
        public Account? Account { get; set; }

        /// <summary>
        /// Gets or sets the AccountId.
        /// </summary>
        [JsonPropertyName("accountId")]
        public System.Guid AccountId { get; set; }

        /// <summary>
        /// Gets or sets the parent <see cref="Asset"/> row.
        /// </summary>
        [JsonIgnore]
        public Asset? Asset { get; set; }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Quantity.
        /// </summary>
        [JsonPropertyName("quantity")]
        public decimal Quantity { get; set; }

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Shallow copy of a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The destination <see cref="Order"/> row.</param>
        public void CopyFrom(Order order)
        {
            this.Account = order.Account;
            this.AccountId = order.AccountId;
            this.Asset = order.Asset;
            this.AssetId = order.AssetId;
            this.Quantity = order.Quantity;
            this.RowVersion = order.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Order other && this.AccountId == other.AccountId && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AccountId.GetHashCode() + this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Order"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Orders(Fixture fixture) : IEnlistmentNotification, IEnumerable<Order>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<(System.Guid, System.Guid), Order> dictionary = new Dictionary<(System.Guid, System.Guid), Order>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Order"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Order> DeletedRows { get; } = new LinkedList<Order>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                ArgumentNullException.ThrowIfNull(asyncTransaction);
                if (asyncTransaction == null)
                {
                    return null;
                }

                if (asyncTransaction.CancellationToken.IsCancellationRequested)
                {
                    throw new OperationCanceledException();
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The <see cref="Order"/> row.</param>
        /// <returns>The added <see cref="Order"/> row.</returns>
        public async Task<Order> AddAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            await order.EnterWriteLockAsync().ConfigureAwait(false);
            var originalRow = new Order(order);
            enlistmentState.RollbackStack.Push(() => order.CopyFrom(originalRow));
            var newAccount = this.fixture.Accounts.Find(order.AccountId);
            if (newAccount == null)
            {
                throw new ConstraintException("The add action conflicted with the constraint AccountOrderIndex.");
            }

            await newAccount.EnterWriteLockAsync().ConfigureAwait(false);
            newAccount.Orders.Add(order);
            enlistmentState.RollbackStack.Push(() => newAccount.Orders.Remove(order));
            order.Account = newAccount;
            var newAsset = this.fixture.Assets.Find(order.AssetId);
            if (newAsset == null)
            {
                throw new ConstraintException("The add action conflicted with the constraint AssetOrderIndex.");
            }

            await newAsset.EnterWriteLockAsync().ConfigureAwait(false);
            newAsset.Orders.Add(order);
            enlistmentState.RollbackStack.Push(() => newAsset.Orders.Remove(order));
            order.Asset = newAsset;
            order.RowVersion = this.fixture.IncrementRowVersion();
            this.dictionary.Add((order.AccountId, order.AssetId), order);
            enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((order.AccountId, order.AssetId)));
            var clonedRow = new Order(order);
            enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
            return clonedRow;
        }

        /// <summary>
        /// Adds a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The collection of <see cref="Order"/> rows.</param>
        /// <returns>The added <see cref="Order"/> rows.</returns>
        public async Task<IEnumerable<Order>> AddAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Order>();
            foreach (var order in orders)
            {
                await order.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Order(order);
                enlistmentState.RollbackStack.Push(() => order.CopyFrom(originalRow));
                var newAccount = this.fixture.Accounts.Find(order.AccountId);
                if (newAccount == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AccountOrderIndex.");
                }

                await newAccount.EnterWriteLockAsync().ConfigureAwait(false);
                newAccount.Orders.Add(order);
                enlistmentState.RollbackStack.Push(() => newAccount.Orders.Remove(order));
                order.Account = newAccount;
                var newAsset = this.fixture.Assets.Find(order.AssetId);
                if (newAsset == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AssetOrderIndex.");
                }

                await newAsset.EnterWriteLockAsync().ConfigureAwait(false);
                newAsset.Orders.Add(order);
                enlistmentState.RollbackStack.Push(() => newAsset.Orders.Remove(order));
                order.Asset = newAsset;
                order.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Add((order.AccountId, order.AssetId), order);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((order.AccountId, order.AssetId)));
                var clonedRow = new Order(order);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                addedRows.Add(clonedRow);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.CommitStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Order"/> row using the unique key.
        /// </summary>
        /// <param name="accountId">The accountId.</param>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Order"/> row, or null if not found.</returns>
        public Order? Find(System.Guid accountId, System.Guid assetId)
        {
            return this.dictionary.TryGetValue((accountId, assetId), out var order) ? order : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Order> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The collection of <see cref="Order"/> rows to load.</param>
        public void Load(IEnumerable<Order> orders)
        {
            foreach (var order in orders)
            {
                var account = this.fixture.Accounts.Find(order.AccountId);
                if (account == null)
                {
                    throw new ConstraintException("The insert action conflicted with the constraint AccountOrderIndex");
                }

                account.Orders.Add(order);
                order.Account = account;
                var asset = this.fixture.Assets.Find(order.AssetId);
                if (asset == null)
                {
                    throw new ConstraintException("The insert action conflicted with the constraint AssetOrderIndex");
                }

                asset.Orders.Add(order);
                order.Asset = asset;
                this.dictionary.Add((order.AccountId, order.AssetId), order);
                this.fixture.RowVersion = order.RowVersion;
                this.OnRowChanged(DataAction.Add, order);
            }
        }

        /// <summary>
        /// Handles the <see cref="Order"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="order">The <see cref="Order"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Order order)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, order));
                }
                finally
                {
                }
            }

            if (dataAction == DataAction.Remove)
            {
                this.DeletedRows.AddFirst(order);
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The collection of <see cref="Order"/> rows.</param>
        /// <returns>The patched <see cref="Order"/> rows.</returns>
        public async Task<(IEnumerable<Order> AddedRows, IEnumerable<Order> UpdatedRows)> PatchAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Order>();
            var updatedRows = new List<Order>();
            foreach (var order in orders)
            {
                if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Order(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (order.RowVersion != foundRow.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    foundRow.AccountId = order.AccountId;
                    foundRow.AssetId = order.AssetId;
                    foundRow.Quantity = order.Quantity;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    var clonedRow = new Order(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    await order.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Order(order);
                    enlistmentState.RollbackStack.Push(() => order.CopyFrom(originalRow));
                    var newAccount = this.fixture.Accounts.Find(order.AccountId);
                    if (newAccount == null)
                    {
                        throw new ConstraintException("The add action conflicted with the constraint AccountOrderIndex.");
                    }

                    await newAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    newAccount.Orders.Add(order);
                    enlistmentState.RollbackStack.Push(() => newAccount.Orders.Remove(order));
                    order.Account = newAccount;
                    var newAsset = this.fixture.Assets.Find(order.AssetId);
                    if (newAsset == null)
                    {
                        throw new ConstraintException("The add action conflicted with the constraint AssetOrderIndex.");
                    }

                    await newAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    newAsset.Orders.Add(order);
                    enlistmentState.RollbackStack.Push(() => newAsset.Orders.Remove(order));
                    order.Asset = newAsset;
                    order.RowVersion = this.fixture.IncrementRowVersion();
                    this.dictionary.Add((order.AccountId, order.AssetId), order);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((order.AccountId, order.AssetId)));
                    var clonedRow = new Order(order);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                    addedRows.Add(clonedRow);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The <see cref="Order"/> row.</param>
        /// <returns>The added or updated <see cref="Order"/> row.</returns>
        public async Task<(Order? AddedRow, Order? UpdatedRow)> PutAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Order(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (order.RowVersion != foundRow.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                foundRow.AccountId = order.AccountId;
                foundRow.AssetId = order.AssetId;
                foundRow.Quantity = order.Quantity;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                var clonedRow = new Order(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return (AddedRow: null, UpdatedRow: clonedRow);
            }
            else
            {
                await order.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Order(order);
                enlistmentState.RollbackStack.Push(() => order.CopyFrom(originalRow));
                var newAccount = this.fixture.Accounts.Find(order.AccountId);
                if (newAccount == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AccountOrderIndex.");
                }

                await newAccount.EnterWriteLockAsync().ConfigureAwait(false);
                newAccount.Orders.Add(order);
                enlistmentState.RollbackStack.Push(() => newAccount.Orders.Remove(order));
                order.Account = newAccount;
                var newAsset = this.fixture.Assets.Find(order.AssetId);
                if (newAsset == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AssetOrderIndex.");
                }

                await newAsset.EnterWriteLockAsync().ConfigureAwait(false);
                newAsset.Orders.Add(order);
                enlistmentState.RollbackStack.Push(() => newAsset.Orders.Remove(order));
                order.Asset = newAsset;
                order.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Add((order.AccountId, order.AssetId), order);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((order.AccountId, order.AssetId)));
                var clonedRow = new Order(order);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                return (AddedRow: clonedRow, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">A collection of <see cref="Order"/> rows.</param>
        /// <returns>The removed <see cref="Order"/> rows.</returns>
        public async Task<IEnumerable<Order>> RemoveAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Order>();
            foreach (var order in orders)
            {
                if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Order(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (foundRow.RowVersion != order.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    var oldAccount = this.fixture.Accounts.Find(order.AccountId);
                    ArgumentNullException.ThrowIfNull(oldAccount);
                    await oldAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    oldAccount.Orders.Remove(order);
                    enlistmentState.RollbackStack.Push(() => oldAccount.Orders.Add(order));
                    order.Account = null;
                    var oldAsset = this.fixture.Assets.Find(order.AssetId);
                    ArgumentNullException.ThrowIfNull(oldAsset);
                    await oldAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    oldAsset.Orders.Remove(order);
                    enlistmentState.RollbackStack.Push(() => oldAsset.Orders.Add(order));
                    order.Asset = null;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow));
                    var clonedRow = new Order(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                    removedRows.Add(clonedRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The <see cref="Order"/> row.</param>
        /// <returns>The removed <see cref="Order"/> row.</returns>
        public async Task<Order?> RemoveAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Order(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (foundRow.RowVersion != order.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                var oldAccount = this.fixture.Accounts.Find(order.AccountId);
                ArgumentNullException.ThrowIfNull(oldAccount);
                await oldAccount.EnterWriteLockAsync().ConfigureAwait(false);
                oldAccount.Orders.Remove(order);
                enlistmentState.RollbackStack.Push(() => oldAccount.Orders.Add(order));
                order.Account = null;
                var oldAsset = this.fixture.Assets.Find(order.AssetId);
                ArgumentNullException.ThrowIfNull(oldAsset);
                await oldAsset.EnterWriteLockAsync().ConfigureAwait(false);
                oldAsset.Orders.Remove(order);
                enlistmentState.RollbackStack.Push(() => oldAsset.Orders.Add(order));
                order.Asset = null;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                enlistmentState.RollbackStack.Push(() => this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow));
                var clonedRow = new Order(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                return clonedRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.RollbackStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Order"/> row in the table.
        /// </summary>
        /// <param name="orders">The order row.</param>
        public async Task<IEnumerable<Order>> UpdateAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Order>();
            foreach (var order in orders)
            {
                if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Order(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (order.RowVersion != foundRow.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    foundRow.AccountId = order.AccountId;
                    foundRow.AssetId = order.AssetId;
                    foundRow.Quantity = order.Quantity;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    var clonedRow = new Order(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Order"/> row in the table.
        /// </summary>
        /// <param name="order">The order row.</param>
        public async Task<Order> UpdateAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Order(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (order.RowVersion != foundRow.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                foundRow.AccountId = order.AccountId;
                foundRow.AssetId = order.AssetId;
                foundRow.Quantity = order.Quantity;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                var clonedRow = new Order(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return clonedRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// Controller for <see cref="Order"/> rows.
    /// </summary>
    [Route("fixture/[controller]")]
    [ApiController]
    [Authorize]
    public partial class OrdersController : ControllerBase
    {
        private readonly Fixture fixture;
        private readonly FixtureContext fixtureContext;
        private readonly ILogger logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="OrdersController"/> class.
        /// </summary>
        /// <param name="fixture">The data model.</param>
        /// <param name="fixtureContext">The DbContext for the data model.</param>
        /// <param name="logger">The log device.</param>
        public OrdersController(Fixture fixture, FixtureContext fixtureContext, ILogger<OrdersController> logger)
        {
            this.fixture = fixture;
            this.fixtureContext = fixtureContext;
            this.logger = logger;
        }

        /// <summary>
        /// Removes a <see cref="Order"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="order">The <see cref="Order"/> row to be deleted.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete("{accountId}/{assetId}")]
        public async Task<IActionResult> DeleteOrder([FromRoute] System.Guid accountId, [FromRoute] System.Guid assetId, [FromBody] Order order)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Orders.EnterWriteLockAsync().ConfigureAwait(false);
                if (this.fixture.Orders.Find(accountId, assetId) != null)
                {
                    var removedRow = await this.fixture.Orders.RemoveAsync(order).ConfigureAwait(false);
                    if (removedRow != null)
                    {
                        this.fixtureContext.Orders.Remove(order);
                        await this.fixtureContext.SaveChangesAsync();
                    }

                    asyncTransaction.Complete();
                }

                return this.Ok(order);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">A collection of <see cref="Order"/> rows.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete]
        public async Task<IActionResult> DeleteOrders([FromBody] IEnumerable<Order> orders)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Orders.EnterWriteLockAsync().ConfigureAwait(false);
                var deletedRows = await this.fixture.Orders.RemoveAsync(orders).ConfigureAwait(false);
                this.fixtureContext.Orders.RemoveRange(deletedRows);
                await this.fixtureContext.SaveChangesAsync();
                asyncTransaction.Complete();
                return this.Ok(deletedRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a specific <see cref="Order"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <returns>The row matching the key or NotFound.</returns>
        [HttpGet("{accountId}/{assetId}")]
        public async Task<IActionResult> GetOrder([FromRoute] System.Guid accountId, [FromRoute] System.Guid assetId)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Orders.EnterReadLockAsync().ConfigureAwait(false);
                var existingRow = this.fixture.Orders.Find(accountId, assetId);
                if (existingRow == null)
                {
                    return this.NotFound();
                }

                await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                return this.Ok(new Order(existingRow));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <returns>A collection of <see cref="Order"/> rows.</returns>
        [HttpGet]
        public async Task<IActionResult> GetOrders()
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Orders.EnterReadLockAsync().ConfigureAwait(false);
                var existingRows = new List<Order>();
                foreach (var existingRow in this.fixture.Orders)
                {
                    await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                    existingRows.Add(new Order(existingRow));
                }

                return this.Ok(existingRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Patches the <see cref="Order"/> table.
        /// </summary>
        /// <param name="orders">A collection of <see cref="Order"/> rows.</param>
        /// <returns>The result of applying the patch action.</returns>
        [HttpPatch]
        public async Task<IActionResult> PatchOrdersAsync([FromBody] IEnumerable<Order> orders)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Orders.EnterWriteLockAsync().ConfigureAwait(false);
                await this.fixture.Accounts.EnterReadLockAsync().ConfigureAwait(false);
                await this.fixture.Assets.EnterReadLockAsync().ConfigureAwait(false);
                (var addedRows, var updatedRows) = await this.fixture.Orders.PatchAsync(orders).ConfigureAwait(false);
                this.fixtureContext.Orders.AddRange(addedRows);
                this.fixtureContext.Orders.UpdateRange(updatedRows);
                await this.fixtureContext.SaveChangesAsync().ConfigureAwait(false);
                asyncTransaction.Complete();
                return this.Ok(addedRows.Concat(updatedRows));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Puts the <see cref="Order"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="order">The <see cref="Order"/> row.</param>
        /// <returns>The result of applying the put action.</returns>
        [HttpPut("{accountId}/{assetId}")]
        public async Task<IActionResult> PutOrder([FromRoute] System.Guid accountId, [FromRoute] System.Guid assetId, [FromBody] Order order)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Orders.EnterWriteLockAsync().ConfigureAwait(false);
                (var addedRow, var updatedRow) = await this.fixture.Orders.PutAsync(order).ConfigureAwait(false);
                if (addedRow != null)
                {
                    this.fixtureContext.Add(addedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Complete();
                    return this.Ok(addedRow);
                }

                if (updatedRow != null)
                {
                    this.fixtureContext.Update(updatedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Complete();
                    return this.Ok(updatedRow);
                }

                throw new InvalidOperationException();
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }
    }

    /// <summary>
    /// A Position row.
    /// </summary>
    public class Position
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Position"/> class.
        /// </summary>
        public Position()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Position"/> class.
        /// </summary>
        /// /// <param name="position">The position.</param>
        public Position(Position position)
        {
            this.Account = position.Account;
            this.AccountId = position.AccountId;
            this.Asset = position.Asset;
            this.AssetId = position.AssetId;
            this.Quantity = position.Quantity;
            this.RowVersion = position.RowVersion;
        }

        /// <summary>
        /// Gets or sets the parent <see cref="Account"/> row.
        /// </summary>
        [JsonIgnore]
        public Account? Account { get; set; }

        /// <summary>
        /// Gets or sets the AccountId.
        /// </summary>
        [JsonPropertyName("accountId")]
        public System.Guid AccountId { get; set; }

        /// <summary>
        /// Gets or sets the parent <see cref="Asset"/> row.
        /// </summary>
        [JsonIgnore]
        public Asset? Asset { get; set; }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Quantity.
        /// </summary>
        [JsonPropertyName("quantity")]
        public decimal Quantity { get; set; }

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Shallow copy of a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The destination <see cref="Position"/> row.</param>
        public void CopyFrom(Position position)
        {
            this.Account = position.Account;
            this.AccountId = position.AccountId;
            this.Asset = position.Asset;
            this.AssetId = position.AssetId;
            this.Quantity = position.Quantity;
            this.RowVersion = position.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Position other && this.AccountId == other.AccountId && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AccountId.GetHashCode() + this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Position"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Positions(Fixture fixture) : IEnlistmentNotification, IEnumerable<Position>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<(System.Guid, System.Guid), Position> dictionary = new Dictionary<(System.Guid, System.Guid), Position>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Position"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Position> DeletedRows { get; } = new LinkedList<Position>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                ArgumentNullException.ThrowIfNull(asyncTransaction);
                if (asyncTransaction == null)
                {
                    return null;
                }

                if (asyncTransaction.CancellationToken.IsCancellationRequested)
                {
                    throw new OperationCanceledException();
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The <see cref="Position"/> row.</param>
        /// <returns>The added <see cref="Position"/> row.</returns>
        public async Task<Position> AddAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            await position.EnterWriteLockAsync().ConfigureAwait(false);
            var originalRow = new Position(position);
            enlistmentState.RollbackStack.Push(() => position.CopyFrom(originalRow));
            var newAccount = this.fixture.Accounts.Find(position.AccountId);
            if (newAccount == null)
            {
                throw new ConstraintException("The add action conflicted with the constraint AccountPositionIndex.");
            }

            await newAccount.EnterWriteLockAsync().ConfigureAwait(false);
            newAccount.Positions.Add(position);
            enlistmentState.RollbackStack.Push(() => newAccount.Positions.Remove(position));
            position.Account = newAccount;
            var newAsset = this.fixture.Assets.Find(position.AssetId);
            if (newAsset == null)
            {
                throw new ConstraintException("The add action conflicted with the constraint AssetPositionIndex.");
            }

            await newAsset.EnterWriteLockAsync().ConfigureAwait(false);
            newAsset.Positions.Add(position);
            enlistmentState.RollbackStack.Push(() => newAsset.Positions.Remove(position));
            position.Asset = newAsset;
            position.RowVersion = this.fixture.IncrementRowVersion();
            this.dictionary.Add((position.AccountId, position.AssetId), position);
            enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((position.AccountId, position.AssetId)));
            var clonedRow = new Position(position);
            enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
            return clonedRow;
        }

        /// <summary>
        /// Adds a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The collection of <see cref="Position"/> rows.</param>
        /// <returns>The added <see cref="Position"/> rows.</returns>
        public async Task<IEnumerable<Position>> AddAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Position>();
            foreach (var position in positions)
            {
                await position.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Position(position);
                enlistmentState.RollbackStack.Push(() => position.CopyFrom(originalRow));
                var newAccount = this.fixture.Accounts.Find(position.AccountId);
                if (newAccount == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AccountPositionIndex.");
                }

                await newAccount.EnterWriteLockAsync().ConfigureAwait(false);
                newAccount.Positions.Add(position);
                enlistmentState.RollbackStack.Push(() => newAccount.Positions.Remove(position));
                position.Account = newAccount;
                var newAsset = this.fixture.Assets.Find(position.AssetId);
                if (newAsset == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AssetPositionIndex.");
                }

                await newAsset.EnterWriteLockAsync().ConfigureAwait(false);
                newAsset.Positions.Add(position);
                enlistmentState.RollbackStack.Push(() => newAsset.Positions.Remove(position));
                position.Asset = newAsset;
                position.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Add((position.AccountId, position.AssetId), position);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((position.AccountId, position.AssetId)));
                var clonedRow = new Position(position);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                addedRows.Add(clonedRow);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.CommitStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Position"/> row using the unique key.
        /// </summary>
        /// <param name="accountId">The accountId.</param>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Position"/> row, or null if not found.</returns>
        public Position? Find(System.Guid accountId, System.Guid assetId)
        {
            return this.dictionary.TryGetValue((accountId, assetId), out var position) ? position : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Position> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The collection of <see cref="Position"/> rows to load.</param>
        public void Load(IEnumerable<Position> positions)
        {
            foreach (var position in positions)
            {
                var account = this.fixture.Accounts.Find(position.AccountId);
                if (account == null)
                {
                    throw new ConstraintException("The insert action conflicted with the constraint AccountPositionIndex");
                }

                account.Positions.Add(position);
                position.Account = account;
                var asset = this.fixture.Assets.Find(position.AssetId);
                if (asset == null)
                {
                    throw new ConstraintException("The insert action conflicted with the constraint AssetPositionIndex");
                }

                asset.Positions.Add(position);
                position.Asset = asset;
                this.dictionary.Add((position.AccountId, position.AssetId), position);
                this.fixture.RowVersion = position.RowVersion;
                this.OnRowChanged(DataAction.Add, position);
            }
        }

        /// <summary>
        /// Handles the <see cref="Position"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="position">The <see cref="Position"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Position position)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, position));
                }
                finally
                {
                }
            }

            if (dataAction == DataAction.Remove)
            {
                this.DeletedRows.AddFirst(position);
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The collection of <see cref="Position"/> rows.</param>
        /// <returns>The patched <see cref="Position"/> rows.</returns>
        public async Task<(IEnumerable<Position> AddedRows, IEnumerable<Position> UpdatedRows)> PatchAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Position>();
            var updatedRows = new List<Position>();
            foreach (var position in positions)
            {
                if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Position(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (position.RowVersion != foundRow.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    foundRow.AccountId = position.AccountId;
                    foundRow.AssetId = position.AssetId;
                    foundRow.Quantity = position.Quantity;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    var clonedRow = new Position(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    await position.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Position(position);
                    enlistmentState.RollbackStack.Push(() => position.CopyFrom(originalRow));
                    var newAccount = this.fixture.Accounts.Find(position.AccountId);
                    if (newAccount == null)
                    {
                        throw new ConstraintException("The add action conflicted with the constraint AccountPositionIndex.");
                    }

                    await newAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    newAccount.Positions.Add(position);
                    enlistmentState.RollbackStack.Push(() => newAccount.Positions.Remove(position));
                    position.Account = newAccount;
                    var newAsset = this.fixture.Assets.Find(position.AssetId);
                    if (newAsset == null)
                    {
                        throw new ConstraintException("The add action conflicted with the constraint AssetPositionIndex.");
                    }

                    await newAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    newAsset.Positions.Add(position);
                    enlistmentState.RollbackStack.Push(() => newAsset.Positions.Remove(position));
                    position.Asset = newAsset;
                    position.RowVersion = this.fixture.IncrementRowVersion();
                    this.dictionary.Add((position.AccountId, position.AssetId), position);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((position.AccountId, position.AssetId)));
                    var clonedRow = new Position(position);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                    addedRows.Add(clonedRow);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The <see cref="Position"/> row.</param>
        /// <returns>The added or updated <see cref="Position"/> row.</returns>
        public async Task<(Position? AddedRow, Position? UpdatedRow)> PutAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Position(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (position.RowVersion != foundRow.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                foundRow.AccountId = position.AccountId;
                foundRow.AssetId = position.AssetId;
                foundRow.Quantity = position.Quantity;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                var clonedRow = new Position(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return (AddedRow: null, UpdatedRow: clonedRow);
            }
            else
            {
                await position.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Position(position);
                enlistmentState.RollbackStack.Push(() => position.CopyFrom(originalRow));
                var newAccount = this.fixture.Accounts.Find(position.AccountId);
                if (newAccount == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AccountPositionIndex.");
                }

                await newAccount.EnterWriteLockAsync().ConfigureAwait(false);
                newAccount.Positions.Add(position);
                enlistmentState.RollbackStack.Push(() => newAccount.Positions.Remove(position));
                position.Account = newAccount;
                var newAsset = this.fixture.Assets.Find(position.AssetId);
                if (newAsset == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AssetPositionIndex.");
                }

                await newAsset.EnterWriteLockAsync().ConfigureAwait(false);
                newAsset.Positions.Add(position);
                enlistmentState.RollbackStack.Push(() => newAsset.Positions.Remove(position));
                position.Asset = newAsset;
                position.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Add((position.AccountId, position.AssetId), position);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((position.AccountId, position.AssetId)));
                var clonedRow = new Position(position);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                return (AddedRow: clonedRow, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">A collection of <see cref="Position"/> rows.</param>
        /// <returns>The removed <see cref="Position"/> rows.</returns>
        public async Task<IEnumerable<Position>> RemoveAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Position>();
            foreach (var position in positions)
            {
                if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Position(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (foundRow.RowVersion != position.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    var oldAccount = this.fixture.Accounts.Find(position.AccountId);
                    ArgumentNullException.ThrowIfNull(oldAccount);
                    await oldAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    oldAccount.Positions.Remove(position);
                    enlistmentState.RollbackStack.Push(() => oldAccount.Positions.Add(position));
                    position.Account = null;
                    var oldAsset = this.fixture.Assets.Find(position.AssetId);
                    ArgumentNullException.ThrowIfNull(oldAsset);
                    await oldAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    oldAsset.Positions.Remove(position);
                    enlistmentState.RollbackStack.Push(() => oldAsset.Positions.Add(position));
                    position.Asset = null;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow));
                    var clonedRow = new Position(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                    removedRows.Add(clonedRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The <see cref="Position"/> row.</param>
        /// <returns>The removed <see cref="Position"/> row.</returns>
        public async Task<Position?> RemoveAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Position(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (foundRow.RowVersion != position.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                var oldAccount = this.fixture.Accounts.Find(position.AccountId);
                ArgumentNullException.ThrowIfNull(oldAccount);
                await oldAccount.EnterWriteLockAsync().ConfigureAwait(false);
                oldAccount.Positions.Remove(position);
                enlistmentState.RollbackStack.Push(() => oldAccount.Positions.Add(position));
                position.Account = null;
                var oldAsset = this.fixture.Assets.Find(position.AssetId);
                ArgumentNullException.ThrowIfNull(oldAsset);
                await oldAsset.EnterWriteLockAsync().ConfigureAwait(false);
                oldAsset.Positions.Remove(position);
                enlistmentState.RollbackStack.Push(() => oldAsset.Positions.Add(position));
                position.Asset = null;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                enlistmentState.RollbackStack.Push(() => this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow));
                var clonedRow = new Position(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                return clonedRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.RollbackStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Position"/> row in the table.
        /// </summary>
        /// <param name="positions">The position row.</param>
        public async Task<IEnumerable<Position>> UpdateAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Position>();
            foreach (var position in positions)
            {
                if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Position(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (position.RowVersion != foundRow.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    foundRow.AccountId = position.AccountId;
                    foundRow.AssetId = position.AssetId;
                    foundRow.Quantity = position.Quantity;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    var clonedRow = new Position(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Position"/> row in the table.
        /// </summary>
        /// <param name="position">The position row.</param>
        public async Task<Position> UpdateAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Position(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (position.RowVersion != foundRow.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                foundRow.AccountId = position.AccountId;
                foundRow.AssetId = position.AssetId;
                foundRow.Quantity = position.Quantity;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                var clonedRow = new Position(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return clonedRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// Controller for <see cref="Position"/> rows.
    /// </summary>
    [Route("fixture/[controller]")]
    [ApiController]
    [Authorize]
    public partial class PositionsController : ControllerBase
    {
        private readonly Fixture fixture;
        private readonly FixtureContext fixtureContext;
        private readonly ILogger logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="PositionsController"/> class.
        /// </summary>
        /// <param name="fixture">The data model.</param>
        /// <param name="fixtureContext">The DbContext for the data model.</param>
        /// <param name="logger">The log device.</param>
        public PositionsController(Fixture fixture, FixtureContext fixtureContext, ILogger<PositionsController> logger)
        {
            this.fixture = fixture;
            this.fixtureContext = fixtureContext;
            this.logger = logger;
        }

        /// <summary>
        /// Removes a <see cref="Position"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="position">The <see cref="Position"/> row to be deleted.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete("{accountId}/{assetId}")]
        public async Task<IActionResult> DeletePosition([FromRoute] System.Guid accountId, [FromRoute] System.Guid assetId, [FromBody] Position position)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Positions.EnterWriteLockAsync().ConfigureAwait(false);
                if (this.fixture.Positions.Find(accountId, assetId) != null)
                {
                    var removedRow = await this.fixture.Positions.RemoveAsync(position).ConfigureAwait(false);
                    if (removedRow != null)
                    {
                        this.fixtureContext.Positions.Remove(position);
                        await this.fixtureContext.SaveChangesAsync();
                    }

                    asyncTransaction.Complete();
                }

                return this.Ok(position);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">A collection of <see cref="Position"/> rows.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete]
        public async Task<IActionResult> DeletePositions([FromBody] IEnumerable<Position> positions)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Positions.EnterWriteLockAsync().ConfigureAwait(false);
                var deletedRows = await this.fixture.Positions.RemoveAsync(positions).ConfigureAwait(false);
                this.fixtureContext.Positions.RemoveRange(deletedRows);
                await this.fixtureContext.SaveChangesAsync();
                asyncTransaction.Complete();
                return this.Ok(deletedRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a specific <see cref="Position"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <returns>The row matching the key or NotFound.</returns>
        [HttpGet("{accountId}/{assetId}")]
        public async Task<IActionResult> GetPosition([FromRoute] System.Guid accountId, [FromRoute] System.Guid assetId)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Positions.EnterReadLockAsync().ConfigureAwait(false);
                var existingRow = this.fixture.Positions.Find(accountId, assetId);
                if (existingRow == null)
                {
                    return this.NotFound();
                }

                await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                return this.Ok(new Position(existingRow));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <returns>A collection of <see cref="Position"/> rows.</returns>
        [HttpGet]
        public async Task<IActionResult> GetPositions()
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Positions.EnterReadLockAsync().ConfigureAwait(false);
                var existingRows = new List<Position>();
                foreach (var existingRow in this.fixture.Positions)
                {
                    await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                    existingRows.Add(new Position(existingRow));
                }

                return this.Ok(existingRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Patches the <see cref="Position"/> table.
        /// </summary>
        /// <param name="positions">A collection of <see cref="Position"/> rows.</param>
        /// <returns>The result of applying the patch action.</returns>
        [HttpPatch]
        public async Task<IActionResult> PatchPositionsAsync([FromBody] IEnumerable<Position> positions)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Positions.EnterWriteLockAsync().ConfigureAwait(false);
                await this.fixture.Accounts.EnterReadLockAsync().ConfigureAwait(false);
                await this.fixture.Assets.EnterReadLockAsync().ConfigureAwait(false);
                (var addedRows, var updatedRows) = await this.fixture.Positions.PatchAsync(positions).ConfigureAwait(false);
                this.fixtureContext.Positions.AddRange(addedRows);
                this.fixtureContext.Positions.UpdateRange(updatedRows);
                await this.fixtureContext.SaveChangesAsync().ConfigureAwait(false);
                asyncTransaction.Complete();
                return this.Ok(addedRows.Concat(updatedRows));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Puts the <see cref="Position"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="position">The <see cref="Position"/> row.</param>
        /// <returns>The result of applying the put action.</returns>
        [HttpPut("{accountId}/{assetId}")]
        public async Task<IActionResult> PutPosition([FromRoute] System.Guid accountId, [FromRoute] System.Guid assetId, [FromBody] Position position)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Positions.EnterWriteLockAsync().ConfigureAwait(false);
                (var addedRow, var updatedRow) = await this.fixture.Positions.PutAsync(position).ConfigureAwait(false);
                if (addedRow != null)
                {
                    this.fixtureContext.Add(addedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Complete();
                    return this.Ok(addedRow);
                }

                if (updatedRow != null)
                {
                    this.fixtureContext.Update(updatedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Complete();
                    return this.Ok(updatedRow);
                }

                throw new InvalidOperationException();
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }
    }

    /// <summary>
    /// A Quote row.
    /// </summary>
    public class Quote
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Quote"/> class.
        /// </summary>
        public Quote()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Quote"/> class.
        /// </summary>
        /// /// <param name="quote">The quote.</param>
        public Quote(Quote quote)
        {
            this.Asset = quote.Asset;
            this.AssetId = quote.AssetId;
            this.Last = quote.Last;
            this.RowVersion = quote.RowVersion;
        }

        /// <summary>
        /// Gets or sets the parent <see cref="Asset"/> row.
        /// </summary>
        [JsonIgnore]
        public Asset? Asset { get; set; }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Last.
        /// </summary>
        [JsonPropertyName("last")]
        public decimal Last { get; set; }

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Shallow copy of a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The destination <see cref="Quote"/> row.</param>
        public void CopyFrom(Quote quote)
        {
            this.Asset = quote.Asset;
            this.AssetId = quote.AssetId;
            this.Last = quote.Last;
            this.RowVersion = quote.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Quote other && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Quote"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Quotes(Fixture fixture) : IEnlistmentNotification, IEnumerable<Quote>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<System.Guid, Quote> dictionary = new Dictionary<System.Guid, Quote>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Quote"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Quote> DeletedRows { get; } = new LinkedList<Quote>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                ArgumentNullException.ThrowIfNull(asyncTransaction);
                if (asyncTransaction == null)
                {
                    return null;
                }

                if (asyncTransaction.CancellationToken.IsCancellationRequested)
                {
                    throw new OperationCanceledException();
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The <see cref="Quote"/> row.</param>
        /// <returns>The added <see cref="Quote"/> row.</returns>
        public async Task<Quote> AddAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            await quote.EnterWriteLockAsync().ConfigureAwait(false);
            var originalRow = new Quote(quote);
            enlistmentState.RollbackStack.Push(() => quote.CopyFrom(originalRow));
            var newAsset = this.fixture.Assets.Find(quote.AssetId);
            if (newAsset == null)
            {
                throw new ConstraintException("The add action conflicted with the constraint AssetQuoteIndex.");
            }

            await newAsset.EnterWriteLockAsync().ConfigureAwait(false);
            newAsset.Quotes.Add(quote);
            enlistmentState.RollbackStack.Push(() => newAsset.Quotes.Remove(quote));
            quote.Asset = newAsset;
            quote.RowVersion = this.fixture.IncrementRowVersion();
            this.dictionary.Add(quote.AssetId, quote);
            enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(quote.AssetId));
            var clonedRow = new Quote(quote);
            enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
            return clonedRow;
        }

        /// <summary>
        /// Adds a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The collection of <see cref="Quote"/> rows.</param>
        /// <returns>The added <see cref="Quote"/> rows.</returns>
        public async Task<IEnumerable<Quote>> AddAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                await quote.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Quote(quote);
                enlistmentState.RollbackStack.Push(() => quote.CopyFrom(originalRow));
                var newAsset = this.fixture.Assets.Find(quote.AssetId);
                if (newAsset == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AssetQuoteIndex.");
                }

                await newAsset.EnterWriteLockAsync().ConfigureAwait(false);
                newAsset.Quotes.Add(quote);
                enlistmentState.RollbackStack.Push(() => newAsset.Quotes.Remove(quote));
                quote.Asset = newAsset;
                quote.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Add(quote.AssetId, quote);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(quote.AssetId));
                var clonedRow = new Quote(quote);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                addedRows.Add(clonedRow);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.CommitStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Quote"/> row using the unique key.
        /// </summary>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Quote"/> row, or null if not found.</returns>
        public Quote? Find(System.Guid assetId)
        {
            return this.dictionary.TryGetValue(assetId, out var quote) ? quote : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Quote> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The collection of <see cref="Quote"/> rows to load.</param>
        public void Load(IEnumerable<Quote> quotes)
        {
            foreach (var quote in quotes)
            {
                var asset = this.fixture.Assets.Find(quote.AssetId);
                if (asset == null)
                {
                    throw new ConstraintException("The insert action conflicted with the constraint AssetQuoteIndex");
                }

                asset.Quotes.Add(quote);
                quote.Asset = asset;
                this.dictionary.Add(quote.AssetId, quote);
                this.fixture.RowVersion = quote.RowVersion;
                this.OnRowChanged(DataAction.Add, quote);
            }
        }

        /// <summary>
        /// Handles the <see cref="Quote"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="quote">The <see cref="Quote"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Quote quote)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, quote));
                }
                finally
                {
                }
            }

            if (dataAction == DataAction.Remove)
            {
                this.DeletedRows.AddFirst(quote);
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The collection of <see cref="Quote"/> rows.</param>
        /// <returns>The patched <see cref="Quote"/> rows.</returns>
        public async Task<(IEnumerable<Quote> AddedRows, IEnumerable<Quote> UpdatedRows)> PatchAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Quote>();
            var updatedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Quote(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (quote.RowVersion != foundRow.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    foundRow.AssetId = quote.AssetId;
                    foundRow.Last = quote.Last;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    var clonedRow = new Quote(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    await quote.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Quote(quote);
                    enlistmentState.RollbackStack.Push(() => quote.CopyFrom(originalRow));
                    var newAsset = this.fixture.Assets.Find(quote.AssetId);
                    if (newAsset == null)
                    {
                        throw new ConstraintException("The add action conflicted with the constraint AssetQuoteIndex.");
                    }

                    await newAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    newAsset.Quotes.Add(quote);
                    enlistmentState.RollbackStack.Push(() => newAsset.Quotes.Remove(quote));
                    quote.Asset = newAsset;
                    quote.RowVersion = this.fixture.IncrementRowVersion();
                    this.dictionary.Add(quote.AssetId, quote);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(quote.AssetId));
                    var clonedRow = new Quote(quote);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                    addedRows.Add(clonedRow);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The <see cref="Quote"/> row.</param>
        /// <returns>The added or updated <see cref="Quote"/> row.</returns>
        public async Task<(Quote? AddedRow, Quote? UpdatedRow)> PutAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Quote(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (quote.RowVersion != foundRow.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                foundRow.AssetId = quote.AssetId;
                foundRow.Last = quote.Last;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                var clonedRow = new Quote(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return (AddedRow: null, UpdatedRow: clonedRow);
            }
            else
            {
                await quote.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Quote(quote);
                enlistmentState.RollbackStack.Push(() => quote.CopyFrom(originalRow));
                var newAsset = this.fixture.Assets.Find(quote.AssetId);
                if (newAsset == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AssetQuoteIndex.");
                }

                await newAsset.EnterWriteLockAsync().ConfigureAwait(false);
                newAsset.Quotes.Add(quote);
                enlistmentState.RollbackStack.Push(() => newAsset.Quotes.Remove(quote));
                quote.Asset = newAsset;
                quote.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Add(quote.AssetId, quote);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(quote.AssetId));
                var clonedRow = new Quote(quote);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                return (AddedRow: clonedRow, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">A collection of <see cref="Quote"/> rows.</param>
        /// <returns>The removed <see cref="Quote"/> rows.</returns>
        public async Task<IEnumerable<Quote>> RemoveAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Quote(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (foundRow.RowVersion != quote.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    var oldAsset = this.fixture.Assets.Find(quote.AssetId);
                    ArgumentNullException.ThrowIfNull(oldAsset);
                    await oldAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    oldAsset.Quotes.Remove(quote);
                    enlistmentState.RollbackStack.Push(() => oldAsset.Quotes.Add(quote));
                    quote.Asset = null;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    this.dictionary.Remove(foundRow.AssetId);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Add(foundRow.AssetId, foundRow));
                    var clonedRow = new Quote(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                    removedRows.Add(clonedRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The <see cref="Quote"/> row.</param>
        /// <returns>The removed <see cref="Quote"/> row.</returns>
        public async Task<Quote?> RemoveAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Quote(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (foundRow.RowVersion != quote.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                var oldAsset = this.fixture.Assets.Find(quote.AssetId);
                ArgumentNullException.ThrowIfNull(oldAsset);
                await oldAsset.EnterWriteLockAsync().ConfigureAwait(false);
                oldAsset.Quotes.Remove(quote);
                enlistmentState.RollbackStack.Push(() => oldAsset.Quotes.Add(quote));
                quote.Asset = null;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Remove(foundRow.AssetId);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Add(foundRow.AssetId, foundRow));
                var clonedRow = new Quote(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                return clonedRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.RollbackStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Quote"/> row in the table.
        /// </summary>
        /// <param name="quotes">The quote row.</param>
        public async Task<IEnumerable<Quote>> UpdateAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Quote(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (quote.RowVersion != foundRow.RowVersion)
                    {
                        throw new ConcurrencyException();
                    }

                    foundRow.AssetId = quote.AssetId;
                    foundRow.Last = quote.Last;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    var clonedRow = new Quote(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Quote"/> row in the table.
        /// </summary>
        /// <param name="quote">The quote row.</param>
        public async Task<Quote> UpdateAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Quote(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (quote.RowVersion != foundRow.RowVersion)
                {
                    throw new ConcurrencyException();
                }

                foundRow.AssetId = quote.AssetId;
                foundRow.Last = quote.Last;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                var clonedRow = new Quote(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return clonedRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// Controller for <see cref="Quote"/> rows.
    /// </summary>
    [Route("fixture/[controller]")]
    [ApiController]
    [Authorize]
    public partial class QuotesController : ControllerBase
    {
        private readonly Fixture fixture;
        private readonly FixtureContext fixtureContext;
        private readonly ILogger logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="QuotesController"/> class.
        /// </summary>
        /// <param name="fixture">The data model.</param>
        /// <param name="fixtureContext">The DbContext for the data model.</param>
        /// <param name="logger">The log device.</param>
        public QuotesController(Fixture fixture, FixtureContext fixtureContext, ILogger<QuotesController> logger)
        {
            this.fixture = fixture;
            this.fixtureContext = fixtureContext;
            this.logger = logger;
        }

        /// <summary>
        /// Removes a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="quote">The <see cref="Quote"/> row to be deleted.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete("{assetId}")]
        public async Task<IActionResult> DeleteQuote([FromRoute] System.Guid assetId, [FromBody] Quote quote)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Quotes.EnterWriteLockAsync().ConfigureAwait(false);
                if (this.fixture.Quotes.Find(assetId) != null)
                {
                    var removedRow = await this.fixture.Quotes.RemoveAsync(quote).ConfigureAwait(false);
                    if (removedRow != null)
                    {
                        this.fixtureContext.Quotes.Remove(quote);
                        await this.fixtureContext.SaveChangesAsync();
                    }

                    asyncTransaction.Complete();
                }

                return this.Ok(quote);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">A collection of <see cref="Quote"/> rows.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete]
        public async Task<IActionResult> DeleteQuotes([FromBody] IEnumerable<Quote> quotes)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Quotes.EnterWriteLockAsync().ConfigureAwait(false);
                var deletedRows = await this.fixture.Quotes.RemoveAsync(quotes).ConfigureAwait(false);
                this.fixtureContext.Quotes.RemoveRange(deletedRows);
                await this.fixtureContext.SaveChangesAsync();
                asyncTransaction.Complete();
                return this.Ok(deletedRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a specific <see cref="Quote"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <returns>The row matching the key or NotFound.</returns>
        [HttpGet("{assetId}")]
        public async Task<IActionResult> GetQuote([FromRoute] System.Guid assetId)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Quotes.EnterReadLockAsync().ConfigureAwait(false);
                var existingRow = this.fixture.Quotes.Find(assetId);
                if (existingRow == null)
                {
                    return this.NotFound();
                }

                await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                return this.Ok(new Quote(existingRow));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <returns>A collection of <see cref="Quote"/> rows.</returns>
        [HttpGet]
        public async Task<IActionResult> GetQuotes()
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Quotes.EnterReadLockAsync().ConfigureAwait(false);
                var existingRows = new List<Quote>();
                foreach (var existingRow in this.fixture.Quotes)
                {
                    await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                    existingRows.Add(new Quote(existingRow));
                }

                return this.Ok(existingRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Patches the <see cref="Quote"/> table.
        /// </summary>
        /// <param name="quotes">A collection of <see cref="Quote"/> rows.</param>
        /// <returns>The result of applying the patch action.</returns>
        [HttpPatch]
        public async Task<IActionResult> PatchQuotesAsync([FromBody] IEnumerable<Quote> quotes)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Quotes.EnterWriteLockAsync().ConfigureAwait(false);
                await this.fixture.Assets.EnterReadLockAsync().ConfigureAwait(false);
                (var addedRows, var updatedRows) = await this.fixture.Quotes.PatchAsync(quotes).ConfigureAwait(false);
                this.fixtureContext.Quotes.AddRange(addedRows);
                this.fixtureContext.Quotes.UpdateRange(updatedRows);
                await this.fixtureContext.SaveChangesAsync().ConfigureAwait(false);
                asyncTransaction.Complete();
                return this.Ok(addedRows.Concat(updatedRows));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Puts the <see cref="Quote"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="quote">The <see cref="Quote"/> row.</param>
        /// <returns>The result of applying the put action.</returns>
        [HttpPut("{assetId}")]
        public async Task<IActionResult> PutQuote([FromRoute] System.Guid assetId, [FromBody] Quote quote)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Quotes.EnterWriteLockAsync().ConfigureAwait(false);
                (var addedRow, var updatedRow) = await this.fixture.Quotes.PutAsync(quote).ConfigureAwait(false);
                if (addedRow != null)
                {
                    this.fixtureContext.Add(addedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Complete();
                    return this.Ok(addedRow);
                }

                if (updatedRow != null)
                {
                    this.fixtureContext.Update(updatedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Complete();
                    return this.Ok(updatedRow);
                }

                throw new InvalidOperationException();
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }
    }
}

namespace UnitTest.Slave
{
    using System;
    using System.Collections;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net.Http;
    using System.Text;
    using System.Text.Json;
    using System.Text.Json.Serialization;
    using System.Threading;
    using System.Threading.Tasks;
    using System.Transactions;
    using DotNext.Threading;
    using Microsoft.Extensions.Configuration;
    using Microsoft.Extensions.Logging;
    using UnitTest;

    /// <summary>
    /// A Account row.
    /// </summary>
    public class Account
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Account"/> class.
        /// </summary>
        public Account()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Account"/> class.
        /// </summary>
        /// /// <param name="account">The account.</param>
        public Account(Account account)
        {
            this.AccountId = account.AccountId;
            this.Name = account.Name;
            this.Orders.UnionWith(account.Orders);
            this.Positions.UnionWith(account.Positions);
            this.RowVersion = account.RowVersion;
        }

        /// <summary>
        /// Gets or sets the AccountId.
        /// </summary>
        [JsonPropertyName("accountId")]
        public System.Guid AccountId { get; set; }

        /// <summary>
        /// Gets or sets the Name.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Gets the child <see cref="Order"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Order> Orders { get; } = new HashSet<Order>();

        /// <summary>
        /// Gets the child <see cref="Position"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Position> Positions { get; } = new HashSet<Position>();

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Shallow copy of a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The destination <see cref="Account"/> row.</param>
        public void CopyFrom(Account account)
        {
            this.AccountId = account.AccountId;
            this.Name = account.Name;
            this.Orders.Clear();
            this.Orders.UnionWith(account.Orders);
            this.Positions.Clear();
            this.Positions.UnionWith(account.Positions);
            this.RowVersion = account.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Account other && this.AccountId == other.AccountId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AccountId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Account"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Accounts(Fixture fixture) : IEnlistmentNotification, IEnumerable<Account>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<System.Guid, Account> dictionary = new Dictionary<System.Guid, Account>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Account"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Account> DeletedRows { get; } = new LinkedList<Account>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                ArgumentNullException.ThrowIfNull(asyncTransaction);
                if (asyncTransaction == null)
                {
                    return null;
                }

                if (asyncTransaction.CancellationToken.IsCancellationRequested)
                {
                    throw new OperationCanceledException();
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The <see cref="Account"/> row.</param>
        /// <returns>The added <see cref="Account"/> row.</returns>
        public async Task<Account> AddAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            await account.EnterWriteLockAsync().ConfigureAwait(true);
            var originalRow = new Account(account);
            enlistmentState.RollbackStack.Push(() => account.CopyFrom(originalRow));
            this.fixture.RowVersion = account.RowVersion;
            this.dictionary.Add(account.AccountId, account);
            enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(account.AccountId));
            var clonedRow = new Account(account);
            enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
            return clonedRow;
        }

        /// <summary>
        /// Adds a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The collection of <see cref="Account"/> rows.</param>
        /// <returns>The added <see cref="Account"/> rows.</returns>
        public async Task<IEnumerable<Account>> AddAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Account>();
            foreach (var account in accounts)
            {
                await account.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Account(account);
                enlistmentState.RollbackStack.Push(() => account.CopyFrom(originalRow));
                this.fixture.RowVersion = account.RowVersion;
                this.dictionary.Add(account.AccountId, account);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(account.AccountId));
                var clonedRow = new Account(account);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                addedRows.Add(clonedRow);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.CommitStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Account"/> row using the unique key.
        /// </summary>
        /// <param name="accountId">The accountId.</param>
        /// <returns>The found <see cref="Account"/> row, or null if not found.</returns>
        public Account? Find(System.Guid accountId)
        {
            return this.dictionary.TryGetValue(accountId, out var account) ? account : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Account> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The collection of <see cref="Account"/> rows to load.</param>
        public void Load(IEnumerable<Account> accounts)
        {
            foreach (var account in accounts)
            {
                this.dictionary.Add(account.AccountId, account);
                this.fixture.RowVersion = account.RowVersion;
                this.OnRowChanged(DataAction.Add, account);
            }
        }

        /// <summary>
        /// Handles the <see cref="Account"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="account">The <see cref="Account"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Account account)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, account));
                }
                finally
                {
                }
            }

            if (dataAction == DataAction.Remove)
            {
                this.DeletedRows.AddFirst(account);
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The collection of <see cref="Account"/> rows.</param>
        /// <returns>The patched <see cref="Account"/> rows.</returns>
        public async Task<(IEnumerable<Account> AddedRows, IEnumerable<Account> UpdatedRows)> PatchAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Account>();
            var updatedRows = new List<Account>();
            foreach (var account in accounts)
            {
                if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Account(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    foundRow.AccountId = account.AccountId;
                    foundRow.Name = account.Name;
                    this.fixture.RowVersion = account.RowVersion;
                    var clonedRow = new Account(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    await account.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Account(account);
                    enlistmentState.RollbackStack.Push(() => account.CopyFrom(originalRow));
                    this.fixture.RowVersion = account.RowVersion;
                    this.dictionary.Add(account.AccountId, account);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(account.AccountId));
                    var clonedRow = new Account(account);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                    addedRows.Add(clonedRow);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The <see cref="Account"/> row.</param>
        /// <returns>The added or updated <see cref="Account"/> row.</returns>
        public async Task<(Account? AddedRow, Account? UpdatedRow)> PutAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Account(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                foundRow.AccountId = account.AccountId;
                foundRow.Name = account.Name;
                this.fixture.RowVersion = account.RowVersion;
                var clonedRow = new Account(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return (AddedRow: null, UpdatedRow: clonedRow);
            }
            else
            {
                await account.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Account(account);
                enlistmentState.RollbackStack.Push(() => account.CopyFrom(originalRow));
                this.fixture.RowVersion = account.RowVersion;
                this.dictionary.Add(account.AccountId, account);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(account.AccountId));
                var clonedRow = new Account(account);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                return (AddedRow: clonedRow, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">A collection of <see cref="Account"/> rows.</param>
        /// <returns>The removed <see cref="Account"/> rows.</returns>
        public async Task<IEnumerable<Account>> RemoveAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Account>();
            foreach (var account in accounts)
            {
                if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Account(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (foundRow.Orders.Any())
                    {
                        throw new ConstraintException("The remove action conflicted with the constraint AccountOrderIndex");
                    }

                    if (foundRow.Positions.Any())
                    {
                        throw new ConstraintException("The remove action conflicted with the constraint AccountPositionIndex");
                    }

                    this.fixture.RowVersion = foundRow.RowVersion;
                    this.dictionary.Remove(foundRow.AccountId);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Add(foundRow.AccountId, foundRow));
                    var clonedRow = new Account(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                    removedRows.Add(clonedRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The <see cref="Account"/> row.</param>
        /// <returns>The removed <see cref="Account"/> row.</returns>
        public async Task<Account?> RemoveAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Account(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (foundRow.Orders.Any())
                {
                    throw new ConstraintException("The remove action conflicted with the constraint AccountOrderIndex");
                }

                if (foundRow.Positions.Any())
                {
                    throw new ConstraintException("The remove action conflicted with the constraint AccountPositionIndex");
                }

                this.fixture.RowVersion = foundRow.RowVersion;
                this.dictionary.Remove(foundRow.AccountId);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Add(foundRow.AccountId, foundRow));
                var clonedRow = new Account(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                return clonedRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.RollbackStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Account"/> row in the table.
        /// </summary>
        /// <param name="accounts">The account row.</param>
        public async Task<IEnumerable<Account>> UpdateAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Account>();
            foreach (var account in accounts)
            {
                if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Account(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    foundRow.AccountId = account.AccountId;
                    foundRow.Name = account.Name;
                    this.fixture.RowVersion = account.RowVersion;
                    var clonedRow = new Account(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Account"/> row in the table.
        /// </summary>
        /// <param name="account">The account row.</param>
        public async Task<Account> UpdateAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Account(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                foundRow.AccountId = account.AccountId;
                foundRow.Name = account.Name;
                this.fixture.RowVersion = account.RowVersion;
                var clonedRow = new Account(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return clonedRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// A Asset row.
    /// </summary>
    public class Asset
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Asset"/> class.
        /// </summary>
        public Asset()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Asset"/> class.
        /// </summary>
        /// /// <param name="asset">The asset.</param>
        public Asset(Asset asset)
        {
            this.AssetId = asset.AssetId;
            this.Name = asset.Name;
            this.Orders.UnionWith(asset.Orders);
            this.Positions.UnionWith(asset.Positions);
            this.Quotes.UnionWith(asset.Quotes);
            this.RowVersion = asset.RowVersion;
        }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Name.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Gets the child <see cref="Order"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Order> Orders { get; } = new HashSet<Order>();

        /// <summary>
        /// Gets the child <see cref="Position"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Position> Positions { get; } = new HashSet<Position>();

        /// <summary>
        /// Gets the child <see cref="Quote"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Quote> Quotes { get; } = new HashSet<Quote>();

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Shallow copy of a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The destination <see cref="Asset"/> row.</param>
        public void CopyFrom(Asset asset)
        {
            this.AssetId = asset.AssetId;
            this.Name = asset.Name;
            this.Orders.Clear();
            this.Orders.UnionWith(asset.Orders);
            this.Positions.Clear();
            this.Positions.UnionWith(asset.Positions);
            this.Quotes.Clear();
            this.Quotes.UnionWith(asset.Quotes);
            this.RowVersion = asset.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Asset other && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Asset"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Assets(Fixture fixture) : IEnlistmentNotification, IEnumerable<Asset>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<System.Guid, Asset> dictionary = new Dictionary<System.Guid, Asset>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Asset"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Asset> DeletedRows { get; } = new LinkedList<Asset>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                ArgumentNullException.ThrowIfNull(asyncTransaction);
                if (asyncTransaction == null)
                {
                    return null;
                }

                if (asyncTransaction.CancellationToken.IsCancellationRequested)
                {
                    throw new OperationCanceledException();
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The <see cref="Asset"/> row.</param>
        /// <returns>The added <see cref="Asset"/> row.</returns>
        public async Task<Asset> AddAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            await asset.EnterWriteLockAsync().ConfigureAwait(true);
            var originalRow = new Asset(asset);
            enlistmentState.RollbackStack.Push(() => asset.CopyFrom(originalRow));
            this.fixture.RowVersion = asset.RowVersion;
            this.dictionary.Add(asset.AssetId, asset);
            enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(asset.AssetId));
            var clonedRow = new Asset(asset);
            enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
            return clonedRow;
        }

        /// <summary>
        /// Adds a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The collection of <see cref="Asset"/> rows.</param>
        /// <returns>The added <see cref="Asset"/> rows.</returns>
        public async Task<IEnumerable<Asset>> AddAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                await asset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Asset(asset);
                enlistmentState.RollbackStack.Push(() => asset.CopyFrom(originalRow));
                this.fixture.RowVersion = asset.RowVersion;
                this.dictionary.Add(asset.AssetId, asset);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(asset.AssetId));
                var clonedRow = new Asset(asset);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                addedRows.Add(clonedRow);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.CommitStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Asset"/> row using the unique key.
        /// </summary>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Asset"/> row, or null if not found.</returns>
        public Asset? Find(System.Guid assetId)
        {
            return this.dictionary.TryGetValue(assetId, out var asset) ? asset : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Asset> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The collection of <see cref="Asset"/> rows to load.</param>
        public void Load(IEnumerable<Asset> assets)
        {
            foreach (var asset in assets)
            {
                this.dictionary.Add(asset.AssetId, asset);
                this.fixture.RowVersion = asset.RowVersion;
                this.OnRowChanged(DataAction.Add, asset);
            }
        }

        /// <summary>
        /// Handles the <see cref="Asset"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="asset">The <see cref="Asset"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Asset asset)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, asset));
                }
                finally
                {
                }
            }

            if (dataAction == DataAction.Remove)
            {
                this.DeletedRows.AddFirst(asset);
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The collection of <see cref="Asset"/> rows.</param>
        /// <returns>The patched <see cref="Asset"/> rows.</returns>
        public async Task<(IEnumerable<Asset> AddedRows, IEnumerable<Asset> UpdatedRows)> PatchAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Asset>();
            var updatedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Asset(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    foundRow.AssetId = asset.AssetId;
                    foundRow.Name = asset.Name;
                    this.fixture.RowVersion = asset.RowVersion;
                    var clonedRow = new Asset(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    await asset.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Asset(asset);
                    enlistmentState.RollbackStack.Push(() => asset.CopyFrom(originalRow));
                    this.fixture.RowVersion = asset.RowVersion;
                    this.dictionary.Add(asset.AssetId, asset);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(asset.AssetId));
                    var clonedRow = new Asset(asset);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                    addedRows.Add(clonedRow);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The <see cref="Asset"/> row.</param>
        /// <returns>The added or updated <see cref="Asset"/> row.</returns>
        public async Task<(Asset? AddedRow, Asset? UpdatedRow)> PutAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Asset(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                foundRow.AssetId = asset.AssetId;
                foundRow.Name = asset.Name;
                this.fixture.RowVersion = asset.RowVersion;
                var clonedRow = new Asset(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return (AddedRow: null, UpdatedRow: clonedRow);
            }
            else
            {
                await asset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Asset(asset);
                enlistmentState.RollbackStack.Push(() => asset.CopyFrom(originalRow));
                this.fixture.RowVersion = asset.RowVersion;
                this.dictionary.Add(asset.AssetId, asset);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(asset.AssetId));
                var clonedRow = new Asset(asset);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                return (AddedRow: clonedRow, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">A collection of <see cref="Asset"/> rows.</param>
        /// <returns>The removed <see cref="Asset"/> rows.</returns>
        public async Task<IEnumerable<Asset>> RemoveAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Asset(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    if (foundRow.Orders.Any())
                    {
                        throw new ConstraintException("The remove action conflicted with the constraint AssetOrderIndex");
                    }

                    if (foundRow.Positions.Any())
                    {
                        throw new ConstraintException("The remove action conflicted with the constraint AssetPositionIndex");
                    }

                    if (foundRow.Quotes.Any())
                    {
                        throw new ConstraintException("The remove action conflicted with the constraint AssetQuoteIndex");
                    }

                    this.fixture.RowVersion = foundRow.RowVersion;
                    this.dictionary.Remove(foundRow.AssetId);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Add(foundRow.AssetId, foundRow));
                    var clonedRow = new Asset(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                    removedRows.Add(clonedRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The <see cref="Asset"/> row.</param>
        /// <returns>The removed <see cref="Asset"/> row.</returns>
        public async Task<Asset?> RemoveAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Asset(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                if (foundRow.Orders.Any())
                {
                    throw new ConstraintException("The remove action conflicted with the constraint AssetOrderIndex");
                }

                if (foundRow.Positions.Any())
                {
                    throw new ConstraintException("The remove action conflicted with the constraint AssetPositionIndex");
                }

                if (foundRow.Quotes.Any())
                {
                    throw new ConstraintException("The remove action conflicted with the constraint AssetQuoteIndex");
                }

                this.fixture.RowVersion = foundRow.RowVersion;
                this.dictionary.Remove(foundRow.AssetId);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Add(foundRow.AssetId, foundRow));
                var clonedRow = new Asset(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                return clonedRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.RollbackStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Asset"/> row in the table.
        /// </summary>
        /// <param name="assets">The asset row.</param>
        public async Task<IEnumerable<Asset>> UpdateAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Asset(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    foundRow.AssetId = asset.AssetId;
                    foundRow.Name = asset.Name;
                    this.fixture.RowVersion = asset.RowVersion;
                    var clonedRow = new Asset(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Asset"/> row in the table.
        /// </summary>
        /// <param name="asset">The asset row.</param>
        public async Task<Asset> UpdateAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Asset(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                foundRow.AssetId = asset.AssetId;
                foundRow.Name = asset.Name;
                this.fixture.RowVersion = asset.RowVersion;
                var clonedRow = new Asset(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return clonedRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// A Fixture.
    /// </summary>
    public class Fixture
    {
        /// <summary>
        /// The master row version.
        /// </summary>
        private long rowVersion = 0;

        /// <summary>
        /// Initializes a new instance of the <see cref="Fixture"/> class.
        /// </summary>
        /// <param name="logger">The log device.</param>
        public Fixture(ILogger<Fixture> logger)
        {
            this.Logger = logger;
            this.Accounts = new Accounts(this);
            this.Assets = new Assets(this);
            this.Orders = new Orders(this);
            this.Positions = new Positions(this);
            this.Quotes = new Quotes(this);
        }

        /// <summary>
        /// Gets the <see cref="Accounts"/> table.
        /// </summary>
        public Accounts Accounts { get; }

        /// <summary>
        /// Gets the <see cref="Assets"/> table.
        /// </summary>
        public Assets Assets { get; }

        /// <summary>
        /// Gets the log device.
        /// </summary>
        internal ILogger Logger { get; }

        /// <summary>
        /// Gets the <see cref="Orders"/> table.
        /// </summary>
        public Orders Orders { get; }

        /// <summary>
        /// Gets the <see cref="Positions"/> table.
        /// </summary>
        public Positions Positions { get; }

        /// <summary>
        /// Gets the <see cref="Quotes"/> table.
        /// </summary>
        public Quotes Quotes { get; }

        /// <summary>
        /// Gets or sets the master row version.
        /// </summary>
        public long RowVersion
        {
            get
            {
                return System.Threading.Interlocked.Read(ref this.rowVersion);
            }

            set
            {
                if (this.rowVersion < value)
                {
                    System.Threading.Interlocked.Exchange(ref this.rowVersion, value);
                }
            }
        }

        /// <summary>
        /// Increment the master row version.
        /// </summary>
        /// <returns>The incremented row version.</returns>
        public long IncrementRowVersion()
        {
            return System.Threading.Interlocked.Increment(ref this.rowVersion);
        }
    }

    /// <summary>
    /// A <see cref="Fixture"/> adapter.
    /// </summary>
    public class FixtureAdapter(HttpClient httpClient)
    {
        /// <summary>
        /// Gets the HTTP client.
        /// </summary>
        public HttpClient HttpClient { get; } = httpClient;

        /// <summary>
        /// Gets the collectin of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Account>> GetAccountsAsync(CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, "fixture/accounts");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Account>>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRows);
            return deserializedRows;
        }

        /// <summary>
        /// Gets the collectin of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Asset>> GetAssetsAsync(CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, "fixture/assets");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Asset>>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRows);
            return deserializedRows;
        }

        /// <summary>
        /// Gets a <see cref="Account"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Account> GetAccountAsync(System.Guid accountId, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, $"fixture/accounts/{accountId}");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Account>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Gets a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Asset> GetAssetAsync(System.Guid assetId, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, $"fixture/assets/{assetId}");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Asset>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Gets a <see cref="Order"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Order> GetOrderAsync(System.Guid accountId, System.Guid assetId, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, $"fixture/orders/{accountId}/{assetId}");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Order>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Gets a <see cref="Position"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Position> GetPositionAsync(System.Guid accountId, System.Guid assetId, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, $"fixture/positions/{accountId}/{assetId}");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Position>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Gets a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Quote> GetQuoteAsync(System.Guid assetId, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, $"fixture/quotes/{assetId}");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Quote>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Gets the collectin of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Order>> GetOrdersAsync(CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, "fixture/orders");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Order>>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRows);
            return deserializedRows;
        }

        /// <summary>
        /// Gets the collectin of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Position>> GetPositionsAsync(CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, "fixture/positions");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Position>>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRows);
            return deserializedRows;
        }

        /// <summary>
        /// Gets the collectin of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Quote>> GetQuotesAsync(CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, "fixture/quotes");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Quote>>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRows);
            return deserializedRows;
        }

        /// <summary>
        /// Patchs a set of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The set of <see cref="Account"/> rows to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Account>> PatchAsync(IEnumerable<Account> accounts, CancellationToken cancellationToken = default)
        {
            if (accounts.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, "fixture/accounts");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(accounts), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Account>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return accounts;
        }

        /// <summary>
        /// Patchs a set of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The set of <see cref="Asset"/> rows to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Asset>> PatchAsync(IEnumerable<Asset> assets, CancellationToken cancellationToken = default)
        {
            if (assets.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, "fixture/assets");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(assets), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Asset>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return assets;
        }

        /// <summary>
        /// Patchs a set of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The set of <see cref="Order"/> rows to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Order>> PatchAsync(IEnumerable<Order> orders, CancellationToken cancellationToken = default)
        {
            if (orders.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, "fixture/orders");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(orders), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Order>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return orders;
        }

        /// <summary>
        /// Patchs a set of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The set of <see cref="Position"/> rows to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Position>> PatchAsync(IEnumerable<Position> positions, CancellationToken cancellationToken = default)
        {
            if (positions.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, "fixture/positions");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(positions), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Position>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return positions;
        }

        /// <summary>
        /// Patchs a set of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The set of <see cref="Quote"/> rows to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Quote>> PatchAsync(IEnumerable<Quote> quotes, CancellationToken cancellationToken = default)
        {
            if (quotes.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, "fixture/quotes");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(quotes), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Quote>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return quotes;
        }

        /// <summary>
        /// Puts a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">A <see cref="Account"/> row to put.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Account> PutAsync(Account account, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, $"fixture/accounts/{account.AccountId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(account), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Account>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Puts a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">A <see cref="Asset"/> row to put.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Asset> PutAsync(Asset asset, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, $"fixture/assets/{asset.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(asset), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Asset>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Puts a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">A <see cref="Order"/> row to put.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Order> PutAsync(Order order, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, $"fixture/orders/{order.AccountId}/{order.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(order), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Order>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Puts a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">A <see cref="Position"/> row to put.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Position> PutAsync(Position position, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, $"fixture/positions/{position.AccountId}/{position.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(position), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Position>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Puts a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">A <see cref="Quote"/> row to put.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Quote> PutAsync(Quote quote, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, $"fixture/quotes/{quote.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(quote), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Quote>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Removes a set of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The set of <see cref="Account"/> rows.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Account>> RemoveAsync(IEnumerable<Account> accounts, CancellationToken cancellationToken = default)
        {
            if (accounts.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, "fixture/accounts");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(accounts), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Account>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return accounts;
        }

        /// <summary>
        /// Removes a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">A <see cref="Account"/> row to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Account> RemoveAsync(Account account, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, $"fixture/accounts/{account.AccountId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(account), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Account>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Removes a set of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The set of <see cref="Asset"/> rows.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Asset>> RemoveAsync(IEnumerable<Asset> assets, CancellationToken cancellationToken = default)
        {
            if (assets.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, "fixture/assets");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(assets), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Asset>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return assets;
        }

        /// <summary>
        /// Removes a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">A <see cref="Asset"/> row to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Asset> RemoveAsync(Asset asset, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, $"fixture/assets/{asset.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(asset), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Asset>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Removes a set of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The set of <see cref="Order"/> rows.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Order>> RemoveAsync(IEnumerable<Order> orders, CancellationToken cancellationToken = default)
        {
            if (orders.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, "fixture/orders");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(orders), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Order>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return orders;
        }

        /// <summary>
        /// Removes a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">A <see cref="Order"/> row to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Order> RemoveAsync(Order order, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, $"fixture/orders/{order.AccountId}/{order.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(order), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Order>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Removes a set of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The set of <see cref="Position"/> rows.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Position>> RemoveAsync(IEnumerable<Position> positions, CancellationToken cancellationToken = default)
        {
            if (positions.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, "fixture/positions");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(positions), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Position>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return positions;
        }

        /// <summary>
        /// Removes a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">A <see cref="Position"/> row to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Position> RemoveAsync(Position position, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, $"fixture/positions/{position.AccountId}/{position.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(position), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Position>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Removes a set of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The set of <see cref="Quote"/> rows.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Quote>> RemoveAsync(IEnumerable<Quote> quotes, CancellationToken cancellationToken = default)
        {
            if (quotes.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, "fixture/quotes");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(quotes), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Quote>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return quotes;
        }

        /// <summary>
        /// Removes a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">A <see cref="Quote"/> row to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Quote> RemoveAsync(Quote quote, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, $"fixture/quotes/{quote.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(quote), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Quote>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }
    }

    /// <summary>
    /// A Order row.
    /// </summary>
    public class Order
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Order"/> class.
        /// </summary>
        public Order()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Order"/> class.
        /// </summary>
        /// /// <param name="order">The order.</param>
        public Order(Order order)
        {
            this.Account = order.Account;
            this.AccountId = order.AccountId;
            this.Asset = order.Asset;
            this.AssetId = order.AssetId;
            this.Quantity = order.Quantity;
            this.RowVersion = order.RowVersion;
        }

        /// <summary>
        /// Gets or sets the parent <see cref="Account"/> row.
        /// </summary>
        [JsonIgnore]
        public Account? Account { get; set; }

        /// <summary>
        /// Gets or sets the AccountId.
        /// </summary>
        [JsonPropertyName("accountId")]
        public System.Guid AccountId { get; set; }

        /// <summary>
        /// Gets or sets the parent <see cref="Asset"/> row.
        /// </summary>
        [JsonIgnore]
        public Asset? Asset { get; set; }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Quantity.
        /// </summary>
        [JsonPropertyName("quantity")]
        public decimal Quantity { get; set; }

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Shallow copy of a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The destination <see cref="Order"/> row.</param>
        public void CopyFrom(Order order)
        {
            this.Account = order.Account;
            this.AccountId = order.AccountId;
            this.Asset = order.Asset;
            this.AssetId = order.AssetId;
            this.Quantity = order.Quantity;
            this.RowVersion = order.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Order other && this.AccountId == other.AccountId && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AccountId.GetHashCode() + this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Order"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Orders(Fixture fixture) : IEnlistmentNotification, IEnumerable<Order>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<(System.Guid, System.Guid), Order> dictionary = new Dictionary<(System.Guid, System.Guid), Order>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Order"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Order> DeletedRows { get; } = new LinkedList<Order>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                ArgumentNullException.ThrowIfNull(asyncTransaction);
                if (asyncTransaction == null)
                {
                    return null;
                }

                if (asyncTransaction.CancellationToken.IsCancellationRequested)
                {
                    throw new OperationCanceledException();
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The <see cref="Order"/> row.</param>
        /// <returns>The added <see cref="Order"/> row.</returns>
        public async Task<Order> AddAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            await order.EnterWriteLockAsync().ConfigureAwait(true);
            var originalRow = new Order(order);
            enlistmentState.RollbackStack.Push(() => order.CopyFrom(originalRow));
            var newAccount = this.fixture.Accounts.Find(order.AccountId);
            if (newAccount == null)
            {
                throw new ConstraintException("The add action conflicted with the constraint AccountOrderIndex.");
            }

            await newAccount.EnterWriteLockAsync().ConfigureAwait(true);
            newAccount.Orders.Add(order);
            enlistmentState.RollbackStack.Push(() => newAccount.Orders.Remove(order));
            order.Account = newAccount;
            var newAsset = this.fixture.Assets.Find(order.AssetId);
            if (newAsset == null)
            {
                throw new ConstraintException("The add action conflicted with the constraint AssetOrderIndex.");
            }

            await newAsset.EnterWriteLockAsync().ConfigureAwait(true);
            newAsset.Orders.Add(order);
            enlistmentState.RollbackStack.Push(() => newAsset.Orders.Remove(order));
            order.Asset = newAsset;
            this.fixture.RowVersion = order.RowVersion;
            this.dictionary.Add((order.AccountId, order.AssetId), order);
            enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((order.AccountId, order.AssetId)));
            var clonedRow = new Order(order);
            enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
            return clonedRow;
        }

        /// <summary>
        /// Adds a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The collection of <see cref="Order"/> rows.</param>
        /// <returns>The added <see cref="Order"/> rows.</returns>
        public async Task<IEnumerable<Order>> AddAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Order>();
            foreach (var order in orders)
            {
                await order.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Order(order);
                enlistmentState.RollbackStack.Push(() => order.CopyFrom(originalRow));
                var newAccount = this.fixture.Accounts.Find(order.AccountId);
                if (newAccount == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AccountOrderIndex.");
                }

                await newAccount.EnterWriteLockAsync().ConfigureAwait(true);
                newAccount.Orders.Add(order);
                enlistmentState.RollbackStack.Push(() => newAccount.Orders.Remove(order));
                order.Account = newAccount;
                var newAsset = this.fixture.Assets.Find(order.AssetId);
                if (newAsset == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AssetOrderIndex.");
                }

                await newAsset.EnterWriteLockAsync().ConfigureAwait(true);
                newAsset.Orders.Add(order);
                enlistmentState.RollbackStack.Push(() => newAsset.Orders.Remove(order));
                order.Asset = newAsset;
                this.fixture.RowVersion = order.RowVersion;
                this.dictionary.Add((order.AccountId, order.AssetId), order);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((order.AccountId, order.AssetId)));
                var clonedRow = new Order(order);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                addedRows.Add(clonedRow);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.CommitStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Order"/> row using the unique key.
        /// </summary>
        /// <param name="accountId">The accountId.</param>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Order"/> row, or null if not found.</returns>
        public Order? Find(System.Guid accountId, System.Guid assetId)
        {
            return this.dictionary.TryGetValue((accountId, assetId), out var order) ? order : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Order> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The collection of <see cref="Order"/> rows to load.</param>
        public void Load(IEnumerable<Order> orders)
        {
            foreach (var order in orders)
            {
                var account = this.fixture.Accounts.Find(order.AccountId);
                if (account == null)
                {
                    throw new ConstraintException("The insert action conflicted with the constraint AccountOrderIndex");
                }

                account.Orders.Add(order);
                order.Account = account;
                var asset = this.fixture.Assets.Find(order.AssetId);
                if (asset == null)
                {
                    throw new ConstraintException("The insert action conflicted with the constraint AssetOrderIndex");
                }

                asset.Orders.Add(order);
                order.Asset = asset;
                this.dictionary.Add((order.AccountId, order.AssetId), order);
                this.fixture.RowVersion = order.RowVersion;
                this.OnRowChanged(DataAction.Add, order);
            }
        }

        /// <summary>
        /// Handles the <see cref="Order"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="order">The <see cref="Order"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Order order)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, order));
                }
                finally
                {
                }
            }

            if (dataAction == DataAction.Remove)
            {
                this.DeletedRows.AddFirst(order);
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The collection of <see cref="Order"/> rows.</param>
        /// <returns>The patched <see cref="Order"/> rows.</returns>
        public async Task<(IEnumerable<Order> AddedRows, IEnumerable<Order> UpdatedRows)> PatchAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Order>();
            var updatedRows = new List<Order>();
            foreach (var order in orders)
            {
                if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Order(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    foundRow.AccountId = order.AccountId;
                    foundRow.AssetId = order.AssetId;
                    foundRow.Quantity = order.Quantity;
                    this.fixture.RowVersion = order.RowVersion;
                    var clonedRow = new Order(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    await order.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Order(order);
                    enlistmentState.RollbackStack.Push(() => order.CopyFrom(originalRow));
                    var newAccount = this.fixture.Accounts.Find(order.AccountId);
                    if (newAccount == null)
                    {
                        throw new ConstraintException("The add action conflicted with the constraint AccountOrderIndex.");
                    }

                    await newAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    newAccount.Orders.Add(order);
                    enlistmentState.RollbackStack.Push(() => newAccount.Orders.Remove(order));
                    order.Account = newAccount;
                    var newAsset = this.fixture.Assets.Find(order.AssetId);
                    if (newAsset == null)
                    {
                        throw new ConstraintException("The add action conflicted with the constraint AssetOrderIndex.");
                    }

                    await newAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    newAsset.Orders.Add(order);
                    enlistmentState.RollbackStack.Push(() => newAsset.Orders.Remove(order));
                    order.Asset = newAsset;
                    this.fixture.RowVersion = order.RowVersion;
                    this.dictionary.Add((order.AccountId, order.AssetId), order);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((order.AccountId, order.AssetId)));
                    var clonedRow = new Order(order);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                    addedRows.Add(clonedRow);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The <see cref="Order"/> row.</param>
        /// <returns>The added or updated <see cref="Order"/> row.</returns>
        public async Task<(Order? AddedRow, Order? UpdatedRow)> PutAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Order(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                foundRow.AccountId = order.AccountId;
                foundRow.AssetId = order.AssetId;
                foundRow.Quantity = order.Quantity;
                this.fixture.RowVersion = order.RowVersion;
                var clonedRow = new Order(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return (AddedRow: null, UpdatedRow: clonedRow);
            }
            else
            {
                await order.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Order(order);
                enlistmentState.RollbackStack.Push(() => order.CopyFrom(originalRow));
                var newAccount = this.fixture.Accounts.Find(order.AccountId);
                if (newAccount == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AccountOrderIndex.");
                }

                await newAccount.EnterWriteLockAsync().ConfigureAwait(true);
                newAccount.Orders.Add(order);
                enlistmentState.RollbackStack.Push(() => newAccount.Orders.Remove(order));
                order.Account = newAccount;
                var newAsset = this.fixture.Assets.Find(order.AssetId);
                if (newAsset == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AssetOrderIndex.");
                }

                await newAsset.EnterWriteLockAsync().ConfigureAwait(true);
                newAsset.Orders.Add(order);
                enlistmentState.RollbackStack.Push(() => newAsset.Orders.Remove(order));
                order.Asset = newAsset;
                this.fixture.RowVersion = order.RowVersion;
                this.dictionary.Add((order.AccountId, order.AssetId), order);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((order.AccountId, order.AssetId)));
                var clonedRow = new Order(order);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                return (AddedRow: clonedRow, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">A collection of <see cref="Order"/> rows.</param>
        /// <returns>The removed <see cref="Order"/> rows.</returns>
        public async Task<IEnumerable<Order>> RemoveAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Order>();
            foreach (var order in orders)
            {
                if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Order(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    var oldAccount = this.fixture.Accounts.Find(order.AccountId);
                    ArgumentNullException.ThrowIfNull(oldAccount);
                    await oldAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    oldAccount.Orders.Remove(order);
                    enlistmentState.RollbackStack.Push(() => oldAccount.Orders.Add(order));
                    order.Account = null;
                    var oldAsset = this.fixture.Assets.Find(order.AssetId);
                    ArgumentNullException.ThrowIfNull(oldAsset);
                    await oldAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    oldAsset.Orders.Remove(order);
                    enlistmentState.RollbackStack.Push(() => oldAsset.Orders.Add(order));
                    order.Asset = null;
                    this.fixture.RowVersion = foundRow.RowVersion;
                    this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow));
                    var clonedRow = new Order(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                    removedRows.Add(clonedRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The <see cref="Order"/> row.</param>
        /// <returns>The removed <see cref="Order"/> row.</returns>
        public async Task<Order?> RemoveAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Order(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                var oldAccount = this.fixture.Accounts.Find(order.AccountId);
                ArgumentNullException.ThrowIfNull(oldAccount);
                await oldAccount.EnterWriteLockAsync().ConfigureAwait(true);
                oldAccount.Orders.Remove(order);
                enlistmentState.RollbackStack.Push(() => oldAccount.Orders.Add(order));
                order.Account = null;
                var oldAsset = this.fixture.Assets.Find(order.AssetId);
                ArgumentNullException.ThrowIfNull(oldAsset);
                await oldAsset.EnterWriteLockAsync().ConfigureAwait(true);
                oldAsset.Orders.Remove(order);
                enlistmentState.RollbackStack.Push(() => oldAsset.Orders.Add(order));
                order.Asset = null;
                this.fixture.RowVersion = foundRow.RowVersion;
                this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                enlistmentState.RollbackStack.Push(() => this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow));
                var clonedRow = new Order(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                return clonedRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.RollbackStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Order"/> row in the table.
        /// </summary>
        /// <param name="orders">The order row.</param>
        public async Task<IEnumerable<Order>> UpdateAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Order>();
            foreach (var order in orders)
            {
                if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Order(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    foundRow.AccountId = order.AccountId;
                    foundRow.AssetId = order.AssetId;
                    foundRow.Quantity = order.Quantity;
                    this.fixture.RowVersion = order.RowVersion;
                    var clonedRow = new Order(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Order"/> row in the table.
        /// </summary>
        /// <param name="order">The order row.</param>
        public async Task<Order> UpdateAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Order(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                foundRow.AccountId = order.AccountId;
                foundRow.AssetId = order.AssetId;
                foundRow.Quantity = order.Quantity;
                this.fixture.RowVersion = order.RowVersion;
                var clonedRow = new Order(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return clonedRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// A Position row.
    /// </summary>
    public class Position
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Position"/> class.
        /// </summary>
        public Position()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Position"/> class.
        /// </summary>
        /// /// <param name="position">The position.</param>
        public Position(Position position)
        {
            this.Account = position.Account;
            this.AccountId = position.AccountId;
            this.Asset = position.Asset;
            this.AssetId = position.AssetId;
            this.Quantity = position.Quantity;
            this.RowVersion = position.RowVersion;
        }

        /// <summary>
        /// Gets or sets the parent <see cref="Account"/> row.
        /// </summary>
        [JsonIgnore]
        public Account? Account { get; set; }

        /// <summary>
        /// Gets or sets the AccountId.
        /// </summary>
        [JsonPropertyName("accountId")]
        public System.Guid AccountId { get; set; }

        /// <summary>
        /// Gets or sets the parent <see cref="Asset"/> row.
        /// </summary>
        [JsonIgnore]
        public Asset? Asset { get; set; }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Quantity.
        /// </summary>
        [JsonPropertyName("quantity")]
        public decimal Quantity { get; set; }

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Shallow copy of a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The destination <see cref="Position"/> row.</param>
        public void CopyFrom(Position position)
        {
            this.Account = position.Account;
            this.AccountId = position.AccountId;
            this.Asset = position.Asset;
            this.AssetId = position.AssetId;
            this.Quantity = position.Quantity;
            this.RowVersion = position.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Position other && this.AccountId == other.AccountId && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AccountId.GetHashCode() + this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Position"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Positions(Fixture fixture) : IEnlistmentNotification, IEnumerable<Position>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<(System.Guid, System.Guid), Position> dictionary = new Dictionary<(System.Guid, System.Guid), Position>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Position"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Position> DeletedRows { get; } = new LinkedList<Position>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                ArgumentNullException.ThrowIfNull(asyncTransaction);
                if (asyncTransaction == null)
                {
                    return null;
                }

                if (asyncTransaction.CancellationToken.IsCancellationRequested)
                {
                    throw new OperationCanceledException();
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The <see cref="Position"/> row.</param>
        /// <returns>The added <see cref="Position"/> row.</returns>
        public async Task<Position> AddAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            await position.EnterWriteLockAsync().ConfigureAwait(true);
            var originalRow = new Position(position);
            enlistmentState.RollbackStack.Push(() => position.CopyFrom(originalRow));
            var newAccount = this.fixture.Accounts.Find(position.AccountId);
            if (newAccount == null)
            {
                throw new ConstraintException("The add action conflicted with the constraint AccountPositionIndex.");
            }

            await newAccount.EnterWriteLockAsync().ConfigureAwait(true);
            newAccount.Positions.Add(position);
            enlistmentState.RollbackStack.Push(() => newAccount.Positions.Remove(position));
            position.Account = newAccount;
            var newAsset = this.fixture.Assets.Find(position.AssetId);
            if (newAsset == null)
            {
                throw new ConstraintException("The add action conflicted with the constraint AssetPositionIndex.");
            }

            await newAsset.EnterWriteLockAsync().ConfigureAwait(true);
            newAsset.Positions.Add(position);
            enlistmentState.RollbackStack.Push(() => newAsset.Positions.Remove(position));
            position.Asset = newAsset;
            this.fixture.RowVersion = position.RowVersion;
            this.dictionary.Add((position.AccountId, position.AssetId), position);
            enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((position.AccountId, position.AssetId)));
            var clonedRow = new Position(position);
            enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
            return clonedRow;
        }

        /// <summary>
        /// Adds a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The collection of <see cref="Position"/> rows.</param>
        /// <returns>The added <see cref="Position"/> rows.</returns>
        public async Task<IEnumerable<Position>> AddAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Position>();
            foreach (var position in positions)
            {
                await position.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Position(position);
                enlistmentState.RollbackStack.Push(() => position.CopyFrom(originalRow));
                var newAccount = this.fixture.Accounts.Find(position.AccountId);
                if (newAccount == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AccountPositionIndex.");
                }

                await newAccount.EnterWriteLockAsync().ConfigureAwait(true);
                newAccount.Positions.Add(position);
                enlistmentState.RollbackStack.Push(() => newAccount.Positions.Remove(position));
                position.Account = newAccount;
                var newAsset = this.fixture.Assets.Find(position.AssetId);
                if (newAsset == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AssetPositionIndex.");
                }

                await newAsset.EnterWriteLockAsync().ConfigureAwait(true);
                newAsset.Positions.Add(position);
                enlistmentState.RollbackStack.Push(() => newAsset.Positions.Remove(position));
                position.Asset = newAsset;
                this.fixture.RowVersion = position.RowVersion;
                this.dictionary.Add((position.AccountId, position.AssetId), position);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((position.AccountId, position.AssetId)));
                var clonedRow = new Position(position);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                addedRows.Add(clonedRow);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.CommitStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Position"/> row using the unique key.
        /// </summary>
        /// <param name="accountId">The accountId.</param>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Position"/> row, or null if not found.</returns>
        public Position? Find(System.Guid accountId, System.Guid assetId)
        {
            return this.dictionary.TryGetValue((accountId, assetId), out var position) ? position : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Position> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The collection of <see cref="Position"/> rows to load.</param>
        public void Load(IEnumerable<Position> positions)
        {
            foreach (var position in positions)
            {
                var account = this.fixture.Accounts.Find(position.AccountId);
                if (account == null)
                {
                    throw new ConstraintException("The insert action conflicted with the constraint AccountPositionIndex");
                }

                account.Positions.Add(position);
                position.Account = account;
                var asset = this.fixture.Assets.Find(position.AssetId);
                if (asset == null)
                {
                    throw new ConstraintException("The insert action conflicted with the constraint AssetPositionIndex");
                }

                asset.Positions.Add(position);
                position.Asset = asset;
                this.dictionary.Add((position.AccountId, position.AssetId), position);
                this.fixture.RowVersion = position.RowVersion;
                this.OnRowChanged(DataAction.Add, position);
            }
        }

        /// <summary>
        /// Handles the <see cref="Position"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="position">The <see cref="Position"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Position position)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, position));
                }
                finally
                {
                }
            }

            if (dataAction == DataAction.Remove)
            {
                this.DeletedRows.AddFirst(position);
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The collection of <see cref="Position"/> rows.</param>
        /// <returns>The patched <see cref="Position"/> rows.</returns>
        public async Task<(IEnumerable<Position> AddedRows, IEnumerable<Position> UpdatedRows)> PatchAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Position>();
            var updatedRows = new List<Position>();
            foreach (var position in positions)
            {
                if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Position(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    foundRow.AccountId = position.AccountId;
                    foundRow.AssetId = position.AssetId;
                    foundRow.Quantity = position.Quantity;
                    this.fixture.RowVersion = position.RowVersion;
                    var clonedRow = new Position(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    await position.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Position(position);
                    enlistmentState.RollbackStack.Push(() => position.CopyFrom(originalRow));
                    var newAccount = this.fixture.Accounts.Find(position.AccountId);
                    if (newAccount == null)
                    {
                        throw new ConstraintException("The add action conflicted with the constraint AccountPositionIndex.");
                    }

                    await newAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    newAccount.Positions.Add(position);
                    enlistmentState.RollbackStack.Push(() => newAccount.Positions.Remove(position));
                    position.Account = newAccount;
                    var newAsset = this.fixture.Assets.Find(position.AssetId);
                    if (newAsset == null)
                    {
                        throw new ConstraintException("The add action conflicted with the constraint AssetPositionIndex.");
                    }

                    await newAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    newAsset.Positions.Add(position);
                    enlistmentState.RollbackStack.Push(() => newAsset.Positions.Remove(position));
                    position.Asset = newAsset;
                    this.fixture.RowVersion = position.RowVersion;
                    this.dictionary.Add((position.AccountId, position.AssetId), position);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((position.AccountId, position.AssetId)));
                    var clonedRow = new Position(position);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                    addedRows.Add(clonedRow);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The <see cref="Position"/> row.</param>
        /// <returns>The added or updated <see cref="Position"/> row.</returns>
        public async Task<(Position? AddedRow, Position? UpdatedRow)> PutAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Position(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                foundRow.AccountId = position.AccountId;
                foundRow.AssetId = position.AssetId;
                foundRow.Quantity = position.Quantity;
                this.fixture.RowVersion = position.RowVersion;
                var clonedRow = new Position(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return (AddedRow: null, UpdatedRow: clonedRow);
            }
            else
            {
                await position.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Position(position);
                enlistmentState.RollbackStack.Push(() => position.CopyFrom(originalRow));
                var newAccount = this.fixture.Accounts.Find(position.AccountId);
                if (newAccount == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AccountPositionIndex.");
                }

                await newAccount.EnterWriteLockAsync().ConfigureAwait(true);
                newAccount.Positions.Add(position);
                enlistmentState.RollbackStack.Push(() => newAccount.Positions.Remove(position));
                position.Account = newAccount;
                var newAsset = this.fixture.Assets.Find(position.AssetId);
                if (newAsset == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AssetPositionIndex.");
                }

                await newAsset.EnterWriteLockAsync().ConfigureAwait(true);
                newAsset.Positions.Add(position);
                enlistmentState.RollbackStack.Push(() => newAsset.Positions.Remove(position));
                position.Asset = newAsset;
                this.fixture.RowVersion = position.RowVersion;
                this.dictionary.Add((position.AccountId, position.AssetId), position);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove((position.AccountId, position.AssetId)));
                var clonedRow = new Position(position);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                return (AddedRow: clonedRow, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">A collection of <see cref="Position"/> rows.</param>
        /// <returns>The removed <see cref="Position"/> rows.</returns>
        public async Task<IEnumerable<Position>> RemoveAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Position>();
            foreach (var position in positions)
            {
                if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Position(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    var oldAccount = this.fixture.Accounts.Find(position.AccountId);
                    ArgumentNullException.ThrowIfNull(oldAccount);
                    await oldAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    oldAccount.Positions.Remove(position);
                    enlistmentState.RollbackStack.Push(() => oldAccount.Positions.Add(position));
                    position.Account = null;
                    var oldAsset = this.fixture.Assets.Find(position.AssetId);
                    ArgumentNullException.ThrowIfNull(oldAsset);
                    await oldAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    oldAsset.Positions.Remove(position);
                    enlistmentState.RollbackStack.Push(() => oldAsset.Positions.Add(position));
                    position.Asset = null;
                    this.fixture.RowVersion = foundRow.RowVersion;
                    this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow));
                    var clonedRow = new Position(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                    removedRows.Add(clonedRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The <see cref="Position"/> row.</param>
        /// <returns>The removed <see cref="Position"/> row.</returns>
        public async Task<Position?> RemoveAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Position(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                var oldAccount = this.fixture.Accounts.Find(position.AccountId);
                ArgumentNullException.ThrowIfNull(oldAccount);
                await oldAccount.EnterWriteLockAsync().ConfigureAwait(true);
                oldAccount.Positions.Remove(position);
                enlistmentState.RollbackStack.Push(() => oldAccount.Positions.Add(position));
                position.Account = null;
                var oldAsset = this.fixture.Assets.Find(position.AssetId);
                ArgumentNullException.ThrowIfNull(oldAsset);
                await oldAsset.EnterWriteLockAsync().ConfigureAwait(true);
                oldAsset.Positions.Remove(position);
                enlistmentState.RollbackStack.Push(() => oldAsset.Positions.Add(position));
                position.Asset = null;
                this.fixture.RowVersion = foundRow.RowVersion;
                this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                enlistmentState.RollbackStack.Push(() => this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow));
                var clonedRow = new Position(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                return clonedRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.RollbackStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Position"/> row in the table.
        /// </summary>
        /// <param name="positions">The position row.</param>
        public async Task<IEnumerable<Position>> UpdateAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Position>();
            foreach (var position in positions)
            {
                if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Position(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    foundRow.AccountId = position.AccountId;
                    foundRow.AssetId = position.AssetId;
                    foundRow.Quantity = position.Quantity;
                    this.fixture.RowVersion = position.RowVersion;
                    var clonedRow = new Position(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Position"/> row in the table.
        /// </summary>
        /// <param name="position">The position row.</param>
        public async Task<Position> UpdateAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Position(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                foundRow.AccountId = position.AccountId;
                foundRow.AssetId = position.AssetId;
                foundRow.Quantity = position.Quantity;
                this.fixture.RowVersion = position.RowVersion;
                var clonedRow = new Position(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return clonedRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// A Quote row.
    /// </summary>
    public class Quote
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Quote"/> class.
        /// </summary>
        public Quote()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Quote"/> class.
        /// </summary>
        /// /// <param name="quote">The quote.</param>
        public Quote(Quote quote)
        {
            this.Asset = quote.Asset;
            this.AssetId = quote.AssetId;
            this.Last = quote.Last;
            this.RowVersion = quote.RowVersion;
        }

        /// <summary>
        /// Gets or sets the parent <see cref="Asset"/> row.
        /// </summary>
        [JsonIgnore]
        public Asset? Asset { get; set; }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Last.
        /// </summary>
        [JsonPropertyName("last")]
        public decimal Last { get; set; }

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Shallow copy of a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The destination <see cref="Quote"/> row.</param>
        public void CopyFrom(Quote quote)
        {
            this.Asset = quote.Asset;
            this.AssetId = quote.AssetId;
            this.Last = quote.Last;
            this.RowVersion = quote.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Quote other && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Quote"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Quotes(Fixture fixture) : IEnlistmentNotification, IEnumerable<Quote>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<System.Guid, Quote> dictionary = new Dictionary<System.Guid, Quote>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Quote"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Quote> DeletedRows { get; } = new LinkedList<Quote>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                ArgumentNullException.ThrowIfNull(asyncTransaction);
                if (asyncTransaction == null)
                {
                    return null;
                }

                if (asyncTransaction.CancellationToken.IsCancellationRequested)
                {
                    throw new OperationCanceledException();
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The <see cref="Quote"/> row.</param>
        /// <returns>The added <see cref="Quote"/> row.</returns>
        public async Task<Quote> AddAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            await quote.EnterWriteLockAsync().ConfigureAwait(true);
            var originalRow = new Quote(quote);
            enlistmentState.RollbackStack.Push(() => quote.CopyFrom(originalRow));
            var newAsset = this.fixture.Assets.Find(quote.AssetId);
            if (newAsset == null)
            {
                throw new ConstraintException("The add action conflicted with the constraint AssetQuoteIndex.");
            }

            await newAsset.EnterWriteLockAsync().ConfigureAwait(true);
            newAsset.Quotes.Add(quote);
            enlistmentState.RollbackStack.Push(() => newAsset.Quotes.Remove(quote));
            quote.Asset = newAsset;
            this.fixture.RowVersion = quote.RowVersion;
            this.dictionary.Add(quote.AssetId, quote);
            enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(quote.AssetId));
            var clonedRow = new Quote(quote);
            enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
            return clonedRow;
        }

        /// <summary>
        /// Adds a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The collection of <see cref="Quote"/> rows.</param>
        /// <returns>The added <see cref="Quote"/> rows.</returns>
        public async Task<IEnumerable<Quote>> AddAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                await quote.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Quote(quote);
                enlistmentState.RollbackStack.Push(() => quote.CopyFrom(originalRow));
                var newAsset = this.fixture.Assets.Find(quote.AssetId);
                if (newAsset == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AssetQuoteIndex.");
                }

                await newAsset.EnterWriteLockAsync().ConfigureAwait(true);
                newAsset.Quotes.Add(quote);
                enlistmentState.RollbackStack.Push(() => newAsset.Quotes.Remove(quote));
                quote.Asset = newAsset;
                this.fixture.RowVersion = quote.RowVersion;
                this.dictionary.Add(quote.AssetId, quote);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(quote.AssetId));
                var clonedRow = new Quote(quote);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                addedRows.Add(clonedRow);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.CommitStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Quote"/> row using the unique key.
        /// </summary>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Quote"/> row, or null if not found.</returns>
        public Quote? Find(System.Guid assetId)
        {
            return this.dictionary.TryGetValue(assetId, out var quote) ? quote : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Quote> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The collection of <see cref="Quote"/> rows to load.</param>
        public void Load(IEnumerable<Quote> quotes)
        {
            foreach (var quote in quotes)
            {
                var asset = this.fixture.Assets.Find(quote.AssetId);
                if (asset == null)
                {
                    throw new ConstraintException("The insert action conflicted with the constraint AssetQuoteIndex");
                }

                asset.Quotes.Add(quote);
                quote.Asset = asset;
                this.dictionary.Add(quote.AssetId, quote);
                this.fixture.RowVersion = quote.RowVersion;
                this.OnRowChanged(DataAction.Add, quote);
            }
        }

        /// <summary>
        /// Handles the <see cref="Quote"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="quote">The <see cref="Quote"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Quote quote)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, quote));
                }
                finally
                {
                }
            }

            if (dataAction == DataAction.Remove)
            {
                this.DeletedRows.AddFirst(quote);
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The collection of <see cref="Quote"/> rows.</param>
        /// <returns>The patched <see cref="Quote"/> rows.</returns>
        public async Task<(IEnumerable<Quote> AddedRows, IEnumerable<Quote> UpdatedRows)> PatchAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Quote>();
            var updatedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Quote(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    foundRow.AssetId = quote.AssetId;
                    foundRow.Last = quote.Last;
                    this.fixture.RowVersion = quote.RowVersion;
                    var clonedRow = new Quote(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    await quote.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Quote(quote);
                    enlistmentState.RollbackStack.Push(() => quote.CopyFrom(originalRow));
                    var newAsset = this.fixture.Assets.Find(quote.AssetId);
                    if (newAsset == null)
                    {
                        throw new ConstraintException("The add action conflicted with the constraint AssetQuoteIndex.");
                    }

                    await newAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    newAsset.Quotes.Add(quote);
                    enlistmentState.RollbackStack.Push(() => newAsset.Quotes.Remove(quote));
                    quote.Asset = newAsset;
                    this.fixture.RowVersion = quote.RowVersion;
                    this.dictionary.Add(quote.AssetId, quote);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(quote.AssetId));
                    var clonedRow = new Quote(quote);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                    addedRows.Add(clonedRow);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The <see cref="Quote"/> row.</param>
        /// <returns>The added or updated <see cref="Quote"/> row.</returns>
        public async Task<(Quote? AddedRow, Quote? UpdatedRow)> PutAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Quote(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                foundRow.AssetId = quote.AssetId;
                foundRow.Last = quote.Last;
                this.fixture.RowVersion = quote.RowVersion;
                var clonedRow = new Quote(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return (AddedRow: null, UpdatedRow: clonedRow);
            }
            else
            {
                await quote.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Quote(quote);
                enlistmentState.RollbackStack.Push(() => quote.CopyFrom(originalRow));
                var newAsset = this.fixture.Assets.Find(quote.AssetId);
                if (newAsset == null)
                {
                    throw new ConstraintException("The add action conflicted with the constraint AssetQuoteIndex.");
                }

                await newAsset.EnterWriteLockAsync().ConfigureAwait(true);
                newAsset.Quotes.Add(quote);
                enlistmentState.RollbackStack.Push(() => newAsset.Quotes.Remove(quote));
                quote.Asset = newAsset;
                this.fixture.RowVersion = quote.RowVersion;
                this.dictionary.Add(quote.AssetId, quote);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Remove(quote.AssetId));
                var clonedRow = new Quote(quote);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Add, clonedRow));
                return (AddedRow: clonedRow, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">A collection of <see cref="Quote"/> rows.</param>
        /// <returns>The removed <see cref="Quote"/> rows.</returns>
        public async Task<IEnumerable<Quote>> RemoveAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Quote(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    var oldAsset = this.fixture.Assets.Find(quote.AssetId);
                    ArgumentNullException.ThrowIfNull(oldAsset);
                    await oldAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    oldAsset.Quotes.Remove(quote);
                    enlistmentState.RollbackStack.Push(() => oldAsset.Quotes.Add(quote));
                    quote.Asset = null;
                    this.fixture.RowVersion = foundRow.RowVersion;
                    this.dictionary.Remove(foundRow.AssetId);
                    enlistmentState.RollbackStack.Push(() => this.dictionary.Add(foundRow.AssetId, foundRow));
                    var clonedRow = new Quote(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                    removedRows.Add(clonedRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The <see cref="Quote"/> row.</param>
        /// <returns>The removed <see cref="Quote"/> row.</returns>
        public async Task<Quote?> RemoveAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Quote(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                var oldAsset = this.fixture.Assets.Find(quote.AssetId);
                ArgumentNullException.ThrowIfNull(oldAsset);
                await oldAsset.EnterWriteLockAsync().ConfigureAwait(true);
                oldAsset.Quotes.Remove(quote);
                enlistmentState.RollbackStack.Push(() => oldAsset.Quotes.Add(quote));
                quote.Asset = null;
                this.fixture.RowVersion = foundRow.RowVersion;
                this.dictionary.Remove(foundRow.AssetId);
                enlistmentState.RollbackStack.Push(() => this.dictionary.Add(foundRow.AssetId, foundRow));
                var clonedRow = new Quote(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Remove, clonedRow));
                return clonedRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var stack = enlistmentState.RollbackStack;
            while (stack.Count != 0)
            {
                stack.Pop()();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Quote"/> row in the table.
        /// </summary>
        /// <param name="quotes">The quote row.</param>
        public async Task<IEnumerable<Quote>> UpdateAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Quote(foundRow);
                    enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                    foundRow.AssetId = quote.AssetId;
                    foundRow.Last = quote.Last;
                    this.fixture.RowVersion = quote.RowVersion;
                    var clonedRow = new Quote(foundRow);
                    enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                    updatedRows.Add(clonedRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Quote"/> row in the table.
        /// </summary>
        /// <param name="quote">The quote row.</param>
        public async Task<Quote> UpdateAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Quote(foundRow);
                enlistmentState.RollbackStack.Push(() => foundRow.CopyFrom(originalRow));
                foundRow.AssetId = quote.AssetId;
                foundRow.Last = quote.Last;
                this.fixture.RowVersion = quote.RowVersion;
                var clonedRow = new Quote(foundRow);
                enlistmentState.CommitStack.Push(() => this.OnRowChanged(DataAction.Update, clonedRow));
                return clonedRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }
}