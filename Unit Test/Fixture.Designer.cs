// <auto-generated />
#nullable enable
namespace UnitTest
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
    using System.Threading;
    using System.Transactions;
    using DotNext.Threading;

    /// <summary>
    /// An action on a row.
    /// </summary>
    public enum DataAction
    {
        /// <summary>
        /// Add an item.
        /// </summary>
        Add,
        /// <summary>
        /// Remove an item.
        /// </summary>
        Remove,
        /// <summary>
        /// Update an item.
        /// </summary>
        Update,
    }

    /// <summary>
    /// An object that can be enlisted in a transaction.
    /// </summary>
    public class EnlistmentNotification : IEnlistmentNotification
    {
        /// <summary>
        /// The asynchronous transaction.
        /// </summary>
        private readonly AsyncTransaction asyncTransaction;

        /// <summary>
        /// The original <see cref="IEnlistmentNotification"/> object.
        /// </summary>
        private readonly IEnlistmentNotification enlistmentNotification;

        /// <summary>
        /// Initializes a new instance of the <see cref="EnlistmentNotification"/> class.
        /// </summary>
        public EnlistmentNotification(IEnlistmentNotification enlistmentNotification)
        {
            ArgumentNullException.ThrowIfNull(AsyncTransaction.Current);
            this.asyncTransaction = AsyncTransaction.Current;
            this.enlistmentNotification = enlistmentNotification;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            AsyncTransaction.Current = this.asyncTransaction;
            this.enlistmentNotification.Commit(enlistment);
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            AsyncTransaction.Current = this.asyncTransaction;
            this.enlistmentNotification.Prepare(preparingEnlistment);
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            AsyncTransaction.Current = this.asyncTransaction;
            this.enlistmentNotification.Rollback(enlistment);
        }
    }

    /// <summary>
    /// An asynchronous transaction.
    /// </summary>
    public class AsyncTransaction : IDisposable
    {
        /// <summary>
        /// The local asynchronous transaction.
        /// </summary>
        private static readonly AsyncLocal<AsyncTransaction?> asyncTransaction = new AsyncLocal<AsyncTransaction?>();

        /// <summary>
        /// The cancellation token source.
        /// </summary>
        private readonly CancellationTokenSource? cancellationTokenSource = null;

        /// <summary>
        /// The committable transaction.
        /// </summary>
        private readonly CommittableTransaction committableTransaction;

        /// <summary>
        /// The unique identifier.
        /// </summary>
        private readonly Guid identifier = Guid.NewGuid();

        /// <summary>
        /// Initializes a new instance of the <see cref="AsyncTransaction"/> class.
        /// </summary>
        public AsyncTransaction(CancellationToken cancellationToken = default)
        {
            if (cancellationToken == default)
            {
                this.cancellationTokenSource = new CancellationTokenSource(TimeSpan.FromSeconds(30));
                cancellationToken = cancellationTokenSource.Token;
            }

            this.CancellationToken = cancellationToken;
            AsyncTransaction.asyncTransaction.Value = this;
            this.committableTransaction = new CommittableTransaction(new TransactionOptions { Timeout = TimeSpan.MaxValue });
        }

        /// <summary>
        /// Gets the cancellation token.
        /// </summary>
        public CancellationToken CancellationToken { get; }

        /// <summary>
        /// Gets the current asynchronous transaction.
        /// </summary>
        public static AsyncTransaction? Current
        {
            get
            {
                return AsyncTransaction.asyncTransaction.Value;
            }

            set
            {
                AsyncTransaction.asyncTransaction.Value = value;
            }
        }

        /// <summary>
        /// Gets the read locks.
        /// </summary>
        public Dictionary<object, AsyncReaderWriterLock> ReadLocks { get; } = new Dictionary<object, AsyncReaderWriterLock>();

        /// <summary>
        /// Gets the write locks.
        /// </summary>
        public Dictionary<object, AsyncReaderWriterLock> WriteLocks { get; } = new Dictionary<object, AsyncReaderWriterLock>();

        /// <summary>
        /// Indicates that all operations are to be committed.
        /// </summary>
        public void Commit()
        {
            this.committableTransaction.Commit();
        }

        /// <inheritdoc/>
        public void Dispose()
        {
            foreach (var asyncReaderWriterLock in this.ReadLocks.Values)
            {
                asyncReaderWriterLock.Release();
            }

            foreach (var asyncReaderWriterLock in this.WriteLocks.Values)
            {
                asyncReaderWriterLock.Release();
            }

            this.committableTransaction.Dispose();
            AsyncTransaction.asyncTransaction.Value = null;
        }

        /// <summary>
        /// Enlists a volatile resource manager to participate in a transaction.
        /// </summary>
        /// <param name="enlistmentNotification">An object that implements the <see cref="IEnlistmentNotification"/> interface to receive two-phase commit notifications.</param>
        /// <returns>An <see cref="Enlistment"/> object that describes the enlistment.</returns>
        public Enlistment EnlistVolatile(IEnlistmentNotification enlistmentNotification)
        {
            ArgumentNullException.ThrowIfNull(this.committableTransaction);
            return this.committableTransaction.EnlistVolatile(new EnlistmentNotification(enlistmentNotification), EnlistmentOptions.None);
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is AsyncTransaction other && this.identifier == other.identifier;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.identifier.GetHashCode();
        }

        /// <summary>
        /// Indicates that all operations are to be rolled back.
        /// </summary>
        public void Rollback()
        {
            this.committableTransaction.Rollback();
        }
    }

    /// <summary>
    /// Represents errors that occurs when trying to establish a relationship in a data model.
    /// </summary>
    public class ConcurrencyException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ConcurrencyException"/> class.
        /// </summary>
        public ConcurrencyException() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConcurrencyException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public ConcurrencyException(string message) : base(message)
        {
        }

        /// <summary>
        /// Throw a concurrency exception if the values are not equal.
        /// </summary>
        /// <param name="rowVersion1">The first row version.</param>
        /// <param name="rowVersion2">The second row version.</param>
        public static void ThrowIfNotEqual(long rowVersion1, long rowVersion2)
        {
            if (rowVersion1 != rowVersion2)
            {
                throw new ConcurrencyException();
            }
        }
    }

    /// <summary>
    /// Represents errors that occurs when trying to establish a relationship in a data model.
    /// </summary>
    public class ConstraintException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ConstraintException"/> class.
        /// </summary>
        public ConstraintException() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConstraintException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public ConstraintException(string message) : base(message)
        {
        }

        /// <summary>
        /// Throw a constraint exception if the value is null.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="message">The message.</param>
        public static void ThrowIfNull([NotNull] object? value, string message)
        {
            if (value == null)
            {
                throw new ConstraintException(message);
            }
        }

        /// <summary>
        /// Throw a constraint exception if the value is true.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="message">The message.</param>
        public static void ThrowIfTrue(bool value, string message)
        {
            if (value)
            {
                throw new ConstraintException(message);
            }
        }
    }

    /// <summary>
    /// The state of an <see cref="Enlistment"/>.
    /// </summary>
    public class EnlistmentState
    {
        /// <summary>
        /// Gets the commit actions.
        /// </summary>
        public List<Action> CommitActions { get; } = new List<Action>();

        /// <summary>
        /// Gets the rollback actions.
        /// </summary>
        public List<Action> RollbackActions { get; } = new List<Action>();
    }

    /// <summary>
    /// Arguments describing an event that changed a row.
    /// </summary>
    public class RowChangedEventArgs(DataAction dataAction, object row) : EventArgs
    {
        /// <summary>
        /// Gets the action that caused the change.
        /// </summary>
        public DataAction DataAction { get; } = dataAction;

        /// <summary>
        /// Gets the row.
        /// </summary>
        public object Row { get; } = row;
    }
}

namespace UnitTest.Master
{
    using System;
    using System.Collections;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using System.Text.Json.Serialization;
    using System.Threading.Tasks;
    using System.Transactions;
    using DotNext.Threading;
    using Microsoft.AspNetCore.Authorization;
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.EntityFrameworkCore;
    using Microsoft.Extensions.Configuration;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.Logging;
    using UnitTest;

    /// <summary>
    /// A Account row.
    /// </summary>
    public class Account
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Account"/> class.
        /// </summary>
        public Account()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Account"/> class.
        /// </summary>
        /// /// <param name="account">The account.</param>
        public Account(Account account)
        {
            this.AccountId = account.AccountId;
            this.Model = account.Model;
            this.ModelId = account.ModelId;
            this.Name = account.Name;
            this.Orders.UnionWith(account.Orders);
            this.Positions.UnionWith(account.Positions);
            this.RowVersion = account.RowVersion;
        }

        /// <summary>
        /// Gets or sets the AccountId.
        /// </summary>
        [JsonPropertyName("accountId")]
        public System.Guid AccountId { get; set; }

        /// <summary>
        /// Gets or sets the parent <see cref="Model"/> row.
        /// </summary>
        [JsonIgnore]
        public Model? Model { get; set; }

        /// <summary>
        /// Gets or sets the ModelId.
        /// </summary>
        [JsonPropertyName("modelId")]
        public System.Guid? ModelId { get; set; }

        /// <summary>
        /// Gets or sets the Name.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Gets the child <see cref="Order"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Order> Orders { get; } = new HashSet<Order>();

        /// <summary>
        /// Gets the child <see cref="Position"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Position> Positions { get; } = new HashSet<Position>();

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Deep copy of a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The destination <see cref="Account"/> row.</param>
        public void CopyFrom(Account account)
        {
            this.AccountId = account.AccountId;
            this.Model = account.Model;
            this.ModelId = account.ModelId;
            this.Name = account.Name;
            this.Orders.Clear();
            this.Orders.UnionWith(account.Orders);
            this.Positions.Clear();
            this.Positions.UnionWith(account.Positions);
            this.RowVersion = account.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Account other && this.AccountId == other.AccountId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AccountId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Account"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Accounts(Fixture fixture) : IEnlistmentNotification, IEnumerable<Account>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<System.Guid, Account> dictionary = new Dictionary<System.Guid, Account>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private readonly ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Account"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Account> DeletedRows { get; } = new LinkedList<Account>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                if (asyncTransaction == null)
                {
                    return null;
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The <see cref="Account"/> row.</param>
        /// <returns>The added <see cref="Account"/> row.</returns>
        public async Task<Account> AddAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            Model? addedModel = null;
            if (account.ModelId != null)
            {
                addedModel = this.fixture.Models.Find(account.ModelId.Value);
                ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                await addedModel.EnterWriteLockAsync().ConfigureAwait(false);
            }

            var originalRow = new Account(account);
            account.Model = addedModel;
            account.RowVersion = this.fixture.IncrementRowVersion();
            if (addedModel != null)
            {
                addedModel.Accounts.Add(account);
            }

            this.dictionary.Add(account.AccountId, account);
            enlistmentState.RollbackActions.Add(() =>
            {
                account.CopyFrom(originalRow);
                if (addedModel != null)
                {
                    addedModel.Accounts.Remove(account);
                }

                this.dictionary.Remove(account.AccountId);
            });
            enlistmentState.CommitActions.Add(() =>
            {
                this.OnRowChanged(DataAction.Add, account);
            });
            return account;
        }

        /// <summary>
        /// Adds a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The collection of <see cref="Account"/> rows.</param>
        /// <returns>The added <see cref="Account"/> rows.</returns>
        public async Task<IEnumerable<Account>> AddAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Account>();
            foreach (var account in accounts)
            {
                Model? addedModel = null;
                if (account.ModelId != null)
                {
                    addedModel = this.fixture.Models.Find(account.ModelId.Value);
                    ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                    await addedModel.EnterWriteLockAsync().ConfigureAwait(false);
                }

                var originalRow = new Account(account);
                account.Model = addedModel;
                account.RowVersion = this.fixture.IncrementRowVersion();
                if (addedModel != null)
                {
                    addedModel.Accounts.Add(account);
                }

                this.dictionary.Add(account.AccountId, account);
                enlistmentState.RollbackActions.Add(() =>
                {
                    account.CopyFrom(originalRow);
                    if (addedModel != null)
                    {
                        addedModel.Accounts.Remove(account);
                    }

                    this.dictionary.Remove(account.AccountId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, account);
                });
                addedRows.Add(account);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var commitAction in enlistmentState.CommitActions)
            {
                commitAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Account"/> row using the unique key.
        /// </summary>
        /// <param name="accountId">The accountId.</param>
        /// <returns>The found <see cref="Account"/> row, or null if not found.</returns>
        public Account? Find(System.Guid accountId)
        {
            return this.dictionary.TryGetValue(accountId, out var account) ? account : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Account> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The collection of <see cref="Account"/> rows to load.</param>
        public void Load(IEnumerable<Account> accounts)
        {
            foreach (var account in accounts)
            {
                if (account.ModelId == null)
                {
                    account.ModelId = null;
                }
                else
                {
                    var model = this.fixture.Models.Find(account.ModelId.Value);
                    if (model == null)
                    {
                        throw new ConstraintException("ModelAccountIndex");
                    }

                    model.Accounts.Add(account);
                    account.Model = model;
                }

                this.dictionary.Add(account.AccountId, account);
                this.fixture.RowVersion = account.RowVersion;
                this.OnRowChanged(DataAction.Add, account);
            }
        }

        /// <summary>
        /// Handles the <see cref="Account"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="account">The <see cref="Account"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Account account)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, account));
                }
                finally
                {
                }
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The collection of <see cref="Account"/> rows.</param>
        /// <returns>The patched <see cref="Account"/> rows.</returns>
        public async Task<(IEnumerable<Account> AddedRows, IEnumerable<Account> UpdatedRows)> PatchAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Account>();
            var updatedRows = new List<Account>();
            foreach (var account in accounts)
            {
                if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(account.RowVersion, foundRow.RowVersion);
                    Model? removedModel = null;
                    if (foundRow.ModelId != null)
                    {
                        removedModel = this.fixture.Models.Find(foundRow.ModelId.Value);
                        ArgumentNullException.ThrowIfNull(removedModel);
                        await removedModel.EnterWriteLockAsync().ConfigureAwait(false);
                    }

                    Model? addedModel = null;
                    if (account.ModelId != null)
                    {
                        addedModel = this.fixture.Models.Find(account.ModelId.Value);
                        ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                        await addedModel.EnterWriteLockAsync().ConfigureAwait(false);
                    }

                    var originalRow = new Account(foundRow);
                    foundRow.AccountId = account.AccountId;
                    foundRow.Model = addedModel;
                    foundRow.ModelId = account.ModelId;
                    foundRow.Name = account.Name;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    if (removedModel != null)
                    {
                        removedModel.Accounts.Remove(foundRow);
                    }

                    if (addedModel != null)
                    {
                        addedModel.Accounts.Add(foundRow);
                    }

                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        if (removedModel != null)
                        {
                            removedModel.Accounts.Add(foundRow);
                        }

                        if (addedModel != null)
                        {
                            addedModel.Accounts.Remove(foundRow);
                        }
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    Model? addedModel = null;
                    if (account.ModelId != null)
                    {
                        addedModel = this.fixture.Models.Find(account.ModelId.Value);
                        ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                        await addedModel.EnterWriteLockAsync().ConfigureAwait(false);
                    }

                    var originalRow = new Account(account);
                    account.Model = addedModel;
                    account.RowVersion = this.fixture.IncrementRowVersion();
                    if (addedModel != null)
                    {
                        addedModel.Accounts.Add(account);
                    }

                    this.dictionary.Add(account.AccountId, account);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        account.CopyFrom(originalRow);
                        if (addedModel != null)
                        {
                            addedModel.Accounts.Remove(account);
                        }

                        this.dictionary.Remove(account.AccountId);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Add, account);
                    });
                    addedRows.Add(account);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The <see cref="Account"/> row.</param>
        /// <returns>The added or updated <see cref="Account"/> row.</returns>
        public async Task<(Account? AddedRow, Account? UpdatedRow)> PutAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(account.RowVersion, foundRow.RowVersion);
                Model? removedModel = null;
                if (foundRow.ModelId != null)
                {
                    removedModel = this.fixture.Models.Find(foundRow.ModelId.Value);
                    ArgumentNullException.ThrowIfNull(removedModel);
                    await removedModel.EnterWriteLockAsync().ConfigureAwait(false);
                }

                Model? addedModel = null;
                if (account.ModelId != null)
                {
                    addedModel = this.fixture.Models.Find(account.ModelId.Value);
                    ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                    await addedModel.EnterWriteLockAsync().ConfigureAwait(false);
                }

                var originalRow = new Account(foundRow);
                foundRow.AccountId = account.AccountId;
                foundRow.Model = addedModel;
                foundRow.ModelId = account.ModelId;
                foundRow.Name = account.Name;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                if (removedModel != null)
                {
                    removedModel.Accounts.Remove(foundRow);
                }

                if (addedModel != null)
                {
                    addedModel.Accounts.Add(foundRow);
                }

                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    if (removedModel != null)
                    {
                        removedModel.Accounts.Add(foundRow);
                    }

                    if (addedModel != null)
                    {
                        addedModel.Accounts.Remove(foundRow);
                    }
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return (AddedRow: null, UpdatedRow: foundRow);
            }
            else
            {
                Model? addedModel = null;
                if (account.ModelId != null)
                {
                    addedModel = this.fixture.Models.Find(account.ModelId.Value);
                    ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                    await addedModel.EnterWriteLockAsync().ConfigureAwait(false);
                }

                var originalRow = new Account(account);
                account.Model = addedModel;
                account.RowVersion = this.fixture.IncrementRowVersion();
                if (addedModel != null)
                {
                    addedModel.Accounts.Add(account);
                }

                this.dictionary.Add(account.AccountId, account);
                enlistmentState.RollbackActions.Add(() =>
                {
                    account.CopyFrom(originalRow);
                    if (addedModel != null)
                    {
                        addedModel.Accounts.Remove(account);
                    }

                    this.dictionary.Remove(account.AccountId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, account);
                });
                return (AddedRow: account, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">A collection of <see cref="Account"/> rows.</param>
        /// <returns>The removed <see cref="Account"/> rows.</returns>
        public async Task<IEnumerable<Account>> RemoveAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Account>();
            foreach (var account in accounts)
            {
                if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(account.RowVersion, foundRow.RowVersion);
                    ConstraintException.ThrowIfTrue(foundRow.Orders.Count != 0, "AccountOrderIndex");
                    ConstraintException.ThrowIfTrue(foundRow.Positions.Count != 0, "AccountPositionIndex");
                    Model? removedModel = null;
                    if (account.ModelId != null)
                    {
                        removedModel = this.fixture.Models.Find(account.ModelId.Value);
                        ArgumentNullException.ThrowIfNull(removedModel);
                        await removedModel.EnterWriteLockAsync().ConfigureAwait(false);
                    }

                    var originalRow = new Account(foundRow);
                    foundRow.Model = null;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    if (removedModel != null)
                    {
                        removedModel.Accounts.Remove(foundRow);
                    }

                    this.dictionary.Remove(foundRow.AccountId);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        if (removedModel != null)
                        {
                            removedModel.Accounts.Add(foundRow);
                        }

                        this.dictionary.Add(foundRow.AccountId, foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.DeletedRows.AddFirst(foundRow);
                        this.OnRowChanged(DataAction.Remove, foundRow);
                    });
                    removedRows.Add(foundRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The <see cref="Account"/> row.</param>
        /// <returns>The removed <see cref="Account"/> row.</returns>
        public async Task<Account?> RemoveAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(account.RowVersion, foundRow.RowVersion);
                ConstraintException.ThrowIfTrue(foundRow.Orders.Count != 0, "AccountOrderIndex");
                ConstraintException.ThrowIfTrue(foundRow.Positions.Count != 0, "AccountPositionIndex");
                Model? removedModel = null;
                if (account.ModelId != null)
                {
                    removedModel = this.fixture.Models.Find(account.ModelId.Value);
                    ArgumentNullException.ThrowIfNull(removedModel);
                    await removedModel.EnterWriteLockAsync().ConfigureAwait(false);
                }

                var originalRow = new Account(foundRow);
                foundRow.Model = null;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                if (removedModel != null)
                {
                    removedModel.Accounts.Remove(foundRow);
                }

                this.dictionary.Remove(foundRow.AccountId);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    if (removedModel != null)
                    {
                        removedModel.Accounts.Add(foundRow);
                    }

                    this.dictionary.Add(foundRow.AccountId, foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.DeletedRows.AddFirst(foundRow);
                    this.OnRowChanged(DataAction.Remove, foundRow);
                });
                return foundRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var rollbackAction in enlistmentState.RollbackActions)
            {
                rollbackAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Account"/> row in the table.
        /// </summary>
        /// <param name="accounts">The account row.</param>
        public async Task<IEnumerable<Account>> UpdateAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Account>();
            foreach (var account in accounts)
            {
                if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(account.RowVersion, foundRow.RowVersion);
                    Model? removedModel = null;
                    if (foundRow.ModelId != null)
                    {
                        removedModel = this.fixture.Models.Find(foundRow.ModelId.Value);
                        ArgumentNullException.ThrowIfNull(removedModel);
                        await removedModel.EnterWriteLockAsync().ConfigureAwait(false);
                    }

                    Model? addedModel = null;
                    if (account.ModelId != null)
                    {
                        addedModel = this.fixture.Models.Find(account.ModelId.Value);
                        ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                        await addedModel.EnterWriteLockAsync().ConfigureAwait(false);
                    }

                    var originalRow = new Account(foundRow);
                    foundRow.AccountId = account.AccountId;
                    foundRow.Model = addedModel;
                    foundRow.ModelId = account.ModelId;
                    foundRow.Name = account.Name;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    if (removedModel != null)
                    {
                        removedModel.Accounts.Remove(foundRow);
                    }

                    if (addedModel != null)
                    {
                        addedModel.Accounts.Add(foundRow);
                    }

                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        if (removedModel != null)
                        {
                            removedModel.Accounts.Add(foundRow);
                        }

                        if (addedModel != null)
                        {
                            addedModel.Accounts.Remove(foundRow);
                        }
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Account"/> row in the table.
        /// </summary>
        /// <param name="account">The account row.</param>
        public async Task<Account> UpdateAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(account.RowVersion, foundRow.RowVersion);
                Model? removedModel = null;
                if (foundRow.ModelId != null)
                {
                    removedModel = this.fixture.Models.Find(foundRow.ModelId.Value);
                    ArgumentNullException.ThrowIfNull(removedModel);
                    await removedModel.EnterWriteLockAsync().ConfigureAwait(false);
                }

                Model? addedModel = null;
                if (account.ModelId != null)
                {
                    addedModel = this.fixture.Models.Find(account.ModelId.Value);
                    ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                    await addedModel.EnterWriteLockAsync().ConfigureAwait(false);
                }

                var originalRow = new Account(foundRow);
                foundRow.AccountId = account.AccountId;
                foundRow.Model = addedModel;
                foundRow.ModelId = account.ModelId;
                foundRow.Name = account.Name;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                if (removedModel != null)
                {
                    removedModel.Accounts.Remove(foundRow);
                }

                if (addedModel != null)
                {
                    addedModel.Accounts.Add(foundRow);
                }

                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    if (removedModel != null)
                    {
                        removedModel.Accounts.Add(foundRow);
                    }

                    if (addedModel != null)
                    {
                        addedModel.Accounts.Remove(foundRow);
                    }
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return foundRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// Controller for <see cref="Account"/> rows.
    /// </summary>
    [Route("fixture/[controller]")]
    [ApiController]
    [Authorize]
    public partial class AccountsController : ControllerBase
    {
        private readonly Fixture fixture;
        private readonly FixtureContext fixtureContext;
        private readonly ILogger logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="AccountsController"/> class.
        /// </summary>
        /// <param name="fixture">The data model.</param>
        /// <param name="fixtureContext">The DbContext for the data model.</param>
        /// <param name="logger">The log device.</param>
        public AccountsController(Fixture fixture, FixtureContext fixtureContext, ILogger<AccountsController> logger)
        {
            this.fixture = fixture;
            this.fixtureContext = fixtureContext;
            this.logger = logger;
        }

        /// <summary>
        /// Removes a <see cref="Account"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="account">The <see cref="Account"/> row to be deleted.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete("{accountId}")]
        public async Task<IActionResult> DeleteAccount([FromRoute] System.Guid accountId, [FromBody] Account account)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Accounts.EnterWriteLockAsync().ConfigureAwait(false);
                await this.fixture.Models.EnterReadLockAsync().ConfigureAwait(false);
                if (this.fixture.Accounts.Find(accountId) != null)
                {
                    var removedRow = await this.fixture.Accounts.RemoveAsync(account).ConfigureAwait(false);
                    if (removedRow != null)
                    {
                        this.fixtureContext.Accounts.Remove(account);
                        await this.fixtureContext.SaveChangesAsync();
                    }

                    asyncTransaction.Commit();
                }

                return this.Ok(account);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">A collection of <see cref="Account"/> rows.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete]
        public async Task<IActionResult> DeleteAccounts([FromBody] IEnumerable<Account> accounts)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Accounts.EnterWriteLockAsync().ConfigureAwait(false);
                await this.fixture.Models.EnterReadLockAsync().ConfigureAwait(false);
                var deletedRows = await this.fixture.Accounts.RemoveAsync(accounts).ConfigureAwait(false);
                this.fixtureContext.Accounts.RemoveRange(deletedRows);
                await this.fixtureContext.SaveChangesAsync();
                asyncTransaction.Commit();
                return this.Ok(deletedRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a specific <see cref="Account"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <returns>The row matching the key or NotFound.</returns>
        [HttpGet("{accountId}")]
        public async Task<IActionResult> GetAccount([FromRoute] System.Guid accountId)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Accounts.EnterReadLockAsync().ConfigureAwait(false);
                var existingRow = this.fixture.Accounts.Find(accountId);
                if (existingRow == null)
                {
                    return this.NotFound();
                }

                await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                return this.Ok(new Account(existingRow));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <returns>A collection of <see cref="Account"/> rows.</returns>
        [HttpGet]
        public async Task<IActionResult> GetAccounts()
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Accounts.EnterReadLockAsync().ConfigureAwait(false);
                var existingRows = new List<Account>();
                foreach (var existingRow in this.fixture.Accounts)
                {
                    await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                    existingRows.Add(new Account(existingRow));
                }

                return this.Ok(existingRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Patches the <see cref="Account"/> table.
        /// </summary>
        /// <param name="accounts">A collection of <see cref="Account"/> rows.</param>
        /// <returns>The result of applying the patch action.</returns>
        [HttpPatch]
        public async Task<IActionResult> PatchAccountsAsync([FromBody] IEnumerable<Account> accounts)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Accounts.EnterWriteLockAsync().ConfigureAwait(false);
                await this.fixture.Models.EnterReadLockAsync().ConfigureAwait(false);
                (var addedRows, var updatedRows) = await this.fixture.Accounts.PatchAsync(accounts).ConfigureAwait(false);
                this.fixtureContext.Accounts.AddRange(addedRows);
                this.fixtureContext.Accounts.UpdateRange(updatedRows);
                await this.fixtureContext.SaveChangesAsync().ConfigureAwait(false);
                asyncTransaction.Commit();
                return this.Ok(addedRows.Concat(updatedRows));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Puts the <see cref="Account"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="account">The <see cref="Account"/> row.</param>
        /// <returns>The result of applying the put action.</returns>
        [HttpPut("{accountId}")]
        public async Task<IActionResult> PutAccount([FromRoute] System.Guid accountId, [FromBody] Account account)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Accounts.EnterWriteLockAsync().ConfigureAwait(false);
                await this.fixture.Models.EnterReadLockAsync().ConfigureAwait(false);
                (var addedRow, var updatedRow) = await this.fixture.Accounts.PutAsync(account).ConfigureAwait(false);
                if (addedRow != null)
                {
                    this.fixtureContext.Add(addedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Commit();
                    return this.Ok(addedRow);
                }

                if (updatedRow != null)
                {
                    this.fixtureContext.Update(updatedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Commit();
                    return this.Ok(updatedRow);
                }

                throw new InvalidOperationException();
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }
    }

    /// <summary>
    /// A Asset row.
    /// </summary>
    public class Asset
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Asset"/> class.
        /// </summary>
        public Asset()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Asset"/> class.
        /// </summary>
        /// /// <param name="asset">The asset.</param>
        public Asset(Asset asset)
        {
            this.AssetId = asset.AssetId;
            this.Name = asset.Name;
            this.Orders.UnionWith(asset.Orders);
            this.Positions.UnionWith(asset.Positions);
            this.Quotes.UnionWith(asset.Quotes);
            this.RowVersion = asset.RowVersion;
        }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Name.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Gets the child <see cref="Order"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Order> Orders { get; } = new HashSet<Order>();

        /// <summary>
        /// Gets the child <see cref="Position"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Position> Positions { get; } = new HashSet<Position>();

        /// <summary>
        /// Gets the child <see cref="Quote"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Quote> Quotes { get; } = new HashSet<Quote>();

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Deep copy of a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The destination <see cref="Asset"/> row.</param>
        public void CopyFrom(Asset asset)
        {
            this.AssetId = asset.AssetId;
            this.Name = asset.Name;
            this.Orders.Clear();
            this.Orders.UnionWith(asset.Orders);
            this.Positions.Clear();
            this.Positions.UnionWith(asset.Positions);
            this.Quotes.Clear();
            this.Quotes.UnionWith(asset.Quotes);
            this.RowVersion = asset.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Asset other && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Asset"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Assets(Fixture fixture) : IEnlistmentNotification, IEnumerable<Asset>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<System.Guid, Asset> dictionary = new Dictionary<System.Guid, Asset>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private readonly ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Asset"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Asset> DeletedRows { get; } = new LinkedList<Asset>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                if (asyncTransaction == null)
                {
                    return null;
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The <see cref="Asset"/> row.</param>
        /// <returns>The added <see cref="Asset"/> row.</returns>
        public Task<Asset> AddAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var originalRow = new Asset(asset);
            asset.RowVersion = this.fixture.IncrementRowVersion();
            this.dictionary.Add(asset.AssetId, asset);
            enlistmentState.RollbackActions.Add(() =>
            {
                asset.CopyFrom(originalRow);
                this.dictionary.Remove(asset.AssetId);
            });
            enlistmentState.CommitActions.Add(() =>
            {
                this.OnRowChanged(DataAction.Add, asset);
            });
            return Task.FromResult(asset);
        }

        /// <summary>
        /// Adds a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The collection of <see cref="Asset"/> rows.</param>
        /// <returns>The added <see cref="Asset"/> rows.</returns>
        public Task<IEnumerable<Asset>> AddAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                var originalRow = new Asset(asset);
                asset.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Add(asset.AssetId, asset);
                enlistmentState.RollbackActions.Add(() =>
                {
                    asset.CopyFrom(originalRow);
                    this.dictionary.Remove(asset.AssetId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, asset);
                });
                addedRows.Add(asset);
            }

            return Task.FromResult<IEnumerable<Asset>>(addedRows);
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var commitAction in enlistmentState.CommitActions)
            {
                commitAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Asset"/> row using the unique key.
        /// </summary>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Asset"/> row, or null if not found.</returns>
        public Asset? Find(System.Guid assetId)
        {
            return this.dictionary.TryGetValue(assetId, out var asset) ? asset : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Asset> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The collection of <see cref="Asset"/> rows to load.</param>
        public void Load(IEnumerable<Asset> assets)
        {
            foreach (var asset in assets)
            {
                this.dictionary.Add(asset.AssetId, asset);
                this.fixture.RowVersion = asset.RowVersion;
                this.OnRowChanged(DataAction.Add, asset);
            }
        }

        /// <summary>
        /// Handles the <see cref="Asset"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="asset">The <see cref="Asset"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Asset asset)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, asset));
                }
                finally
                {
                }
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The collection of <see cref="Asset"/> rows.</param>
        /// <returns>The patched <see cref="Asset"/> rows.</returns>
        public async Task<(IEnumerable<Asset> AddedRows, IEnumerable<Asset> UpdatedRows)> PatchAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Asset>();
            var updatedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(asset.RowVersion, foundRow.RowVersion);
                    var originalRow = new Asset(foundRow);
                    foundRow.AssetId = asset.AssetId;
                    foundRow.Name = asset.Name;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    var originalRow = new Asset(asset);
                    asset.RowVersion = this.fixture.IncrementRowVersion();
                    this.dictionary.Add(asset.AssetId, asset);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        asset.CopyFrom(originalRow);
                        this.dictionary.Remove(asset.AssetId);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Add, asset);
                    });
                    addedRows.Add(asset);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The <see cref="Asset"/> row.</param>
        /// <returns>The added or updated <see cref="Asset"/> row.</returns>
        public async Task<(Asset? AddedRow, Asset? UpdatedRow)> PutAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(asset.RowVersion, foundRow.RowVersion);
                var originalRow = new Asset(foundRow);
                foundRow.AssetId = asset.AssetId;
                foundRow.Name = asset.Name;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return (AddedRow: null, UpdatedRow: foundRow);
            }
            else
            {
                var originalRow = new Asset(asset);
                asset.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Add(asset.AssetId, asset);
                enlistmentState.RollbackActions.Add(() =>
                {
                    asset.CopyFrom(originalRow);
                    this.dictionary.Remove(asset.AssetId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, asset);
                });
                return (AddedRow: asset, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">A collection of <see cref="Asset"/> rows.</param>
        /// <returns>The removed <see cref="Asset"/> rows.</returns>
        public async Task<IEnumerable<Asset>> RemoveAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(asset.RowVersion, foundRow.RowVersion);
                    ConstraintException.ThrowIfTrue(foundRow.Orders.Count != 0, "AssetOrderIndex");
                    ConstraintException.ThrowIfTrue(foundRow.Positions.Count != 0, "AssetPositionIndex");
                    ConstraintException.ThrowIfTrue(foundRow.Quotes.Count != 0, "AssetQuoteIndex");
                    var originalRow = new Asset(foundRow);
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    this.dictionary.Remove(foundRow.AssetId);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        this.dictionary.Add(foundRow.AssetId, foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.DeletedRows.AddFirst(foundRow);
                        this.OnRowChanged(DataAction.Remove, foundRow);
                    });
                    removedRows.Add(foundRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The <see cref="Asset"/> row.</param>
        /// <returns>The removed <see cref="Asset"/> row.</returns>
        public async Task<Asset?> RemoveAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(asset.RowVersion, foundRow.RowVersion);
                ConstraintException.ThrowIfTrue(foundRow.Orders.Count != 0, "AssetOrderIndex");
                ConstraintException.ThrowIfTrue(foundRow.Positions.Count != 0, "AssetPositionIndex");
                ConstraintException.ThrowIfTrue(foundRow.Quotes.Count != 0, "AssetQuoteIndex");
                var originalRow = new Asset(foundRow);
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Remove(foundRow.AssetId);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    this.dictionary.Add(foundRow.AssetId, foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.DeletedRows.AddFirst(foundRow);
                    this.OnRowChanged(DataAction.Remove, foundRow);
                });
                return foundRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var rollbackAction in enlistmentState.RollbackActions)
            {
                rollbackAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Asset"/> row in the table.
        /// </summary>
        /// <param name="assets">The asset row.</param>
        public async Task<IEnumerable<Asset>> UpdateAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(asset.RowVersion, foundRow.RowVersion);
                    var originalRow = new Asset(foundRow);
                    foundRow.AssetId = asset.AssetId;
                    foundRow.Name = asset.Name;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Asset"/> row in the table.
        /// </summary>
        /// <param name="asset">The asset row.</param>
        public async Task<Asset> UpdateAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(asset.RowVersion, foundRow.RowVersion);
                var originalRow = new Asset(foundRow);
                foundRow.AssetId = asset.AssetId;
                foundRow.Name = asset.Name;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return foundRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// Controller for <see cref="Asset"/> rows.
    /// </summary>
    [Route("fixture/[controller]")]
    [ApiController]
    [Authorize]
    public partial class AssetsController : ControllerBase
    {
        private readonly Fixture fixture;
        private readonly FixtureContext fixtureContext;
        private readonly ILogger logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="AssetsController"/> class.
        /// </summary>
        /// <param name="fixture">The data model.</param>
        /// <param name="fixtureContext">The DbContext for the data model.</param>
        /// <param name="logger">The log device.</param>
        public AssetsController(Fixture fixture, FixtureContext fixtureContext, ILogger<AssetsController> logger)
        {
            this.fixture = fixture;
            this.fixtureContext = fixtureContext;
            this.logger = logger;
        }

        /// <summary>
        /// Removes a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="asset">The <see cref="Asset"/> row to be deleted.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete("{assetId}")]
        public async Task<IActionResult> DeleteAsset([FromRoute] System.Guid assetId, [FromBody] Asset asset)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Assets.EnterWriteLockAsync().ConfigureAwait(false);
                if (this.fixture.Assets.Find(assetId) != null)
                {
                    var removedRow = await this.fixture.Assets.RemoveAsync(asset).ConfigureAwait(false);
                    if (removedRow != null)
                    {
                        this.fixtureContext.Assets.Remove(asset);
                        await this.fixtureContext.SaveChangesAsync();
                    }

                    asyncTransaction.Commit();
                }

                return this.Ok(asset);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">A collection of <see cref="Asset"/> rows.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete]
        public async Task<IActionResult> DeleteAssets([FromBody] IEnumerable<Asset> assets)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Assets.EnterWriteLockAsync().ConfigureAwait(false);
                var deletedRows = await this.fixture.Assets.RemoveAsync(assets).ConfigureAwait(false);
                this.fixtureContext.Assets.RemoveRange(deletedRows);
                await this.fixtureContext.SaveChangesAsync();
                asyncTransaction.Commit();
                return this.Ok(deletedRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a specific <see cref="Asset"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <returns>The row matching the key or NotFound.</returns>
        [HttpGet("{assetId}")]
        public async Task<IActionResult> GetAsset([FromRoute] System.Guid assetId)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Assets.EnterReadLockAsync().ConfigureAwait(false);
                var existingRow = this.fixture.Assets.Find(assetId);
                if (existingRow == null)
                {
                    return this.NotFound();
                }

                await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                return this.Ok(new Asset(existingRow));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <returns>A collection of <see cref="Asset"/> rows.</returns>
        [HttpGet]
        public async Task<IActionResult> GetAssets()
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Assets.EnterReadLockAsync().ConfigureAwait(false);
                var existingRows = new List<Asset>();
                foreach (var existingRow in this.fixture.Assets)
                {
                    await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                    existingRows.Add(new Asset(existingRow));
                }

                return this.Ok(existingRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Patches the <see cref="Asset"/> table.
        /// </summary>
        /// <param name="assets">A collection of <see cref="Asset"/> rows.</param>
        /// <returns>The result of applying the patch action.</returns>
        [HttpPatch]
        public async Task<IActionResult> PatchAssetsAsync([FromBody] IEnumerable<Asset> assets)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Assets.EnterWriteLockAsync().ConfigureAwait(false);
                (var addedRows, var updatedRows) = await this.fixture.Assets.PatchAsync(assets).ConfigureAwait(false);
                this.fixtureContext.Assets.AddRange(addedRows);
                this.fixtureContext.Assets.UpdateRange(updatedRows);
                await this.fixtureContext.SaveChangesAsync().ConfigureAwait(false);
                asyncTransaction.Commit();
                return this.Ok(addedRows.Concat(updatedRows));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Puts the <see cref="Asset"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="asset">The <see cref="Asset"/> row.</param>
        /// <returns>The result of applying the put action.</returns>
        [HttpPut("{assetId}")]
        public async Task<IActionResult> PutAsset([FromRoute] System.Guid assetId, [FromBody] Asset asset)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Assets.EnterWriteLockAsync().ConfigureAwait(false);
                (var addedRow, var updatedRow) = await this.fixture.Assets.PutAsync(asset).ConfigureAwait(false);
                if (addedRow != null)
                {
                    this.fixtureContext.Add(addedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Commit();
                    return this.Ok(addedRow);
                }

                if (updatedRow != null)
                {
                    this.fixtureContext.Update(updatedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Commit();
                    return this.Ok(updatedRow);
                }

                throw new InvalidOperationException();
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }
    }

    /// <summary>
    /// A Fixture.
    /// </summary>
    public class Fixture
    {
        /// <summary>
        /// The master row version.
        /// </summary>
        private long rowVersion = 0;

        /// <summary>
        /// Initializes a new instance of the <see cref="Fixture"/> class.
        /// </summary>
        /// <param name="logger">The log device.</param>
        public Fixture(ILogger<Fixture> logger)
        {
            this.Logger = logger;
            this.Accounts = new Accounts(this);
            this.Assets = new Assets(this);
            this.Models = new Models(this);
            this.Orders = new Orders(this);
            this.Positions = new Positions(this);
            this.Quotes = new Quotes(this);
        }

        /// <summary>
        /// Gets the <see cref="Accounts"/> table.
        /// </summary>
        public Accounts Accounts { get; }

        /// <summary>
        /// Gets the <see cref="Assets"/> table.
        /// </summary>
        public Assets Assets { get; }

        /// <summary>
        /// Gets the log device.
        /// </summary>
        internal ILogger Logger { get; }

        /// <summary>
        /// Gets the <see cref="Models"/> table.
        /// </summary>
        public Models Models { get; }

        /// <summary>
        /// Gets the <see cref="Orders"/> table.
        /// </summary>
        public Orders Orders { get; }

        /// <summary>
        /// Gets the <see cref="Positions"/> table.
        /// </summary>
        public Positions Positions { get; }

        /// <summary>
        /// Gets the <see cref="Quotes"/> table.
        /// </summary>
        public Quotes Quotes { get; }

        /// <summary>
        /// Gets or sets the master row version.
        /// </summary>
        public long RowVersion
        {
            get
            {
                return System.Threading.Interlocked.Read(ref this.rowVersion);
            }

            set
            {
                if (this.rowVersion < value)
                {
                    System.Threading.Interlocked.Exchange(ref this.rowVersion, value);
                }
            }
        }

        /// <summary>
        /// Increment the master row version.
        /// </summary>
        /// <returns>The incremented row version.</returns>
        public long IncrementRowVersion()
        {
            return System.Threading.Interlocked.Increment(ref this.rowVersion);
        }
    }

    /// <summary>
    /// The Entity Framework DbContext for the Fixture.
    /// </summary>
    public class FixtureContext : DbContext
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FixtureContext"/> class.
        /// </summary>
        /// <param name="contextOptions">The options for bulding the DbContext.</param>
        public FixtureContext(DbContextOptions<FixtureContext> contextOptions) : base(contextOptions)
        {
        }

        /// <summary>
        /// Gets or sets the <see cref="Account"/> set.
        /// </summary>
        public virtual DbSet<Account> Accounts { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="Asset"/> set.
        /// </summary>
        public virtual DbSet<Asset> Assets { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="Model"/> set.
        /// </summary>
        public virtual DbSet<Model> Models { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="Order"/> set.
        /// </summary>
        public virtual DbSet<Order> Orders { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="Position"/> set.
        /// </summary>
        public virtual DbSet<Position> Positions { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="Quote"/> set.
        /// </summary>
        public virtual DbSet<Quote> Quotes { get; set; }

        /// <summary>
        /// Loads the <see cref="Fixture"/>.
        /// </summary>
        /// <param name="fixture">The data model.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task LoadAsync(Fixture fixture)
        {
            fixture.Assets.Load(await this.Assets.ToListAsync().ConfigureAwait(false));
            fixture.Models.Load(await this.Models.ToListAsync().ConfigureAwait(false));
            fixture.Quotes.Load(await this.Quotes.ToListAsync().ConfigureAwait(false));
            fixture.Accounts.Load(await this.Accounts.ToListAsync().ConfigureAwait(false));
            fixture.Orders.Load(await this.Orders.ToListAsync().ConfigureAwait(false));
            fixture.Positions.Load(await this.Positions.ToListAsync().ConfigureAwait(false));
        }

        /// <inheritdoc/>
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Account>().ToTable("Account");
            modelBuilder.Entity<Account>().Property(a => a.AccountId).IsRequired();
            modelBuilder.Entity<Account>().Property(a => a.Name).IsRequired().HasMaxLength(128);
            modelBuilder.Entity<Account>().Property(a => a.RowVersion).IsRequired();
            modelBuilder.Entity<Account>().Ignore(a => a.Model).Ignore(a => a.Orders).Ignore(a => a.Positions);
            modelBuilder.Entity<Account>().HasKey(a => a.AccountId);
            modelBuilder.Entity<Asset>().ToTable("Asset");
            modelBuilder.Entity<Asset>().Property(a => a.AssetId).IsRequired();
            modelBuilder.Entity<Asset>().Property(a => a.Name).IsRequired().HasMaxLength(128);
            modelBuilder.Entity<Asset>().Property(a => a.RowVersion).IsRequired();
            modelBuilder.Entity<Asset>().Ignore(a => a.Orders).Ignore(a => a.Positions).Ignore(a => a.Quotes);
            modelBuilder.Entity<Asset>().HasKey(a => a.AssetId);
            modelBuilder.Entity<Model>().ToTable("Model");
            modelBuilder.Entity<Model>().Property(m => m.ModelId).IsRequired();
            modelBuilder.Entity<Model>().Property(m => m.Name).IsRequired().HasMaxLength(128);
            modelBuilder.Entity<Model>().Property(m => m.RowVersion).IsRequired();
            modelBuilder.Entity<Model>().Ignore(m => m.Accounts);
            modelBuilder.Entity<Model>().HasKey(m => m.ModelId);
            modelBuilder.Entity<Order>().ToTable("Order");
            modelBuilder.Entity<Order>().Property(o => o.AccountId).IsRequired();
            modelBuilder.Entity<Order>().Property(o => o.AssetId).IsRequired();
            modelBuilder.Entity<Order>().Property(o => o.Quantity).HasColumnType("decimal(21,6)").IsRequired();
            modelBuilder.Entity<Order>().Property(o => o.RowVersion).IsRequired();
            modelBuilder.Entity<Order>().Ignore(o => o.Account).Ignore(o => o.Asset);
            modelBuilder.Entity<Order>().HasKey(o => new { o.AccountId, o.AssetId });
            modelBuilder.Entity<Position>().ToTable("Position");
            modelBuilder.Entity<Position>().Property(p => p.AccountId).IsRequired();
            modelBuilder.Entity<Position>().Property(p => p.AssetId).IsRequired();
            modelBuilder.Entity<Position>().Property(p => p.Quantity).HasColumnType("decimal(21,6)").IsRequired();
            modelBuilder.Entity<Position>().Property(p => p.RowVersion).IsRequired();
            modelBuilder.Entity<Position>().Ignore(p => p.Account).Ignore(p => p.Asset);
            modelBuilder.Entity<Position>().HasKey(p => new { p.AccountId, p.AssetId });
            modelBuilder.Entity<Quote>().ToTable("Quote");
            modelBuilder.Entity<Quote>().Property(q => q.AssetId).IsRequired();
            modelBuilder.Entity<Quote>().Property(q => q.Last).HasColumnType("decimal(21,6)").IsRequired();
            modelBuilder.Entity<Quote>().Property(q => q.RowVersion).IsRequired();
            modelBuilder.Entity<Quote>().Ignore(q => q.Asset);
            modelBuilder.Entity<Quote>().HasKey(q => q.AssetId);
        }
    }

    /// <summary>
    /// A Model row.
    /// </summary>
    public class Model
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Model"/> class.
        /// </summary>
        public Model()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Model"/> class.
        /// </summary>
        /// /// <param name="model">The model.</param>
        public Model(Model model)
        {
            this.Accounts.UnionWith(model.Accounts);
            this.ModelId = model.ModelId;
            this.Name = model.Name;
            this.RowVersion = model.RowVersion;
        }

        /// <summary>
        /// Gets the child <see cref="Account"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Account> Accounts { get; } = new HashSet<Account>();

        /// <summary>
        /// Gets or sets the ModelId.
        /// </summary>
        [JsonPropertyName("modelId")]
        public System.Guid ModelId { get; set; }

        /// <summary>
        /// Gets or sets the Name.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Deep copy of a <see cref="Model"/> row.
        /// </summary>
        /// <param name="model">The destination <see cref="Model"/> row.</param>
        public void CopyFrom(Model model)
        {
            this.Accounts.Clear();
            this.Accounts.UnionWith(model.Accounts);
            this.ModelId = model.ModelId;
            this.Name = model.Name;
            this.RowVersion = model.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Model other && this.ModelId == other.ModelId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.ModelId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Model"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Models(Fixture fixture) : IEnlistmentNotification, IEnumerable<Model>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<System.Guid, Model> dictionary = new Dictionary<System.Guid, Model>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private readonly ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Model"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Model> DeletedRows { get; } = new LinkedList<Model>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                if (asyncTransaction == null)
                {
                    return null;
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Model"/> row.
        /// </summary>
        /// <param name="model">The <see cref="Model"/> row.</param>
        /// <returns>The added <see cref="Model"/> row.</returns>
        public Task<Model> AddAsync(Model model)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var originalRow = new Model(model);
            model.RowVersion = this.fixture.IncrementRowVersion();
            this.dictionary.Add(model.ModelId, model);
            enlistmentState.RollbackActions.Add(() =>
            {
                model.CopyFrom(originalRow);
                this.dictionary.Remove(model.ModelId);
            });
            enlistmentState.CommitActions.Add(() =>
            {
                this.OnRowChanged(DataAction.Add, model);
            });
            return Task.FromResult(model);
        }

        /// <summary>
        /// Adds a collection of <see cref="Model"/> rows.
        /// </summary>
        /// <param name="models">The collection of <see cref="Model"/> rows.</param>
        /// <returns>The added <see cref="Model"/> rows.</returns>
        public Task<IEnumerable<Model>> AddAsync(IEnumerable<Model> models)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Model>();
            foreach (var model in models)
            {
                var originalRow = new Model(model);
                model.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Add(model.ModelId, model);
                enlistmentState.RollbackActions.Add(() =>
                {
                    model.CopyFrom(originalRow);
                    this.dictionary.Remove(model.ModelId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, model);
                });
                addedRows.Add(model);
            }

            return Task.FromResult<IEnumerable<Model>>(addedRows);
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var commitAction in enlistmentState.CommitActions)
            {
                commitAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Model"/> row using the unique key.
        /// </summary>
        /// <param name="modelId">The modelId.</param>
        /// <returns>The found <see cref="Model"/> row, or null if not found.</returns>
        public Model? Find(System.Guid modelId)
        {
            return this.dictionary.TryGetValue(modelId, out var model) ? model : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Model> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Model"/> rows.
        /// </summary>
        /// <param name="models">The collection of <see cref="Model"/> rows to load.</param>
        public void Load(IEnumerable<Model> models)
        {
            foreach (var model in models)
            {
                this.dictionary.Add(model.ModelId, model);
                this.fixture.RowVersion = model.RowVersion;
                this.OnRowChanged(DataAction.Add, model);
            }
        }

        /// <summary>
        /// Handles the <see cref="Model"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="model">The <see cref="Model"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Model model)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, model));
                }
                finally
                {
                }
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Model"/> rows.
        /// </summary>
        /// <param name="models">The collection of <see cref="Model"/> rows.</param>
        /// <returns>The patched <see cref="Model"/> rows.</returns>
        public async Task<(IEnumerable<Model> AddedRows, IEnumerable<Model> UpdatedRows)> PatchAsync(IEnumerable<Model> models)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Model>();
            var updatedRows = new List<Model>();
            foreach (var model in models)
            {
                if (this.dictionary.TryGetValue(model.ModelId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(model.RowVersion, foundRow.RowVersion);
                    var originalRow = new Model(foundRow);
                    foundRow.ModelId = model.ModelId;
                    foundRow.Name = model.Name;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    var originalRow = new Model(model);
                    model.RowVersion = this.fixture.IncrementRowVersion();
                    this.dictionary.Add(model.ModelId, model);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        model.CopyFrom(originalRow);
                        this.dictionary.Remove(model.ModelId);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Add, model);
                    });
                    addedRows.Add(model);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Model"/> row.
        /// </summary>
        /// <param name="model">The <see cref="Model"/> row.</param>
        /// <returns>The added or updated <see cref="Model"/> row.</returns>
        public async Task<(Model? AddedRow, Model? UpdatedRow)> PutAsync(Model model)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(model.ModelId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(model.RowVersion, foundRow.RowVersion);
                var originalRow = new Model(foundRow);
                foundRow.ModelId = model.ModelId;
                foundRow.Name = model.Name;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return (AddedRow: null, UpdatedRow: foundRow);
            }
            else
            {
                var originalRow = new Model(model);
                model.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Add(model.ModelId, model);
                enlistmentState.RollbackActions.Add(() =>
                {
                    model.CopyFrom(originalRow);
                    this.dictionary.Remove(model.ModelId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, model);
                });
                return (AddedRow: model, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Model"/> rows.
        /// </summary>
        /// <param name="models">A collection of <see cref="Model"/> rows.</param>
        /// <returns>The removed <see cref="Model"/> rows.</returns>
        public async Task<IEnumerable<Model>> RemoveAsync(IEnumerable<Model> models)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Model>();
            foreach (var model in models)
            {
                if (this.dictionary.TryGetValue(model.ModelId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(model.RowVersion, foundRow.RowVersion);
                    ConstraintException.ThrowIfTrue(foundRow.Accounts.Count != 0, "ModelAccountIndex");
                    var originalRow = new Model(foundRow);
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    this.dictionary.Remove(foundRow.ModelId);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        this.dictionary.Add(foundRow.ModelId, foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.DeletedRows.AddFirst(foundRow);
                        this.OnRowChanged(DataAction.Remove, foundRow);
                    });
                    removedRows.Add(foundRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Model"/> row.
        /// </summary>
        /// <param name="model">The <see cref="Model"/> row.</param>
        /// <returns>The removed <see cref="Model"/> row.</returns>
        public async Task<Model?> RemoveAsync(Model model)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(model.ModelId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(model.RowVersion, foundRow.RowVersion);
                ConstraintException.ThrowIfTrue(foundRow.Accounts.Count != 0, "ModelAccountIndex");
                var originalRow = new Model(foundRow);
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                this.dictionary.Remove(foundRow.ModelId);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    this.dictionary.Add(foundRow.ModelId, foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.DeletedRows.AddFirst(foundRow);
                    this.OnRowChanged(DataAction.Remove, foundRow);
                });
                return foundRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var rollbackAction in enlistmentState.RollbackActions)
            {
                rollbackAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Model"/> row in the table.
        /// </summary>
        /// <param name="models">The model row.</param>
        public async Task<IEnumerable<Model>> UpdateAsync(IEnumerable<Model> models)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Model>();
            foreach (var model in models)
            {
                if (this.dictionary.TryGetValue(model.ModelId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(model.RowVersion, foundRow.RowVersion);
                    var originalRow = new Model(foundRow);
                    foundRow.ModelId = model.ModelId;
                    foundRow.Name = model.Name;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Model"/> row in the table.
        /// </summary>
        /// <param name="model">The model row.</param>
        public async Task<Model> UpdateAsync(Model model)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(model.ModelId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(model.RowVersion, foundRow.RowVersion);
                var originalRow = new Model(foundRow);
                foundRow.ModelId = model.ModelId;
                foundRow.Name = model.Name;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return foundRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// Controller for <see cref="Model"/> rows.
    /// </summary>
    [Route("fixture/[controller]")]
    [ApiController]
    [Authorize]
    public partial class ModelsController : ControllerBase
    {
        private readonly Fixture fixture;
        private readonly FixtureContext fixtureContext;
        private readonly ILogger logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="ModelsController"/> class.
        /// </summary>
        /// <param name="fixture">The data model.</param>
        /// <param name="fixtureContext">The DbContext for the data model.</param>
        /// <param name="logger">The log device.</param>
        public ModelsController(Fixture fixture, FixtureContext fixtureContext, ILogger<ModelsController> logger)
        {
            this.fixture = fixture;
            this.fixtureContext = fixtureContext;
            this.logger = logger;
        }

        /// <summary>
        /// Removes a <see cref="Model"/> row.
        /// </summary>
        /// <param name="modelId">The ModelId key.</param>
        /// <param name="model">The <see cref="Model"/> row to be deleted.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete("{modelId}")]
        public async Task<IActionResult> DeleteModel([FromRoute] System.Guid modelId, [FromBody] Model model)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Models.EnterWriteLockAsync().ConfigureAwait(false);
                if (this.fixture.Models.Find(modelId) != null)
                {
                    var removedRow = await this.fixture.Models.RemoveAsync(model).ConfigureAwait(false);
                    if (removedRow != null)
                    {
                        this.fixtureContext.Models.Remove(model);
                        await this.fixtureContext.SaveChangesAsync();
                    }

                    asyncTransaction.Commit();
                }

                return this.Ok(model);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Model"/> rows.
        /// </summary>
        /// <param name="models">A collection of <see cref="Model"/> rows.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete]
        public async Task<IActionResult> DeleteModels([FromBody] IEnumerable<Model> models)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Models.EnterWriteLockAsync().ConfigureAwait(false);
                var deletedRows = await this.fixture.Models.RemoveAsync(models).ConfigureAwait(false);
                this.fixtureContext.Models.RemoveRange(deletedRows);
                await this.fixtureContext.SaveChangesAsync();
                asyncTransaction.Commit();
                return this.Ok(deletedRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a specific <see cref="Model"/> row.
        /// </summary>
        /// <param name="modelId">The ModelId key.</param>
        /// <returns>The row matching the key or NotFound.</returns>
        [HttpGet("{modelId}")]
        public async Task<IActionResult> GetModel([FromRoute] System.Guid modelId)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Models.EnterReadLockAsync().ConfigureAwait(false);
                var existingRow = this.fixture.Models.Find(modelId);
                if (existingRow == null)
                {
                    return this.NotFound();
                }

                await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                return this.Ok(new Model(existingRow));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a collection of <see cref="Model"/> rows.
        /// </summary>
        /// <returns>A collection of <see cref="Model"/> rows.</returns>
        [HttpGet]
        public async Task<IActionResult> GetModels()
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Models.EnterReadLockAsync().ConfigureAwait(false);
                var existingRows = new List<Model>();
                foreach (var existingRow in this.fixture.Models)
                {
                    await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                    existingRows.Add(new Model(existingRow));
                }

                return this.Ok(existingRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Patches the <see cref="Model"/> table.
        /// </summary>
        /// <param name="models">A collection of <see cref="Model"/> rows.</param>
        /// <returns>The result of applying the patch action.</returns>
        [HttpPatch]
        public async Task<IActionResult> PatchModelsAsync([FromBody] IEnumerable<Model> models)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Models.EnterWriteLockAsync().ConfigureAwait(false);
                (var addedRows, var updatedRows) = await this.fixture.Models.PatchAsync(models).ConfigureAwait(false);
                this.fixtureContext.Models.AddRange(addedRows);
                this.fixtureContext.Models.UpdateRange(updatedRows);
                await this.fixtureContext.SaveChangesAsync().ConfigureAwait(false);
                asyncTransaction.Commit();
                return this.Ok(addedRows.Concat(updatedRows));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Puts the <see cref="Model"/> row.
        /// </summary>
        /// <param name="modelId">The ModelId key.</param>
        /// <param name="model">The <see cref="Model"/> row.</param>
        /// <returns>The result of applying the put action.</returns>
        [HttpPut("{modelId}")]
        public async Task<IActionResult> PutModel([FromRoute] System.Guid modelId, [FromBody] Model model)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Models.EnterWriteLockAsync().ConfigureAwait(false);
                (var addedRow, var updatedRow) = await this.fixture.Models.PutAsync(model).ConfigureAwait(false);
                if (addedRow != null)
                {
                    this.fixtureContext.Add(addedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Commit();
                    return this.Ok(addedRow);
                }

                if (updatedRow != null)
                {
                    this.fixtureContext.Update(updatedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Commit();
                    return this.Ok(updatedRow);
                }

                throw new InvalidOperationException();
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }
    }

    /// <summary>
    /// Used to configure the MVC environment.
    /// </summary>
    public static class MvcCoreMvcBuilderExtensions
    {
        /// <summary>
        /// Adds the <see cref="Fixture"/> controllers to the application.
        /// </summary>
        /// <returns>The <see cref="IMvcBuilder"/>.</returns>
        public static IMvcBuilder AddFixtureControllers(this IMvcBuilder builder)
        {
            return builder.AddApplicationPart(Assembly.GetExecutingAssembly());
        }
    }

    /// <summary>
    /// A Order row.
    /// </summary>
    public class Order
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Order"/> class.
        /// </summary>
        public Order()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Order"/> class.
        /// </summary>
        /// /// <param name="order">The order.</param>
        public Order(Order order)
        {
            this.Account = order.Account;
            this.AccountId = order.AccountId;
            this.Asset = order.Asset;
            this.AssetId = order.AssetId;
            this.Quantity = order.Quantity;
            this.RowVersion = order.RowVersion;
        }

        /// <summary>
        /// Gets or sets the parent <see cref="Account"/> row.
        /// </summary>
        [JsonIgnore]
        public Account? Account { get; set; }

        /// <summary>
        /// Gets or sets the AccountId.
        /// </summary>
        [JsonPropertyName("accountId")]
        public System.Guid AccountId { get; set; }

        /// <summary>
        /// Gets or sets the parent <see cref="Asset"/> row.
        /// </summary>
        [JsonIgnore]
        public Asset? Asset { get; set; }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Quantity.
        /// </summary>
        [JsonPropertyName("quantity")]
        public decimal Quantity { get; set; }

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Deep copy of a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The destination <see cref="Order"/> row.</param>
        public void CopyFrom(Order order)
        {
            this.Account = order.Account;
            this.AccountId = order.AccountId;
            this.Asset = order.Asset;
            this.AssetId = order.AssetId;
            this.Quantity = order.Quantity;
            this.RowVersion = order.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Order other && this.AccountId == other.AccountId && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AccountId.GetHashCode() + this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Order"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Orders(Fixture fixture) : IEnlistmentNotification, IEnumerable<Order>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<(System.Guid, System.Guid), Order> dictionary = new Dictionary<(System.Guid, System.Guid), Order>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private readonly ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Order"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Order> DeletedRows { get; } = new LinkedList<Order>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                if (asyncTransaction == null)
                {
                    return null;
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The <see cref="Order"/> row.</param>
        /// <returns>The added <see cref="Order"/> row.</returns>
        public async Task<Order> AddAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedAccount = this.fixture.Accounts.Find(order.AccountId);
            ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
            await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
            var addedAsset = this.fixture.Assets.Find(order.AssetId);
            ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
            await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
            var originalRow = new Order(order);
            order.Account = addedAccount;
            order.Asset = addedAsset;
            order.RowVersion = this.fixture.IncrementRowVersion();
            addedAccount.Orders.Add(order);
            addedAsset.Orders.Add(order);
            this.dictionary.Add((order.AccountId, order.AssetId), order);
            enlistmentState.RollbackActions.Add(() =>
            {
                order.CopyFrom(originalRow);
                addedAccount.Orders.Remove(order);
                addedAsset.Orders.Remove(order);
                this.dictionary.Remove((order.AccountId, order.AssetId));
            });
            enlistmentState.CommitActions.Add(() =>
            {
                this.OnRowChanged(DataAction.Add, order);
            });
            return order;
        }

        /// <summary>
        /// Adds a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The collection of <see cref="Order"/> rows.</param>
        /// <returns>The added <see cref="Order"/> rows.</returns>
        public async Task<IEnumerable<Order>> AddAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Order>();
            foreach (var order in orders)
            {
                var addedAccount = this.fixture.Accounts.Find(order.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                var addedAsset = this.fixture.Assets.Find(order.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Order(order);
                order.Account = addedAccount;
                order.Asset = addedAsset;
                order.RowVersion = this.fixture.IncrementRowVersion();
                addedAccount.Orders.Add(order);
                addedAsset.Orders.Add(order);
                this.dictionary.Add((order.AccountId, order.AssetId), order);
                enlistmentState.RollbackActions.Add(() =>
                {
                    order.CopyFrom(originalRow);
                    addedAccount.Orders.Remove(order);
                    addedAsset.Orders.Remove(order);
                    this.dictionary.Remove((order.AccountId, order.AssetId));
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, order);
                });
                addedRows.Add(order);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var commitAction in enlistmentState.CommitActions)
            {
                commitAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Order"/> row using the unique key.
        /// </summary>
        /// <param name="accountId">The accountId.</param>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Order"/> row, or null if not found.</returns>
        public Order? Find(System.Guid accountId, System.Guid assetId)
        {
            return this.dictionary.TryGetValue((accountId, assetId), out var order) ? order : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Order> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The collection of <see cref="Order"/> rows to load.</param>
        public void Load(IEnumerable<Order> orders)
        {
            foreach (var order in orders)
            {
                var account = this.fixture.Accounts.Find(order.AccountId);
                if (account == null)
                {
                    throw new ConstraintException("AccountOrderIndex");
                }

                account.Orders.Add(order);
                order.Account = account;
                var asset = this.fixture.Assets.Find(order.AssetId);
                if (asset == null)
                {
                    throw new ConstraintException("AssetOrderIndex");
                }

                asset.Orders.Add(order);
                order.Asset = asset;
                this.dictionary.Add((order.AccountId, order.AssetId), order);
                this.fixture.RowVersion = order.RowVersion;
                this.OnRowChanged(DataAction.Add, order);
            }
        }

        /// <summary>
        /// Handles the <see cref="Order"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="order">The <see cref="Order"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Order order)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, order));
                }
                finally
                {
                }
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The collection of <see cref="Order"/> rows.</param>
        /// <returns>The patched <see cref="Order"/> rows.</returns>
        public async Task<(IEnumerable<Order> AddedRows, IEnumerable<Order> UpdatedRows)> PatchAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Order>();
            var updatedRows = new List<Order>();
            foreach (var order in orders)
            {
                if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(order.RowVersion, foundRow.RowVersion);
                    var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                    ArgumentNullException.ThrowIfNull(removedAccount);
                    await removedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var addedAccount = this.fixture.Accounts.Find(order.AccountId);
                    ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
                    await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    var addedAsset = this.fixture.Assets.Find(order.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Order(foundRow);
                    foundRow.Account = addedAccount;
                    foundRow.AccountId = order.AccountId;
                    foundRow.Asset = addedAsset;
                    foundRow.AssetId = order.AssetId;
                    foundRow.Quantity = order.Quantity;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    removedAccount.Orders.Remove(foundRow);
                    removedAsset.Orders.Remove(foundRow);
                    addedAccount.Orders.Add(foundRow);
                    addedAsset.Orders.Add(foundRow);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAccount.Orders.Add(foundRow);
                        removedAsset.Orders.Add(foundRow);
                        addedAccount.Orders.Remove(foundRow);
                        addedAsset.Orders.Remove(foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    var addedAccount = this.fixture.Accounts.Find(order.AccountId);
                    ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
                    await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    var addedAsset = this.fixture.Assets.Find(order.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Order(order);
                    order.Account = addedAccount;
                    order.Asset = addedAsset;
                    order.RowVersion = this.fixture.IncrementRowVersion();
                    addedAccount.Orders.Add(order);
                    addedAsset.Orders.Add(order);
                    this.dictionary.Add((order.AccountId, order.AssetId), order);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        order.CopyFrom(originalRow);
                        addedAccount.Orders.Remove(order);
                        addedAsset.Orders.Remove(order);
                        this.dictionary.Remove((order.AccountId, order.AssetId));
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Add, order);
                    });
                    addedRows.Add(order);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The <see cref="Order"/> row.</param>
        /// <returns>The added or updated <see cref="Order"/> row.</returns>
        public async Task<(Order? AddedRow, Order? UpdatedRow)> PutAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(order.RowVersion, foundRow.RowVersion);
                var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                ArgumentNullException.ThrowIfNull(removedAccount);
                await removedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var addedAccount = this.fixture.Accounts.Find(order.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                var addedAsset = this.fixture.Assets.Find(order.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Order(foundRow);
                foundRow.Account = addedAccount;
                foundRow.AccountId = order.AccountId;
                foundRow.Asset = addedAsset;
                foundRow.AssetId = order.AssetId;
                foundRow.Quantity = order.Quantity;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                removedAccount.Orders.Remove(foundRow);
                removedAsset.Orders.Remove(foundRow);
                addedAccount.Orders.Add(foundRow);
                addedAsset.Orders.Add(foundRow);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAccount.Orders.Add(foundRow);
                    removedAsset.Orders.Add(foundRow);
                    addedAccount.Orders.Remove(foundRow);
                    addedAsset.Orders.Remove(foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return (AddedRow: null, UpdatedRow: foundRow);
            }
            else
            {
                var addedAccount = this.fixture.Accounts.Find(order.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                var addedAsset = this.fixture.Assets.Find(order.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Order(order);
                order.Account = addedAccount;
                order.Asset = addedAsset;
                order.RowVersion = this.fixture.IncrementRowVersion();
                addedAccount.Orders.Add(order);
                addedAsset.Orders.Add(order);
                this.dictionary.Add((order.AccountId, order.AssetId), order);
                enlistmentState.RollbackActions.Add(() =>
                {
                    order.CopyFrom(originalRow);
                    addedAccount.Orders.Remove(order);
                    addedAsset.Orders.Remove(order);
                    this.dictionary.Remove((order.AccountId, order.AssetId));
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, order);
                });
                return (AddedRow: order, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">A collection of <see cref="Order"/> rows.</param>
        /// <returns>The removed <see cref="Order"/> rows.</returns>
        public async Task<IEnumerable<Order>> RemoveAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Order>();
            foreach (var order in orders)
            {
                if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(order.RowVersion, foundRow.RowVersion);
                    var removedAccount = this.fixture.Accounts.Find(order.AccountId);
                    ArgumentNullException.ThrowIfNull(removedAccount);
                    await removedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    var removedAsset = this.fixture.Assets.Find(order.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Order(foundRow);
                    foundRow.Account = null;
                    foundRow.Asset = null;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    removedAccount.Orders.Remove(foundRow);
                    removedAsset.Orders.Remove(foundRow);
                    this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAccount.Orders.Add(foundRow);
                        removedAsset.Orders.Add(foundRow);
                        this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.DeletedRows.AddFirst(foundRow);
                        this.OnRowChanged(DataAction.Remove, foundRow);
                    });
                    removedRows.Add(foundRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The <see cref="Order"/> row.</param>
        /// <returns>The removed <see cref="Order"/> row.</returns>
        public async Task<Order?> RemoveAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(order.RowVersion, foundRow.RowVersion);
                var removedAccount = this.fixture.Accounts.Find(order.AccountId);
                ArgumentNullException.ThrowIfNull(removedAccount);
                await removedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                var removedAsset = this.fixture.Assets.Find(order.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Order(foundRow);
                foundRow.Account = null;
                foundRow.Asset = null;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                removedAccount.Orders.Remove(foundRow);
                removedAsset.Orders.Remove(foundRow);
                this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAccount.Orders.Add(foundRow);
                    removedAsset.Orders.Add(foundRow);
                    this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.DeletedRows.AddFirst(foundRow);
                    this.OnRowChanged(DataAction.Remove, foundRow);
                });
                return foundRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var rollbackAction in enlistmentState.RollbackActions)
            {
                rollbackAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Order"/> row in the table.
        /// </summary>
        /// <param name="orders">The order row.</param>
        public async Task<IEnumerable<Order>> UpdateAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Order>();
            foreach (var order in orders)
            {
                if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(order.RowVersion, foundRow.RowVersion);
                    var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                    ArgumentNullException.ThrowIfNull(removedAccount);
                    await removedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var addedAccount = this.fixture.Accounts.Find(order.AccountId);
                    ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
                    await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    var addedAsset = this.fixture.Assets.Find(order.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Order(foundRow);
                    foundRow.Account = addedAccount;
                    foundRow.AccountId = order.AccountId;
                    foundRow.Asset = addedAsset;
                    foundRow.AssetId = order.AssetId;
                    foundRow.Quantity = order.Quantity;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    removedAccount.Orders.Remove(foundRow);
                    removedAsset.Orders.Remove(foundRow);
                    addedAccount.Orders.Add(foundRow);
                    addedAsset.Orders.Add(foundRow);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAccount.Orders.Add(foundRow);
                        removedAsset.Orders.Add(foundRow);
                        addedAccount.Orders.Remove(foundRow);
                        addedAsset.Orders.Remove(foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Order"/> row in the table.
        /// </summary>
        /// <param name="order">The order row.</param>
        public async Task<Order> UpdateAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(order.RowVersion, foundRow.RowVersion);
                var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                ArgumentNullException.ThrowIfNull(removedAccount);
                await removedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var addedAccount = this.fixture.Accounts.Find(order.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                var addedAsset = this.fixture.Assets.Find(order.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Order(foundRow);
                foundRow.Account = addedAccount;
                foundRow.AccountId = order.AccountId;
                foundRow.Asset = addedAsset;
                foundRow.AssetId = order.AssetId;
                foundRow.Quantity = order.Quantity;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                removedAccount.Orders.Remove(foundRow);
                removedAsset.Orders.Remove(foundRow);
                addedAccount.Orders.Add(foundRow);
                addedAsset.Orders.Add(foundRow);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAccount.Orders.Add(foundRow);
                    removedAsset.Orders.Add(foundRow);
                    addedAccount.Orders.Remove(foundRow);
                    addedAsset.Orders.Remove(foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return foundRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// Controller for <see cref="Order"/> rows.
    /// </summary>
    [Route("fixture/[controller]")]
    [ApiController]
    [Authorize]
    public partial class OrdersController : ControllerBase
    {
        private readonly Fixture fixture;
        private readonly FixtureContext fixtureContext;
        private readonly ILogger logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="OrdersController"/> class.
        /// </summary>
        /// <param name="fixture">The data model.</param>
        /// <param name="fixtureContext">The DbContext for the data model.</param>
        /// <param name="logger">The log device.</param>
        public OrdersController(Fixture fixture, FixtureContext fixtureContext, ILogger<OrdersController> logger)
        {
            this.fixture = fixture;
            this.fixtureContext = fixtureContext;
            this.logger = logger;
        }

        /// <summary>
        /// Removes a <see cref="Order"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="order">The <see cref="Order"/> row to be deleted.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete("{accountId}/{assetId}")]
        public async Task<IActionResult> DeleteOrder([FromRoute] System.Guid accountId, [FromRoute] System.Guid assetId, [FromBody] Order order)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Orders.EnterWriteLockAsync().ConfigureAwait(false);
                if (this.fixture.Orders.Find(accountId, assetId) != null)
                {
                    var removedRow = await this.fixture.Orders.RemoveAsync(order).ConfigureAwait(false);
                    if (removedRow != null)
                    {
                        this.fixtureContext.Orders.Remove(order);
                        await this.fixtureContext.SaveChangesAsync();
                    }

                    asyncTransaction.Commit();
                }

                return this.Ok(order);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">A collection of <see cref="Order"/> rows.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete]
        public async Task<IActionResult> DeleteOrders([FromBody] IEnumerable<Order> orders)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Orders.EnterWriteLockAsync().ConfigureAwait(false);
                var deletedRows = await this.fixture.Orders.RemoveAsync(orders).ConfigureAwait(false);
                this.fixtureContext.Orders.RemoveRange(deletedRows);
                await this.fixtureContext.SaveChangesAsync();
                asyncTransaction.Commit();
                return this.Ok(deletedRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a specific <see cref="Order"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <returns>The row matching the key or NotFound.</returns>
        [HttpGet("{accountId}/{assetId}")]
        public async Task<IActionResult> GetOrder([FromRoute] System.Guid accountId, [FromRoute] System.Guid assetId)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Orders.EnterReadLockAsync().ConfigureAwait(false);
                var existingRow = this.fixture.Orders.Find(accountId, assetId);
                if (existingRow == null)
                {
                    return this.NotFound();
                }

                await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                return this.Ok(new Order(existingRow));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <returns>A collection of <see cref="Order"/> rows.</returns>
        [HttpGet]
        public async Task<IActionResult> GetOrders()
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Orders.EnterReadLockAsync().ConfigureAwait(false);
                var existingRows = new List<Order>();
                foreach (var existingRow in this.fixture.Orders)
                {
                    await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                    existingRows.Add(new Order(existingRow));
                }

                return this.Ok(existingRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Patches the <see cref="Order"/> table.
        /// </summary>
        /// <param name="orders">A collection of <see cref="Order"/> rows.</param>
        /// <returns>The result of applying the patch action.</returns>
        [HttpPatch]
        public async Task<IActionResult> PatchOrdersAsync([FromBody] IEnumerable<Order> orders)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Orders.EnterWriteLockAsync().ConfigureAwait(false);
                await this.fixture.Accounts.EnterReadLockAsync().ConfigureAwait(false);
                await this.fixture.Assets.EnterReadLockAsync().ConfigureAwait(false);
                (var addedRows, var updatedRows) = await this.fixture.Orders.PatchAsync(orders).ConfigureAwait(false);
                this.fixtureContext.Orders.AddRange(addedRows);
                this.fixtureContext.Orders.UpdateRange(updatedRows);
                await this.fixtureContext.SaveChangesAsync().ConfigureAwait(false);
                asyncTransaction.Commit();
                return this.Ok(addedRows.Concat(updatedRows));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Puts the <see cref="Order"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="order">The <see cref="Order"/> row.</param>
        /// <returns>The result of applying the put action.</returns>
        [HttpPut("{accountId}/{assetId}")]
        public async Task<IActionResult> PutOrder([FromRoute] System.Guid accountId, [FromRoute] System.Guid assetId, [FromBody] Order order)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Orders.EnterWriteLockAsync().ConfigureAwait(false);
                (var addedRow, var updatedRow) = await this.fixture.Orders.PutAsync(order).ConfigureAwait(false);
                if (addedRow != null)
                {
                    this.fixtureContext.Add(addedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Commit();
                    return this.Ok(addedRow);
                }

                if (updatedRow != null)
                {
                    this.fixtureContext.Update(updatedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Commit();
                    return this.Ok(updatedRow);
                }

                throw new InvalidOperationException();
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }
    }

    /// <summary>
    /// A Position row.
    /// </summary>
    public class Position
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Position"/> class.
        /// </summary>
        public Position()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Position"/> class.
        /// </summary>
        /// /// <param name="position">The position.</param>
        public Position(Position position)
        {
            this.Account = position.Account;
            this.AccountId = position.AccountId;
            this.Asset = position.Asset;
            this.AssetId = position.AssetId;
            this.Quantity = position.Quantity;
            this.RowVersion = position.RowVersion;
        }

        /// <summary>
        /// Gets or sets the parent <see cref="Account"/> row.
        /// </summary>
        [JsonIgnore]
        public Account? Account { get; set; }

        /// <summary>
        /// Gets or sets the AccountId.
        /// </summary>
        [JsonPropertyName("accountId")]
        public System.Guid AccountId { get; set; }

        /// <summary>
        /// Gets or sets the parent <see cref="Asset"/> row.
        /// </summary>
        [JsonIgnore]
        public Asset? Asset { get; set; }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Quantity.
        /// </summary>
        [JsonPropertyName("quantity")]
        public decimal Quantity { get; set; }

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Deep copy of a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The destination <see cref="Position"/> row.</param>
        public void CopyFrom(Position position)
        {
            this.Account = position.Account;
            this.AccountId = position.AccountId;
            this.Asset = position.Asset;
            this.AssetId = position.AssetId;
            this.Quantity = position.Quantity;
            this.RowVersion = position.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Position other && this.AccountId == other.AccountId && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AccountId.GetHashCode() + this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Position"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Positions(Fixture fixture) : IEnlistmentNotification, IEnumerable<Position>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<(System.Guid, System.Guid), Position> dictionary = new Dictionary<(System.Guid, System.Guid), Position>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private readonly ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Position"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Position> DeletedRows { get; } = new LinkedList<Position>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                if (asyncTransaction == null)
                {
                    return null;
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The <see cref="Position"/> row.</param>
        /// <returns>The added <see cref="Position"/> row.</returns>
        public async Task<Position> AddAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedAccount = this.fixture.Accounts.Find(position.AccountId);
            ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
            await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
            var addedAsset = this.fixture.Assets.Find(position.AssetId);
            ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
            await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
            var originalRow = new Position(position);
            position.Account = addedAccount;
            position.Asset = addedAsset;
            position.RowVersion = this.fixture.IncrementRowVersion();
            addedAccount.Positions.Add(position);
            addedAsset.Positions.Add(position);
            this.dictionary.Add((position.AccountId, position.AssetId), position);
            enlistmentState.RollbackActions.Add(() =>
            {
                position.CopyFrom(originalRow);
                addedAccount.Positions.Remove(position);
                addedAsset.Positions.Remove(position);
                this.dictionary.Remove((position.AccountId, position.AssetId));
            });
            enlistmentState.CommitActions.Add(() =>
            {
                this.OnRowChanged(DataAction.Add, position);
            });
            return position;
        }

        /// <summary>
        /// Adds a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The collection of <see cref="Position"/> rows.</param>
        /// <returns>The added <see cref="Position"/> rows.</returns>
        public async Task<IEnumerable<Position>> AddAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Position>();
            foreach (var position in positions)
            {
                var addedAccount = this.fixture.Accounts.Find(position.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                var addedAsset = this.fixture.Assets.Find(position.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Position(position);
                position.Account = addedAccount;
                position.Asset = addedAsset;
                position.RowVersion = this.fixture.IncrementRowVersion();
                addedAccount.Positions.Add(position);
                addedAsset.Positions.Add(position);
                this.dictionary.Add((position.AccountId, position.AssetId), position);
                enlistmentState.RollbackActions.Add(() =>
                {
                    position.CopyFrom(originalRow);
                    addedAccount.Positions.Remove(position);
                    addedAsset.Positions.Remove(position);
                    this.dictionary.Remove((position.AccountId, position.AssetId));
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, position);
                });
                addedRows.Add(position);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var commitAction in enlistmentState.CommitActions)
            {
                commitAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Position"/> row using the unique key.
        /// </summary>
        /// <param name="accountId">The accountId.</param>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Position"/> row, or null if not found.</returns>
        public Position? Find(System.Guid accountId, System.Guid assetId)
        {
            return this.dictionary.TryGetValue((accountId, assetId), out var position) ? position : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Position> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The collection of <see cref="Position"/> rows to load.</param>
        public void Load(IEnumerable<Position> positions)
        {
            foreach (var position in positions)
            {
                var account = this.fixture.Accounts.Find(position.AccountId);
                if (account == null)
                {
                    throw new ConstraintException("AccountPositionIndex");
                }

                account.Positions.Add(position);
                position.Account = account;
                var asset = this.fixture.Assets.Find(position.AssetId);
                if (asset == null)
                {
                    throw new ConstraintException("AssetPositionIndex");
                }

                asset.Positions.Add(position);
                position.Asset = asset;
                this.dictionary.Add((position.AccountId, position.AssetId), position);
                this.fixture.RowVersion = position.RowVersion;
                this.OnRowChanged(DataAction.Add, position);
            }
        }

        /// <summary>
        /// Handles the <see cref="Position"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="position">The <see cref="Position"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Position position)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, position));
                }
                finally
                {
                }
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The collection of <see cref="Position"/> rows.</param>
        /// <returns>The patched <see cref="Position"/> rows.</returns>
        public async Task<(IEnumerable<Position> AddedRows, IEnumerable<Position> UpdatedRows)> PatchAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Position>();
            var updatedRows = new List<Position>();
            foreach (var position in positions)
            {
                if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(position.RowVersion, foundRow.RowVersion);
                    var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                    ArgumentNullException.ThrowIfNull(removedAccount);
                    await removedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var addedAccount = this.fixture.Accounts.Find(position.AccountId);
                    ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
                    await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    var addedAsset = this.fixture.Assets.Find(position.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Position(foundRow);
                    foundRow.Account = addedAccount;
                    foundRow.AccountId = position.AccountId;
                    foundRow.Asset = addedAsset;
                    foundRow.AssetId = position.AssetId;
                    foundRow.Quantity = position.Quantity;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    removedAccount.Positions.Remove(foundRow);
                    removedAsset.Positions.Remove(foundRow);
                    addedAccount.Positions.Add(foundRow);
                    addedAsset.Positions.Add(foundRow);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAccount.Positions.Add(foundRow);
                        removedAsset.Positions.Add(foundRow);
                        addedAccount.Positions.Remove(foundRow);
                        addedAsset.Positions.Remove(foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    var addedAccount = this.fixture.Accounts.Find(position.AccountId);
                    ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
                    await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    var addedAsset = this.fixture.Assets.Find(position.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Position(position);
                    position.Account = addedAccount;
                    position.Asset = addedAsset;
                    position.RowVersion = this.fixture.IncrementRowVersion();
                    addedAccount.Positions.Add(position);
                    addedAsset.Positions.Add(position);
                    this.dictionary.Add((position.AccountId, position.AssetId), position);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        position.CopyFrom(originalRow);
                        addedAccount.Positions.Remove(position);
                        addedAsset.Positions.Remove(position);
                        this.dictionary.Remove((position.AccountId, position.AssetId));
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Add, position);
                    });
                    addedRows.Add(position);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The <see cref="Position"/> row.</param>
        /// <returns>The added or updated <see cref="Position"/> row.</returns>
        public async Task<(Position? AddedRow, Position? UpdatedRow)> PutAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(position.RowVersion, foundRow.RowVersion);
                var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                ArgumentNullException.ThrowIfNull(removedAccount);
                await removedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var addedAccount = this.fixture.Accounts.Find(position.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                var addedAsset = this.fixture.Assets.Find(position.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Position(foundRow);
                foundRow.Account = addedAccount;
                foundRow.AccountId = position.AccountId;
                foundRow.Asset = addedAsset;
                foundRow.AssetId = position.AssetId;
                foundRow.Quantity = position.Quantity;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                removedAccount.Positions.Remove(foundRow);
                removedAsset.Positions.Remove(foundRow);
                addedAccount.Positions.Add(foundRow);
                addedAsset.Positions.Add(foundRow);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAccount.Positions.Add(foundRow);
                    removedAsset.Positions.Add(foundRow);
                    addedAccount.Positions.Remove(foundRow);
                    addedAsset.Positions.Remove(foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return (AddedRow: null, UpdatedRow: foundRow);
            }
            else
            {
                var addedAccount = this.fixture.Accounts.Find(position.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                var addedAsset = this.fixture.Assets.Find(position.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Position(position);
                position.Account = addedAccount;
                position.Asset = addedAsset;
                position.RowVersion = this.fixture.IncrementRowVersion();
                addedAccount.Positions.Add(position);
                addedAsset.Positions.Add(position);
                this.dictionary.Add((position.AccountId, position.AssetId), position);
                enlistmentState.RollbackActions.Add(() =>
                {
                    position.CopyFrom(originalRow);
                    addedAccount.Positions.Remove(position);
                    addedAsset.Positions.Remove(position);
                    this.dictionary.Remove((position.AccountId, position.AssetId));
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, position);
                });
                return (AddedRow: position, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">A collection of <see cref="Position"/> rows.</param>
        /// <returns>The removed <see cref="Position"/> rows.</returns>
        public async Task<IEnumerable<Position>> RemoveAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Position>();
            foreach (var position in positions)
            {
                if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(position.RowVersion, foundRow.RowVersion);
                    var removedAccount = this.fixture.Accounts.Find(position.AccountId);
                    ArgumentNullException.ThrowIfNull(removedAccount);
                    await removedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    var removedAsset = this.fixture.Assets.Find(position.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Position(foundRow);
                    foundRow.Account = null;
                    foundRow.Asset = null;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    removedAccount.Positions.Remove(foundRow);
                    removedAsset.Positions.Remove(foundRow);
                    this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAccount.Positions.Add(foundRow);
                        removedAsset.Positions.Add(foundRow);
                        this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.DeletedRows.AddFirst(foundRow);
                        this.OnRowChanged(DataAction.Remove, foundRow);
                    });
                    removedRows.Add(foundRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The <see cref="Position"/> row.</param>
        /// <returns>The removed <see cref="Position"/> row.</returns>
        public async Task<Position?> RemoveAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(position.RowVersion, foundRow.RowVersion);
                var removedAccount = this.fixture.Accounts.Find(position.AccountId);
                ArgumentNullException.ThrowIfNull(removedAccount);
                await removedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                var removedAsset = this.fixture.Assets.Find(position.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Position(foundRow);
                foundRow.Account = null;
                foundRow.Asset = null;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                removedAccount.Positions.Remove(foundRow);
                removedAsset.Positions.Remove(foundRow);
                this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAccount.Positions.Add(foundRow);
                    removedAsset.Positions.Add(foundRow);
                    this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.DeletedRows.AddFirst(foundRow);
                    this.OnRowChanged(DataAction.Remove, foundRow);
                });
                return foundRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var rollbackAction in enlistmentState.RollbackActions)
            {
                rollbackAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Position"/> row in the table.
        /// </summary>
        /// <param name="positions">The position row.</param>
        public async Task<IEnumerable<Position>> UpdateAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Position>();
            foreach (var position in positions)
            {
                if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(position.RowVersion, foundRow.RowVersion);
                    var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                    ArgumentNullException.ThrowIfNull(removedAccount);
                    await removedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var addedAccount = this.fixture.Accounts.Find(position.AccountId);
                    ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
                    await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                    var addedAsset = this.fixture.Assets.Find(position.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Position(foundRow);
                    foundRow.Account = addedAccount;
                    foundRow.AccountId = position.AccountId;
                    foundRow.Asset = addedAsset;
                    foundRow.AssetId = position.AssetId;
                    foundRow.Quantity = position.Quantity;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    removedAccount.Positions.Remove(foundRow);
                    removedAsset.Positions.Remove(foundRow);
                    addedAccount.Positions.Add(foundRow);
                    addedAsset.Positions.Add(foundRow);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAccount.Positions.Add(foundRow);
                        removedAsset.Positions.Add(foundRow);
                        addedAccount.Positions.Remove(foundRow);
                        addedAsset.Positions.Remove(foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Position"/> row in the table.
        /// </summary>
        /// <param name="position">The position row.</param>
        public async Task<Position> UpdateAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(position.RowVersion, foundRow.RowVersion);
                var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                ArgumentNullException.ThrowIfNull(removedAccount);
                await removedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var addedAccount = this.fixture.Accounts.Find(position.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(false);
                var addedAsset = this.fixture.Assets.Find(position.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Position(foundRow);
                foundRow.Account = addedAccount;
                foundRow.AccountId = position.AccountId;
                foundRow.Asset = addedAsset;
                foundRow.AssetId = position.AssetId;
                foundRow.Quantity = position.Quantity;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                removedAccount.Positions.Remove(foundRow);
                removedAsset.Positions.Remove(foundRow);
                addedAccount.Positions.Add(foundRow);
                addedAsset.Positions.Add(foundRow);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAccount.Positions.Add(foundRow);
                    removedAsset.Positions.Add(foundRow);
                    addedAccount.Positions.Remove(foundRow);
                    addedAsset.Positions.Remove(foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return foundRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// Controller for <see cref="Position"/> rows.
    /// </summary>
    [Route("fixture/[controller]")]
    [ApiController]
    [Authorize]
    public partial class PositionsController : ControllerBase
    {
        private readonly Fixture fixture;
        private readonly FixtureContext fixtureContext;
        private readonly ILogger logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="PositionsController"/> class.
        /// </summary>
        /// <param name="fixture">The data model.</param>
        /// <param name="fixtureContext">The DbContext for the data model.</param>
        /// <param name="logger">The log device.</param>
        public PositionsController(Fixture fixture, FixtureContext fixtureContext, ILogger<PositionsController> logger)
        {
            this.fixture = fixture;
            this.fixtureContext = fixtureContext;
            this.logger = logger;
        }

        /// <summary>
        /// Removes a <see cref="Position"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="position">The <see cref="Position"/> row to be deleted.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete("{accountId}/{assetId}")]
        public async Task<IActionResult> DeletePosition([FromRoute] System.Guid accountId, [FromRoute] System.Guid assetId, [FromBody] Position position)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Positions.EnterWriteLockAsync().ConfigureAwait(false);
                if (this.fixture.Positions.Find(accountId, assetId) != null)
                {
                    var removedRow = await this.fixture.Positions.RemoveAsync(position).ConfigureAwait(false);
                    if (removedRow != null)
                    {
                        this.fixtureContext.Positions.Remove(position);
                        await this.fixtureContext.SaveChangesAsync();
                    }

                    asyncTransaction.Commit();
                }

                return this.Ok(position);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">A collection of <see cref="Position"/> rows.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete]
        public async Task<IActionResult> DeletePositions([FromBody] IEnumerable<Position> positions)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Positions.EnterWriteLockAsync().ConfigureAwait(false);
                var deletedRows = await this.fixture.Positions.RemoveAsync(positions).ConfigureAwait(false);
                this.fixtureContext.Positions.RemoveRange(deletedRows);
                await this.fixtureContext.SaveChangesAsync();
                asyncTransaction.Commit();
                return this.Ok(deletedRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a specific <see cref="Position"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <returns>The row matching the key or NotFound.</returns>
        [HttpGet("{accountId}/{assetId}")]
        public async Task<IActionResult> GetPosition([FromRoute] System.Guid accountId, [FromRoute] System.Guid assetId)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Positions.EnterReadLockAsync().ConfigureAwait(false);
                var existingRow = this.fixture.Positions.Find(accountId, assetId);
                if (existingRow == null)
                {
                    return this.NotFound();
                }

                await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                return this.Ok(new Position(existingRow));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <returns>A collection of <see cref="Position"/> rows.</returns>
        [HttpGet]
        public async Task<IActionResult> GetPositions()
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Positions.EnterReadLockAsync().ConfigureAwait(false);
                var existingRows = new List<Position>();
                foreach (var existingRow in this.fixture.Positions)
                {
                    await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                    existingRows.Add(new Position(existingRow));
                }

                return this.Ok(existingRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Patches the <see cref="Position"/> table.
        /// </summary>
        /// <param name="positions">A collection of <see cref="Position"/> rows.</param>
        /// <returns>The result of applying the patch action.</returns>
        [HttpPatch]
        public async Task<IActionResult> PatchPositionsAsync([FromBody] IEnumerable<Position> positions)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Positions.EnterWriteLockAsync().ConfigureAwait(false);
                await this.fixture.Accounts.EnterReadLockAsync().ConfigureAwait(false);
                await this.fixture.Assets.EnterReadLockAsync().ConfigureAwait(false);
                (var addedRows, var updatedRows) = await this.fixture.Positions.PatchAsync(positions).ConfigureAwait(false);
                this.fixtureContext.Positions.AddRange(addedRows);
                this.fixtureContext.Positions.UpdateRange(updatedRows);
                await this.fixtureContext.SaveChangesAsync().ConfigureAwait(false);
                asyncTransaction.Commit();
                return this.Ok(addedRows.Concat(updatedRows));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Puts the <see cref="Position"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="position">The <see cref="Position"/> row.</param>
        /// <returns>The result of applying the put action.</returns>
        [HttpPut("{accountId}/{assetId}")]
        public async Task<IActionResult> PutPosition([FromRoute] System.Guid accountId, [FromRoute] System.Guid assetId, [FromBody] Position position)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Positions.EnterWriteLockAsync().ConfigureAwait(false);
                (var addedRow, var updatedRow) = await this.fixture.Positions.PutAsync(position).ConfigureAwait(false);
                if (addedRow != null)
                {
                    this.fixtureContext.Add(addedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Commit();
                    return this.Ok(addedRow);
                }

                if (updatedRow != null)
                {
                    this.fixtureContext.Update(updatedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Commit();
                    return this.Ok(updatedRow);
                }

                throw new InvalidOperationException();
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }
    }

    /// <summary>
    /// A Quote row.
    /// </summary>
    public class Quote
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Quote"/> class.
        /// </summary>
        public Quote()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Quote"/> class.
        /// </summary>
        /// /// <param name="quote">The quote.</param>
        public Quote(Quote quote)
        {
            this.Asset = quote.Asset;
            this.AssetId = quote.AssetId;
            this.Last = quote.Last;
            this.RowVersion = quote.RowVersion;
        }

        /// <summary>
        /// Gets or sets the parent <see cref="Asset"/> row.
        /// </summary>
        [JsonIgnore]
        public Asset? Asset { get; set; }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Last.
        /// </summary>
        [JsonPropertyName("last")]
        public decimal Last { get; set; }

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Deep copy of a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The destination <see cref="Quote"/> row.</param>
        public void CopyFrom(Quote quote)
        {
            this.Asset = quote.Asset;
            this.AssetId = quote.AssetId;
            this.Last = quote.Last;
            this.RowVersion = quote.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Quote other && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Quote"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Quotes(Fixture fixture) : IEnlistmentNotification, IEnumerable<Quote>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<System.Guid, Quote> dictionary = new Dictionary<System.Guid, Quote>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private readonly ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Quote"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Quote> DeletedRows { get; } = new LinkedList<Quote>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                if (asyncTransaction == null)
                {
                    return null;
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The <see cref="Quote"/> row.</param>
        /// <returns>The added <see cref="Quote"/> row.</returns>
        public async Task<Quote> AddAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedAsset = this.fixture.Assets.Find(quote.AssetId);
            ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
            await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
            var originalRow = new Quote(quote);
            quote.Asset = addedAsset;
            quote.RowVersion = this.fixture.IncrementRowVersion();
            addedAsset.Quotes.Add(quote);
            this.dictionary.Add(quote.AssetId, quote);
            enlistmentState.RollbackActions.Add(() =>
            {
                quote.CopyFrom(originalRow);
                addedAsset.Quotes.Remove(quote);
                this.dictionary.Remove(quote.AssetId);
            });
            enlistmentState.CommitActions.Add(() =>
            {
                this.OnRowChanged(DataAction.Add, quote);
            });
            return quote;
        }

        /// <summary>
        /// Adds a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The collection of <see cref="Quote"/> rows.</param>
        /// <returns>The added <see cref="Quote"/> rows.</returns>
        public async Task<IEnumerable<Quote>> AddAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                var addedAsset = this.fixture.Assets.Find(quote.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Quote(quote);
                quote.Asset = addedAsset;
                quote.RowVersion = this.fixture.IncrementRowVersion();
                addedAsset.Quotes.Add(quote);
                this.dictionary.Add(quote.AssetId, quote);
                enlistmentState.RollbackActions.Add(() =>
                {
                    quote.CopyFrom(originalRow);
                    addedAsset.Quotes.Remove(quote);
                    this.dictionary.Remove(quote.AssetId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, quote);
                });
                addedRows.Add(quote);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var commitAction in enlistmentState.CommitActions)
            {
                commitAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Quote"/> row using the unique key.
        /// </summary>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Quote"/> row, or null if not found.</returns>
        public Quote? Find(System.Guid assetId)
        {
            return this.dictionary.TryGetValue(assetId, out var quote) ? quote : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Quote> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The collection of <see cref="Quote"/> rows to load.</param>
        public void Load(IEnumerable<Quote> quotes)
        {
            foreach (var quote in quotes)
            {
                var asset = this.fixture.Assets.Find(quote.AssetId);
                if (asset == null)
                {
                    throw new ConstraintException("AssetQuoteIndex");
                }

                asset.Quotes.Add(quote);
                quote.Asset = asset;
                this.dictionary.Add(quote.AssetId, quote);
                this.fixture.RowVersion = quote.RowVersion;
                this.OnRowChanged(DataAction.Add, quote);
            }
        }

        /// <summary>
        /// Handles the <see cref="Quote"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="quote">The <see cref="Quote"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Quote quote)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, quote));
                }
                finally
                {
                }
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The collection of <see cref="Quote"/> rows.</param>
        /// <returns>The patched <see cref="Quote"/> rows.</returns>
        public async Task<(IEnumerable<Quote> AddedRows, IEnumerable<Quote> UpdatedRows)> PatchAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Quote>();
            var updatedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(quote.RowVersion, foundRow.RowVersion);
                    var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var addedAsset = this.fixture.Assets.Find(quote.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Quote(foundRow);
                    foundRow.Asset = addedAsset;
                    foundRow.AssetId = quote.AssetId;
                    foundRow.Last = quote.Last;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    removedAsset.Quotes.Remove(foundRow);
                    addedAsset.Quotes.Add(foundRow);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAsset.Quotes.Add(foundRow);
                        addedAsset.Quotes.Remove(foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    var addedAsset = this.fixture.Assets.Find(quote.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Quote(quote);
                    quote.Asset = addedAsset;
                    quote.RowVersion = this.fixture.IncrementRowVersion();
                    addedAsset.Quotes.Add(quote);
                    this.dictionary.Add(quote.AssetId, quote);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        quote.CopyFrom(originalRow);
                        addedAsset.Quotes.Remove(quote);
                        this.dictionary.Remove(quote.AssetId);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Add, quote);
                    });
                    addedRows.Add(quote);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The <see cref="Quote"/> row.</param>
        /// <returns>The added or updated <see cref="Quote"/> row.</returns>
        public async Task<(Quote? AddedRow, Quote? UpdatedRow)> PutAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(quote.RowVersion, foundRow.RowVersion);
                var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var addedAsset = this.fixture.Assets.Find(quote.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Quote(foundRow);
                foundRow.Asset = addedAsset;
                foundRow.AssetId = quote.AssetId;
                foundRow.Last = quote.Last;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                removedAsset.Quotes.Remove(foundRow);
                addedAsset.Quotes.Add(foundRow);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAsset.Quotes.Add(foundRow);
                    addedAsset.Quotes.Remove(foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return (AddedRow: null, UpdatedRow: foundRow);
            }
            else
            {
                var addedAsset = this.fixture.Assets.Find(quote.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Quote(quote);
                quote.Asset = addedAsset;
                quote.RowVersion = this.fixture.IncrementRowVersion();
                addedAsset.Quotes.Add(quote);
                this.dictionary.Add(quote.AssetId, quote);
                enlistmentState.RollbackActions.Add(() =>
                {
                    quote.CopyFrom(originalRow);
                    addedAsset.Quotes.Remove(quote);
                    this.dictionary.Remove(quote.AssetId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, quote);
                });
                return (AddedRow: quote, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">A collection of <see cref="Quote"/> rows.</param>
        /// <returns>The removed <see cref="Quote"/> rows.</returns>
        public async Task<IEnumerable<Quote>> RemoveAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(quote.RowVersion, foundRow.RowVersion);
                    var removedAsset = this.fixture.Assets.Find(quote.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Quote(foundRow);
                    foundRow.Asset = null;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    removedAsset.Quotes.Remove(foundRow);
                    this.dictionary.Remove(foundRow.AssetId);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAsset.Quotes.Add(foundRow);
                        this.dictionary.Add(foundRow.AssetId, foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.DeletedRows.AddFirst(foundRow);
                        this.OnRowChanged(DataAction.Remove, foundRow);
                    });
                    removedRows.Add(foundRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The <see cref="Quote"/> row.</param>
        /// <returns>The removed <see cref="Quote"/> row.</returns>
        public async Task<Quote?> RemoveAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(quote.RowVersion, foundRow.RowVersion);
                var removedAsset = this.fixture.Assets.Find(quote.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Quote(foundRow);
                foundRow.Asset = null;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                removedAsset.Quotes.Remove(foundRow);
                this.dictionary.Remove(foundRow.AssetId);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAsset.Quotes.Add(foundRow);
                    this.dictionary.Add(foundRow.AssetId, foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.DeletedRows.AddFirst(foundRow);
                    this.OnRowChanged(DataAction.Remove, foundRow);
                });
                return foundRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var rollbackAction in enlistmentState.RollbackActions)
            {
                rollbackAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Quote"/> row in the table.
        /// </summary>
        /// <param name="quotes">The quote row.</param>
        public async Task<IEnumerable<Quote>> UpdateAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                    ConcurrencyException.ThrowIfNotEqual(quote.RowVersion, foundRow.RowVersion);
                    var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var addedAsset = this.fixture.Assets.Find(quote.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                    var originalRow = new Quote(foundRow);
                    foundRow.Asset = addedAsset;
                    foundRow.AssetId = quote.AssetId;
                    foundRow.Last = quote.Last;
                    foundRow.RowVersion = this.fixture.IncrementRowVersion();
                    removedAsset.Quotes.Remove(foundRow);
                    addedAsset.Quotes.Add(foundRow);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAsset.Quotes.Add(foundRow);
                        addedAsset.Quotes.Remove(foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Quote"/> row in the table.
        /// </summary>
        /// <param name="quote">The quote row.</param>
        public async Task<Quote> UpdateAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(false);
                ConcurrencyException.ThrowIfNotEqual(quote.RowVersion, foundRow.RowVersion);
                var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var addedAsset = this.fixture.Assets.Find(quote.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(false);
                var originalRow = new Quote(foundRow);
                foundRow.Asset = addedAsset;
                foundRow.AssetId = quote.AssetId;
                foundRow.Last = quote.Last;
                foundRow.RowVersion = this.fixture.IncrementRowVersion();
                removedAsset.Quotes.Remove(foundRow);
                addedAsset.Quotes.Add(foundRow);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAsset.Quotes.Add(foundRow);
                    addedAsset.Quotes.Remove(foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return foundRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// Controller for <see cref="Quote"/> rows.
    /// </summary>
    [Route("fixture/[controller]")]
    [ApiController]
    [Authorize]
    public partial class QuotesController : ControllerBase
    {
        private readonly Fixture fixture;
        private readonly FixtureContext fixtureContext;
        private readonly ILogger logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="QuotesController"/> class.
        /// </summary>
        /// <param name="fixture">The data model.</param>
        /// <param name="fixtureContext">The DbContext for the data model.</param>
        /// <param name="logger">The log device.</param>
        public QuotesController(Fixture fixture, FixtureContext fixtureContext, ILogger<QuotesController> logger)
        {
            this.fixture = fixture;
            this.fixtureContext = fixtureContext;
            this.logger = logger;
        }

        /// <summary>
        /// Removes a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="quote">The <see cref="Quote"/> row to be deleted.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete("{assetId}")]
        public async Task<IActionResult> DeleteQuote([FromRoute] System.Guid assetId, [FromBody] Quote quote)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Quotes.EnterWriteLockAsync().ConfigureAwait(false);
                if (this.fixture.Quotes.Find(assetId) != null)
                {
                    var removedRow = await this.fixture.Quotes.RemoveAsync(quote).ConfigureAwait(false);
                    if (removedRow != null)
                    {
                        this.fixtureContext.Quotes.Remove(quote);
                        await this.fixtureContext.SaveChangesAsync();
                    }

                    asyncTransaction.Commit();
                }

                return this.Ok(quote);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">A collection of <see cref="Quote"/> rows.</param>
        /// <returns>The result of applying the delete action.</returns>
        [HttpDelete]
        public async Task<IActionResult> DeleteQuotes([FromBody] IEnumerable<Quote> quotes)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Quotes.EnterWriteLockAsync().ConfigureAwait(false);
                var deletedRows = await this.fixture.Quotes.RemoveAsync(quotes).ConfigureAwait(false);
                this.fixtureContext.Quotes.RemoveRange(deletedRows);
                await this.fixtureContext.SaveChangesAsync();
                asyncTransaction.Commit();
                return this.Ok(deletedRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a specific <see cref="Quote"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <returns>The row matching the key or NotFound.</returns>
        [HttpGet("{assetId}")]
        public async Task<IActionResult> GetQuote([FromRoute] System.Guid assetId)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Quotes.EnterReadLockAsync().ConfigureAwait(false);
                var existingRow = this.fixture.Quotes.Find(assetId);
                if (existingRow == null)
                {
                    return this.NotFound();
                }

                await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                return this.Ok(new Quote(existingRow));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Gets a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <returns>A collection of <see cref="Quote"/> rows.</returns>
        [HttpGet]
        public async Task<IActionResult> GetQuotes()
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Quotes.EnterReadLockAsync().ConfigureAwait(false);
                var existingRows = new List<Quote>();
                foreach (var existingRow in this.fixture.Quotes)
                {
                    await existingRow.EnterReadLockAsync().ConfigureAwait(false);
                    existingRows.Add(new Quote(existingRow));
                }

                return this.Ok(existingRows);
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Patches the <see cref="Quote"/> table.
        /// </summary>
        /// <param name="quotes">A collection of <see cref="Quote"/> rows.</param>
        /// <returns>The result of applying the patch action.</returns>
        [HttpPatch]
        public async Task<IActionResult> PatchQuotesAsync([FromBody] IEnumerable<Quote> quotes)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Quotes.EnterWriteLockAsync().ConfigureAwait(false);
                await this.fixture.Assets.EnterReadLockAsync().ConfigureAwait(false);
                (var addedRows, var updatedRows) = await this.fixture.Quotes.PatchAsync(quotes).ConfigureAwait(false);
                this.fixtureContext.Quotes.AddRange(addedRows);
                this.fixtureContext.Quotes.UpdateRange(updatedRows);
                await this.fixtureContext.SaveChangesAsync().ConfigureAwait(false);
                asyncTransaction.Commit();
                return this.Ok(addedRows.Concat(updatedRows));
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }

        /// <summary>
        /// Puts the <see cref="Quote"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="quote">The <see cref="Quote"/> row.</param>
        /// <returns>The result of applying the put action.</returns>
        [HttpPut("{assetId}")]
        public async Task<IActionResult> PutQuote([FromRoute] System.Guid assetId, [FromBody] Quote quote)
        {
            if (!this.ModelState.IsValid)
            {
                return this.BadRequest(this.ModelState);
            }

            try
            {
                using var asyncTransaction = new AsyncTransaction();
                await this.fixture.Quotes.EnterWriteLockAsync().ConfigureAwait(false);
                (var addedRow, var updatedRow) = await this.fixture.Quotes.PutAsync(quote).ConfigureAwait(false);
                if (addedRow != null)
                {
                    this.fixtureContext.Add(addedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Commit();
                    return this.Ok(addedRow);
                }

                if (updatedRow != null)
                {
                    this.fixtureContext.Update(updatedRow);
                    await this.fixtureContext.SaveChangesAsync();
                    asyncTransaction.Commit();
                    return this.Ok(updatedRow);
                }

                throw new InvalidOperationException();
            }
            catch (ConcurrencyException concurrencyException)
            {
                this.logger.LogError(concurrencyException, "{message}", concurrencyException.Message);
                return this.StatusCode(StatusCodes.Status412PreconditionFailed);
            }
            catch (ConstraintException constraintException)
            {
                this.logger.LogError(constraintException, "{message}", constraintException.Message);
                return this.StatusCode(StatusCodes.Status422UnprocessableEntity);
            }
            catch (OperationCanceledException operationCanceledException)
            {
                this.logger.LogError(operationCanceledException, "{message}", operationCanceledException.Message);
                return this.StatusCode(StatusCodes.Status408RequestTimeout);
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "{message}", exception.Message);
                return this.BadRequest($"{exception.GetType()}: {exception.Message}");
            }
        }
    }
}

namespace UnitTest.Slave
{
    using System;
    using System.Collections;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net.Http;
    using System.Text;
    using System.Text.Json;
    using System.Text.Json.Serialization;
    using System.Threading;
    using System.Threading.Tasks;
    using System.Transactions;
    using DotNext.Threading;
    using Microsoft.Extensions.Configuration;
    using Microsoft.Extensions.Logging;
    using UnitTest;

    /// <summary>
    /// A Account row.
    /// </summary>
    public class Account
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Account"/> class.
        /// </summary>
        public Account()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Account"/> class.
        /// </summary>
        /// /// <param name="account">The account.</param>
        public Account(Account account)
        {
            this.AccountId = account.AccountId;
            this.Model = account.Model;
            this.ModelId = account.ModelId;
            this.Name = account.Name;
            this.Orders.UnionWith(account.Orders);
            this.Positions.UnionWith(account.Positions);
            this.RowVersion = account.RowVersion;
        }

        /// <summary>
        /// Gets or sets the AccountId.
        /// </summary>
        [JsonPropertyName("accountId")]
        public System.Guid AccountId { get; set; }

        /// <summary>
        /// Gets or sets the parent <see cref="Model"/> row.
        /// </summary>
        [JsonIgnore]
        public Model? Model { get; set; }

        /// <summary>
        /// Gets or sets the ModelId.
        /// </summary>
        [JsonPropertyName("modelId")]
        public System.Guid? ModelId { get; set; }

        /// <summary>
        /// Gets or sets the Name.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Gets the child <see cref="Order"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Order> Orders { get; } = new HashSet<Order>();

        /// <summary>
        /// Gets the child <see cref="Position"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Position> Positions { get; } = new HashSet<Position>();

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Deep copy of a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The destination <see cref="Account"/> row.</param>
        public void CopyFrom(Account account)
        {
            this.AccountId = account.AccountId;
            this.Model = account.Model;
            this.ModelId = account.ModelId;
            this.Name = account.Name;
            this.Orders.Clear();
            this.Orders.UnionWith(account.Orders);
            this.Positions.Clear();
            this.Positions.UnionWith(account.Positions);
            this.RowVersion = account.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Account other && this.AccountId == other.AccountId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AccountId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Account"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Accounts(Fixture fixture) : IEnlistmentNotification, IEnumerable<Account>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<System.Guid, Account> dictionary = new Dictionary<System.Guid, Account>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private readonly ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Account"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Account> DeletedRows { get; } = new LinkedList<Account>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                if (asyncTransaction == null)
                {
                    return null;
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The <see cref="Account"/> row.</param>
        /// <returns>The added <see cref="Account"/> row.</returns>
        public async Task<Account> AddAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            Model? addedModel = null;
            if (account.ModelId != null)
            {
                addedModel = this.fixture.Models.Find(account.ModelId.Value);
                ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                await addedModel.EnterWriteLockAsync().ConfigureAwait(true);
            }

            var originalRow = new Account(account);
            account.Model = addedModel;
            this.fixture.RowVersion = account.RowVersion;
            if (addedModel != null)
            {
                addedModel.Accounts.Add(account);
            }

            this.dictionary.Add(account.AccountId, account);
            enlistmentState.RollbackActions.Add(() =>
            {
                account.CopyFrom(originalRow);
                if (addedModel != null)
                {
                    addedModel.Accounts.Remove(account);
                }

                this.dictionary.Remove(account.AccountId);
            });
            enlistmentState.CommitActions.Add(() =>
            {
                this.OnRowChanged(DataAction.Add, account);
            });
            return account;
        }

        /// <summary>
        /// Adds a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The collection of <see cref="Account"/> rows.</param>
        /// <returns>The added <see cref="Account"/> rows.</returns>
        public async Task<IEnumerable<Account>> AddAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Account>();
            foreach (var account in accounts)
            {
                Model? addedModel = null;
                if (account.ModelId != null)
                {
                    addedModel = this.fixture.Models.Find(account.ModelId.Value);
                    ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                    await addedModel.EnterWriteLockAsync().ConfigureAwait(true);
                }

                var originalRow = new Account(account);
                account.Model = addedModel;
                this.fixture.RowVersion = account.RowVersion;
                if (addedModel != null)
                {
                    addedModel.Accounts.Add(account);
                }

                this.dictionary.Add(account.AccountId, account);
                enlistmentState.RollbackActions.Add(() =>
                {
                    account.CopyFrom(originalRow);
                    if (addedModel != null)
                    {
                        addedModel.Accounts.Remove(account);
                    }

                    this.dictionary.Remove(account.AccountId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, account);
                });
                addedRows.Add(account);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var commitAction in enlistmentState.CommitActions)
            {
                commitAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Account"/> row using the unique key.
        /// </summary>
        /// <param name="accountId">The accountId.</param>
        /// <returns>The found <see cref="Account"/> row, or null if not found.</returns>
        public Account? Find(System.Guid accountId)
        {
            return this.dictionary.TryGetValue(accountId, out var account) ? account : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Account> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The collection of <see cref="Account"/> rows to load.</param>
        public void Load(IEnumerable<Account> accounts)
        {
            foreach (var account in accounts)
            {
                if (account.ModelId == null)
                {
                    account.ModelId = null;
                }
                else
                {
                    var model = this.fixture.Models.Find(account.ModelId.Value);
                    if (model == null)
                    {
                        throw new ConstraintException("ModelAccountIndex");
                    }

                    model.Accounts.Add(account);
                    account.Model = model;
                }

                this.dictionary.Add(account.AccountId, account);
                this.fixture.RowVersion = account.RowVersion;
                this.OnRowChanged(DataAction.Add, account);
            }
        }

        /// <summary>
        /// Handles the <see cref="Account"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="account">The <see cref="Account"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Account account)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, account));
                }
                finally
                {
                }
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The collection of <see cref="Account"/> rows.</param>
        /// <returns>The patched <see cref="Account"/> rows.</returns>
        public async Task<(IEnumerable<Account> AddedRows, IEnumerable<Account> UpdatedRows)> PatchAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Account>();
            var updatedRows = new List<Account>();
            foreach (var account in accounts)
            {
                if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    Model? removedModel = null;
                    if (foundRow.ModelId != null)
                    {
                        removedModel = this.fixture.Models.Find(foundRow.ModelId.Value);
                        ArgumentNullException.ThrowIfNull(removedModel);
                        await removedModel.EnterWriteLockAsync().ConfigureAwait(true);
                    }

                    Model? addedModel = null;
                    if (account.ModelId != null)
                    {
                        addedModel = this.fixture.Models.Find(account.ModelId.Value);
                        ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                        await addedModel.EnterWriteLockAsync().ConfigureAwait(true);
                    }

                    var originalRow = new Account(foundRow);
                    foundRow.AccountId = account.AccountId;
                    foundRow.Model = addedModel;
                    foundRow.ModelId = account.ModelId;
                    foundRow.Name = account.Name;
                    foundRow.RowVersion = account.RowVersion;
                    if (removedModel != null)
                    {
                        removedModel.Accounts.Remove(foundRow);
                    }

                    if (addedModel != null)
                    {
                        addedModel.Accounts.Add(foundRow);
                    }

                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        if (removedModel != null)
                        {
                            removedModel.Accounts.Add(foundRow);
                        }

                        if (addedModel != null)
                        {
                            addedModel.Accounts.Remove(foundRow);
                        }
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    Model? addedModel = null;
                    if (account.ModelId != null)
                    {
                        addedModel = this.fixture.Models.Find(account.ModelId.Value);
                        ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                        await addedModel.EnterWriteLockAsync().ConfigureAwait(true);
                    }

                    var originalRow = new Account(account);
                    account.Model = addedModel;
                    this.fixture.RowVersion = account.RowVersion;
                    if (addedModel != null)
                    {
                        addedModel.Accounts.Add(account);
                    }

                    this.dictionary.Add(account.AccountId, account);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        account.CopyFrom(originalRow);
                        if (addedModel != null)
                        {
                            addedModel.Accounts.Remove(account);
                        }

                        this.dictionary.Remove(account.AccountId);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Add, account);
                    });
                    addedRows.Add(account);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The <see cref="Account"/> row.</param>
        /// <returns>The added or updated <see cref="Account"/> row.</returns>
        public async Task<(Account? AddedRow, Account? UpdatedRow)> PutAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                Model? removedModel = null;
                if (foundRow.ModelId != null)
                {
                    removedModel = this.fixture.Models.Find(foundRow.ModelId.Value);
                    ArgumentNullException.ThrowIfNull(removedModel);
                    await removedModel.EnterWriteLockAsync().ConfigureAwait(true);
                }

                Model? addedModel = null;
                if (account.ModelId != null)
                {
                    addedModel = this.fixture.Models.Find(account.ModelId.Value);
                    ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                    await addedModel.EnterWriteLockAsync().ConfigureAwait(true);
                }

                var originalRow = new Account(foundRow);
                foundRow.AccountId = account.AccountId;
                foundRow.Model = addedModel;
                foundRow.ModelId = account.ModelId;
                foundRow.Name = account.Name;
                foundRow.RowVersion = account.RowVersion;
                if (removedModel != null)
                {
                    removedModel.Accounts.Remove(foundRow);
                }

                if (addedModel != null)
                {
                    addedModel.Accounts.Add(foundRow);
                }

                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    if (removedModel != null)
                    {
                        removedModel.Accounts.Add(foundRow);
                    }

                    if (addedModel != null)
                    {
                        addedModel.Accounts.Remove(foundRow);
                    }
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return (AddedRow: null, UpdatedRow: foundRow);
            }
            else
            {
                Model? addedModel = null;
                if (account.ModelId != null)
                {
                    addedModel = this.fixture.Models.Find(account.ModelId.Value);
                    ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                    await addedModel.EnterWriteLockAsync().ConfigureAwait(true);
                }

                var originalRow = new Account(account);
                account.Model = addedModel;
                this.fixture.RowVersion = account.RowVersion;
                if (addedModel != null)
                {
                    addedModel.Accounts.Add(account);
                }

                this.dictionary.Add(account.AccountId, account);
                enlistmentState.RollbackActions.Add(() =>
                {
                    account.CopyFrom(originalRow);
                    if (addedModel != null)
                    {
                        addedModel.Accounts.Remove(account);
                    }

                    this.dictionary.Remove(account.AccountId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, account);
                });
                return (AddedRow: account, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">A collection of <see cref="Account"/> rows.</param>
        /// <returns>The removed <see cref="Account"/> rows.</returns>
        public async Task<IEnumerable<Account>> RemoveAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Account>();
            foreach (var account in accounts)
            {
                if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    ConstraintException.ThrowIfTrue(foundRow.Orders.Count != 0, "AccountOrderIndex");
                    ConstraintException.ThrowIfTrue(foundRow.Positions.Count != 0, "AccountPositionIndex");
                    Model? removedModel = null;
                    if (account.ModelId != null)
                    {
                        removedModel = this.fixture.Models.Find(account.ModelId.Value);
                        ArgumentNullException.ThrowIfNull(removedModel);
                        await removedModel.EnterWriteLockAsync().ConfigureAwait(true);
                    }

                    var originalRow = new Account(foundRow);
                    foundRow.Model = null;
                    foundRow.RowVersion = account.RowVersion;
                    if (removedModel != null)
                    {
                        removedModel.Accounts.Remove(foundRow);
                    }

                    this.dictionary.Remove(foundRow.AccountId);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        if (removedModel != null)
                        {
                            removedModel.Accounts.Add(foundRow);
                        }

                        this.dictionary.Add(foundRow.AccountId, foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.DeletedRows.AddFirst(foundRow);
                        this.OnRowChanged(DataAction.Remove, foundRow);
                    });
                    removedRows.Add(foundRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">The <see cref="Account"/> row.</param>
        /// <returns>The removed <see cref="Account"/> row.</returns>
        public async Task<Account?> RemoveAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                ConstraintException.ThrowIfTrue(foundRow.Orders.Count != 0, "AccountOrderIndex");
                ConstraintException.ThrowIfTrue(foundRow.Positions.Count != 0, "AccountPositionIndex");
                Model? removedModel = null;
                if (account.ModelId != null)
                {
                    removedModel = this.fixture.Models.Find(account.ModelId.Value);
                    ArgumentNullException.ThrowIfNull(removedModel);
                    await removedModel.EnterWriteLockAsync().ConfigureAwait(true);
                }

                var originalRow = new Account(foundRow);
                foundRow.Model = null;
                foundRow.RowVersion = account.RowVersion;
                if (removedModel != null)
                {
                    removedModel.Accounts.Remove(foundRow);
                }

                this.dictionary.Remove(foundRow.AccountId);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    if (removedModel != null)
                    {
                        removedModel.Accounts.Add(foundRow);
                    }

                    this.dictionary.Add(foundRow.AccountId, foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.DeletedRows.AddFirst(foundRow);
                    this.OnRowChanged(DataAction.Remove, foundRow);
                });
                return foundRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var rollbackAction in enlistmentState.RollbackActions)
            {
                rollbackAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Account"/> row in the table.
        /// </summary>
        /// <param name="accounts">The account row.</param>
        public async Task<IEnumerable<Account>> UpdateAsync(IEnumerable<Account> accounts)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Account>();
            foreach (var account in accounts)
            {
                if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    Model? removedModel = null;
                    if (foundRow.ModelId != null)
                    {
                        removedModel = this.fixture.Models.Find(foundRow.ModelId.Value);
                        ArgumentNullException.ThrowIfNull(removedModel);
                        await removedModel.EnterWriteLockAsync().ConfigureAwait(true);
                    }

                    Model? addedModel = null;
                    if (account.ModelId != null)
                    {
                        addedModel = this.fixture.Models.Find(account.ModelId.Value);
                        ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                        await addedModel.EnterWriteLockAsync().ConfigureAwait(true);
                    }

                    var originalRow = new Account(foundRow);
                    foundRow.AccountId = account.AccountId;
                    foundRow.Model = addedModel;
                    foundRow.ModelId = account.ModelId;
                    foundRow.Name = account.Name;
                    foundRow.RowVersion = account.RowVersion;
                    if (removedModel != null)
                    {
                        removedModel.Accounts.Remove(foundRow);
                    }

                    if (addedModel != null)
                    {
                        addedModel.Accounts.Add(foundRow);
                    }

                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        if (removedModel != null)
                        {
                            removedModel.Accounts.Add(foundRow);
                        }

                        if (addedModel != null)
                        {
                            addedModel.Accounts.Remove(foundRow);
                        }
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Account"/> row in the table.
        /// </summary>
        /// <param name="account">The account row.</param>
        public async Task<Account> UpdateAsync(Account account)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(account.AccountId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                Model? removedModel = null;
                if (foundRow.ModelId != null)
                {
                    removedModel = this.fixture.Models.Find(foundRow.ModelId.Value);
                    ArgumentNullException.ThrowIfNull(removedModel);
                    await removedModel.EnterWriteLockAsync().ConfigureAwait(true);
                }

                Model? addedModel = null;
                if (account.ModelId != null)
                {
                    addedModel = this.fixture.Models.Find(account.ModelId.Value);
                    ConstraintException.ThrowIfNull(addedModel, "ModelAccountIndex");
                    await addedModel.EnterWriteLockAsync().ConfigureAwait(true);
                }

                var originalRow = new Account(foundRow);
                foundRow.AccountId = account.AccountId;
                foundRow.Model = addedModel;
                foundRow.ModelId = account.ModelId;
                foundRow.Name = account.Name;
                foundRow.RowVersion = account.RowVersion;
                if (removedModel != null)
                {
                    removedModel.Accounts.Remove(foundRow);
                }

                if (addedModel != null)
                {
                    addedModel.Accounts.Add(foundRow);
                }

                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    if (removedModel != null)
                    {
                        removedModel.Accounts.Add(foundRow);
                    }

                    if (addedModel != null)
                    {
                        addedModel.Accounts.Remove(foundRow);
                    }
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return foundRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// A Asset row.
    /// </summary>
    public class Asset
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Asset"/> class.
        /// </summary>
        public Asset()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Asset"/> class.
        /// </summary>
        /// /// <param name="asset">The asset.</param>
        public Asset(Asset asset)
        {
            this.AssetId = asset.AssetId;
            this.Name = asset.Name;
            this.Orders.UnionWith(asset.Orders);
            this.Positions.UnionWith(asset.Positions);
            this.Quotes.UnionWith(asset.Quotes);
            this.RowVersion = asset.RowVersion;
        }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Name.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Gets the child <see cref="Order"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Order> Orders { get; } = new HashSet<Order>();

        /// <summary>
        /// Gets the child <see cref="Position"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Position> Positions { get; } = new HashSet<Position>();

        /// <summary>
        /// Gets the child <see cref="Quote"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Quote> Quotes { get; } = new HashSet<Quote>();

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Deep copy of a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The destination <see cref="Asset"/> row.</param>
        public void CopyFrom(Asset asset)
        {
            this.AssetId = asset.AssetId;
            this.Name = asset.Name;
            this.Orders.Clear();
            this.Orders.UnionWith(asset.Orders);
            this.Positions.Clear();
            this.Positions.UnionWith(asset.Positions);
            this.Quotes.Clear();
            this.Quotes.UnionWith(asset.Quotes);
            this.RowVersion = asset.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Asset other && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Asset"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Assets(Fixture fixture) : IEnlistmentNotification, IEnumerable<Asset>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<System.Guid, Asset> dictionary = new Dictionary<System.Guid, Asset>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private readonly ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Asset"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Asset> DeletedRows { get; } = new LinkedList<Asset>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                if (asyncTransaction == null)
                {
                    return null;
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The <see cref="Asset"/> row.</param>
        /// <returns>The added <see cref="Asset"/> row.</returns>
        public Task<Asset> AddAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var originalRow = new Asset(asset);
            this.fixture.RowVersion = asset.RowVersion;
            this.dictionary.Add(asset.AssetId, asset);
            enlistmentState.RollbackActions.Add(() =>
            {
                asset.CopyFrom(originalRow);
                this.dictionary.Remove(asset.AssetId);
            });
            enlistmentState.CommitActions.Add(() =>
            {
                this.OnRowChanged(DataAction.Add, asset);
            });
            return Task.FromResult(asset);
        }

        /// <summary>
        /// Adds a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The collection of <see cref="Asset"/> rows.</param>
        /// <returns>The added <see cref="Asset"/> rows.</returns>
        public Task<IEnumerable<Asset>> AddAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                var originalRow = new Asset(asset);
                this.fixture.RowVersion = asset.RowVersion;
                this.dictionary.Add(asset.AssetId, asset);
                enlistmentState.RollbackActions.Add(() =>
                {
                    asset.CopyFrom(originalRow);
                    this.dictionary.Remove(asset.AssetId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, asset);
                });
                addedRows.Add(asset);
            }

            return Task.FromResult<IEnumerable<Asset>>(addedRows);
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var commitAction in enlistmentState.CommitActions)
            {
                commitAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Asset"/> row using the unique key.
        /// </summary>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Asset"/> row, or null if not found.</returns>
        public Asset? Find(System.Guid assetId)
        {
            return this.dictionary.TryGetValue(assetId, out var asset) ? asset : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Asset> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The collection of <see cref="Asset"/> rows to load.</param>
        public void Load(IEnumerable<Asset> assets)
        {
            foreach (var asset in assets)
            {
                this.dictionary.Add(asset.AssetId, asset);
                this.fixture.RowVersion = asset.RowVersion;
                this.OnRowChanged(DataAction.Add, asset);
            }
        }

        /// <summary>
        /// Handles the <see cref="Asset"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="asset">The <see cref="Asset"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Asset asset)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, asset));
                }
                finally
                {
                }
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The collection of <see cref="Asset"/> rows.</param>
        /// <returns>The patched <see cref="Asset"/> rows.</returns>
        public async Task<(IEnumerable<Asset> AddedRows, IEnumerable<Asset> UpdatedRows)> PatchAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Asset>();
            var updatedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Asset(foundRow);
                    foundRow.AssetId = asset.AssetId;
                    foundRow.Name = asset.Name;
                    foundRow.RowVersion = asset.RowVersion;
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    var originalRow = new Asset(asset);
                    this.fixture.RowVersion = asset.RowVersion;
                    this.dictionary.Add(asset.AssetId, asset);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        asset.CopyFrom(originalRow);
                        this.dictionary.Remove(asset.AssetId);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Add, asset);
                    });
                    addedRows.Add(asset);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The <see cref="Asset"/> row.</param>
        /// <returns>The added or updated <see cref="Asset"/> row.</returns>
        public async Task<(Asset? AddedRow, Asset? UpdatedRow)> PutAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Asset(foundRow);
                foundRow.AssetId = asset.AssetId;
                foundRow.Name = asset.Name;
                foundRow.RowVersion = asset.RowVersion;
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return (AddedRow: null, UpdatedRow: foundRow);
            }
            else
            {
                var originalRow = new Asset(asset);
                this.fixture.RowVersion = asset.RowVersion;
                this.dictionary.Add(asset.AssetId, asset);
                enlistmentState.RollbackActions.Add(() =>
                {
                    asset.CopyFrom(originalRow);
                    this.dictionary.Remove(asset.AssetId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, asset);
                });
                return (AddedRow: asset, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">A collection of <see cref="Asset"/> rows.</param>
        /// <returns>The removed <see cref="Asset"/> rows.</returns>
        public async Task<IEnumerable<Asset>> RemoveAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    ConstraintException.ThrowIfTrue(foundRow.Orders.Count != 0, "AssetOrderIndex");
                    ConstraintException.ThrowIfTrue(foundRow.Positions.Count != 0, "AssetPositionIndex");
                    ConstraintException.ThrowIfTrue(foundRow.Quotes.Count != 0, "AssetQuoteIndex");
                    var originalRow = new Asset(foundRow);
                    foundRow.RowVersion = asset.RowVersion;
                    this.dictionary.Remove(foundRow.AssetId);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        this.dictionary.Add(foundRow.AssetId, foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.DeletedRows.AddFirst(foundRow);
                        this.OnRowChanged(DataAction.Remove, foundRow);
                    });
                    removedRows.Add(foundRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">The <see cref="Asset"/> row.</param>
        /// <returns>The removed <see cref="Asset"/> row.</returns>
        public async Task<Asset?> RemoveAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                ConstraintException.ThrowIfTrue(foundRow.Orders.Count != 0, "AssetOrderIndex");
                ConstraintException.ThrowIfTrue(foundRow.Positions.Count != 0, "AssetPositionIndex");
                ConstraintException.ThrowIfTrue(foundRow.Quotes.Count != 0, "AssetQuoteIndex");
                var originalRow = new Asset(foundRow);
                foundRow.RowVersion = asset.RowVersion;
                this.dictionary.Remove(foundRow.AssetId);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    this.dictionary.Add(foundRow.AssetId, foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.DeletedRows.AddFirst(foundRow);
                    this.OnRowChanged(DataAction.Remove, foundRow);
                });
                return foundRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var rollbackAction in enlistmentState.RollbackActions)
            {
                rollbackAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Asset"/> row in the table.
        /// </summary>
        /// <param name="assets">The asset row.</param>
        public async Task<IEnumerable<Asset>> UpdateAsync(IEnumerable<Asset> assets)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Asset>();
            foreach (var asset in assets)
            {
                if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Asset(foundRow);
                    foundRow.AssetId = asset.AssetId;
                    foundRow.Name = asset.Name;
                    foundRow.RowVersion = asset.RowVersion;
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Asset"/> row in the table.
        /// </summary>
        /// <param name="asset">The asset row.</param>
        public async Task<Asset> UpdateAsync(Asset asset)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(asset.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Asset(foundRow);
                foundRow.AssetId = asset.AssetId;
                foundRow.Name = asset.Name;
                foundRow.RowVersion = asset.RowVersion;
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return foundRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// A Fixture.
    /// </summary>
    public class Fixture
    {
        /// <summary>
        /// The master row version.
        /// </summary>
        private long rowVersion = 0;

        /// <summary>
        /// Initializes a new instance of the <see cref="Fixture"/> class.
        /// </summary>
        /// <param name="logger">The log device.</param>
        public Fixture(ILogger<Fixture> logger)
        {
            this.Logger = logger;
            this.Accounts = new Accounts(this);
            this.Assets = new Assets(this);
            this.Models = new Models(this);
            this.Orders = new Orders(this);
            this.Positions = new Positions(this);
            this.Quotes = new Quotes(this);
        }

        /// <summary>
        /// Gets the <see cref="Accounts"/> table.
        /// </summary>
        public Accounts Accounts { get; }

        /// <summary>
        /// Gets the <see cref="Assets"/> table.
        /// </summary>
        public Assets Assets { get; }

        /// <summary>
        /// Gets the log device.
        /// </summary>
        internal ILogger Logger { get; }

        /// <summary>
        /// Gets the <see cref="Models"/> table.
        /// </summary>
        public Models Models { get; }

        /// <summary>
        /// Gets the <see cref="Orders"/> table.
        /// </summary>
        public Orders Orders { get; }

        /// <summary>
        /// Gets the <see cref="Positions"/> table.
        /// </summary>
        public Positions Positions { get; }

        /// <summary>
        /// Gets the <see cref="Quotes"/> table.
        /// </summary>
        public Quotes Quotes { get; }

        /// <summary>
        /// Gets or sets the master row version.
        /// </summary>
        public long RowVersion
        {
            get
            {
                return System.Threading.Interlocked.Read(ref this.rowVersion);
            }

            set
            {
                if (this.rowVersion < value)
                {
                    System.Threading.Interlocked.Exchange(ref this.rowVersion, value);
                }
            }
        }

        /// <summary>
        /// Increment the master row version.
        /// </summary>
        /// <returns>The incremented row version.</returns>
        public long IncrementRowVersion()
        {
            return System.Threading.Interlocked.Increment(ref this.rowVersion);
        }
    }

    /// <summary>
    /// A <see cref="Fixture"/> adapter.
    /// </summary>
    public class FixtureAdapter(HttpClient httpClient)
    {
        /// <summary>
        /// Gets the HTTP client.
        /// </summary>
        public HttpClient HttpClient { get; } = httpClient;

        /// <summary>
        /// Gets the collectin of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Account>> GetAccountsAsync(CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, "fixture/accounts");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Account>>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRows);
            return deserializedRows;
        }

        /// <summary>
        /// Gets the collectin of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Asset>> GetAssetsAsync(CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, "fixture/assets");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Asset>>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRows);
            return deserializedRows;
        }

        /// <summary>
        /// Gets a <see cref="Account"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Account> GetAccountAsync(System.Guid accountId, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, $"fixture/accounts/{accountId}");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Account>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Gets a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Asset> GetAssetAsync(System.Guid assetId, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, $"fixture/assets/{assetId}");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Asset>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Gets a <see cref="Model"/> row.
        /// </summary>
        /// <param name="modelId">The ModelId key.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Model> GetModelAsync(System.Guid modelId, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, $"fixture/models/{modelId}");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Model>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Gets a <see cref="Order"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Order> GetOrderAsync(System.Guid accountId, System.Guid assetId, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, $"fixture/orders/{accountId}/{assetId}");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Order>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Gets a <see cref="Position"/> row.
        /// </summary>
        /// <param name="accountId">The AccountId key.</param>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Position> GetPositionAsync(System.Guid accountId, System.Guid assetId, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, $"fixture/positions/{accountId}/{assetId}");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Position>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Gets a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="assetId">The AssetId key.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Quote> GetQuoteAsync(System.Guid assetId, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, $"fixture/quotes/{assetId}");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Quote>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Gets the collectin of <see cref="Model"/> rows.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Model>> GetModelsAsync(CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, "fixture/models");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Model>>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRows);
            return deserializedRows;
        }

        /// <summary>
        /// Gets the collectin of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Order>> GetOrdersAsync(CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, "fixture/orders");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Order>>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRows);
            return deserializedRows;
        }

        /// <summary>
        /// Gets the collectin of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Position>> GetPositionsAsync(CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, "fixture/positions");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Position>>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRows);
            return deserializedRows;
        }

        /// <summary>
        /// Gets the collectin of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Quote>> GetQuotesAsync(CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, "fixture/quotes");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Quote>>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRows);
            return deserializedRows;
        }

        /// <summary>
        /// Patchs a set of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The set of <see cref="Account"/> rows to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Account>> PatchAsync(IEnumerable<Account> accounts, CancellationToken cancellationToken = default)
        {
            if (accounts.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, "fixture/accounts");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(accounts), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Account>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return accounts;
        }

        /// <summary>
        /// Patchs a set of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The set of <see cref="Asset"/> rows to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Asset>> PatchAsync(IEnumerable<Asset> assets, CancellationToken cancellationToken = default)
        {
            if (assets.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, "fixture/assets");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(assets), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Asset>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return assets;
        }

        /// <summary>
        /// Patchs a set of <see cref="Model"/> rows.
        /// </summary>
        /// <param name="models">The set of <see cref="Model"/> rows to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Model>> PatchAsync(IEnumerable<Model> models, CancellationToken cancellationToken = default)
        {
            if (models.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, "fixture/models");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(models), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Model>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return models;
        }

        /// <summary>
        /// Patchs a set of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The set of <see cref="Order"/> rows to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Order>> PatchAsync(IEnumerable<Order> orders, CancellationToken cancellationToken = default)
        {
            if (orders.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, "fixture/orders");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(orders), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Order>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return orders;
        }

        /// <summary>
        /// Patchs a set of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The set of <see cref="Position"/> rows to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Position>> PatchAsync(IEnumerable<Position> positions, CancellationToken cancellationToken = default)
        {
            if (positions.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, "fixture/positions");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(positions), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Position>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return positions;
        }

        /// <summary>
        /// Patchs a set of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The set of <see cref="Quote"/> rows to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Quote>> PatchAsync(IEnumerable<Quote> quotes, CancellationToken cancellationToken = default)
        {
            if (quotes.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, "fixture/quotes");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(quotes), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Quote>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return quotes;
        }

        /// <summary>
        /// Puts a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">A <see cref="Account"/> row to put.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Account> PutAsync(Account account, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, $"fixture/accounts/{account.AccountId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(account), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Account>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Puts a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">A <see cref="Asset"/> row to put.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Asset> PutAsync(Asset asset, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, $"fixture/assets/{asset.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(asset), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Asset>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Puts a <see cref="Model"/> row.
        /// </summary>
        /// <param name="model">A <see cref="Model"/> row to put.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Model> PutAsync(Model model, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, $"fixture/models/{model.ModelId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(model), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Model>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Puts a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">A <see cref="Order"/> row to put.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Order> PutAsync(Order order, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, $"fixture/orders/{order.AccountId}/{order.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(order), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Order>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Puts a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">A <see cref="Position"/> row to put.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Position> PutAsync(Position position, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, $"fixture/positions/{position.AccountId}/{position.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(position), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Position>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Puts a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">A <see cref="Quote"/> row to put.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Quote> PutAsync(Quote quote, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, $"fixture/quotes/{quote.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(quote), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Quote>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Removes a set of <see cref="Account"/> rows.
        /// </summary>
        /// <param name="accounts">The set of <see cref="Account"/> rows.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Account>> RemoveAsync(IEnumerable<Account> accounts, CancellationToken cancellationToken = default)
        {
            if (accounts.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, "fixture/accounts");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(accounts), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Account>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return accounts;
        }

        /// <summary>
        /// Removes a <see cref="Account"/> row.
        /// </summary>
        /// <param name="account">A <see cref="Account"/> row to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Account> RemoveAsync(Account account, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, $"fixture/accounts/{account.AccountId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(account), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Account>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Removes a set of <see cref="Asset"/> rows.
        /// </summary>
        /// <param name="assets">The set of <see cref="Asset"/> rows.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Asset>> RemoveAsync(IEnumerable<Asset> assets, CancellationToken cancellationToken = default)
        {
            if (assets.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, "fixture/assets");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(assets), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Asset>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return assets;
        }

        /// <summary>
        /// Removes a <see cref="Asset"/> row.
        /// </summary>
        /// <param name="asset">A <see cref="Asset"/> row to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Asset> RemoveAsync(Asset asset, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, $"fixture/assets/{asset.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(asset), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Asset>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Removes a set of <see cref="Model"/> rows.
        /// </summary>
        /// <param name="models">The set of <see cref="Model"/> rows.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Model>> RemoveAsync(IEnumerable<Model> models, CancellationToken cancellationToken = default)
        {
            if (models.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, "fixture/models");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(models), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Model>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return models;
        }

        /// <summary>
        /// Removes a <see cref="Model"/> row.
        /// </summary>
        /// <param name="model">A <see cref="Model"/> row to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Model> RemoveAsync(Model model, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, $"fixture/models/{model.ModelId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(model), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Model>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Removes a set of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The set of <see cref="Order"/> rows.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Order>> RemoveAsync(IEnumerable<Order> orders, CancellationToken cancellationToken = default)
        {
            if (orders.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, "fixture/orders");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(orders), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Order>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return orders;
        }

        /// <summary>
        /// Removes a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">A <see cref="Order"/> row to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Order> RemoveAsync(Order order, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, $"fixture/orders/{order.AccountId}/{order.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(order), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Order>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Removes a set of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The set of <see cref="Position"/> rows.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Position>> RemoveAsync(IEnumerable<Position> positions, CancellationToken cancellationToken = default)
        {
            if (positions.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, "fixture/positions");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(positions), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Position>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return positions;
        }

        /// <summary>
        /// Removes a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">A <see cref="Position"/> row to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Position> RemoveAsync(Position position, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, $"fixture/positions/{position.AccountId}/{position.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(position), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Position>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }

        /// <summary>
        /// Removes a set of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The set of <see cref="Quote"/> rows.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<IEnumerable<Quote>> RemoveAsync(IEnumerable<Quote> quotes, CancellationToken cancellationToken = default)
        {
            if (quotes.Any())
            {
                using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, "fixture/quotes");
                httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(quotes), Encoding.Default, "application/json");
                using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
                httpResponseMessage.EnsureSuccessStatusCode();
                var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
                var deserializedRows = JsonSerializer.Deserialize<IEnumerable<Quote>>(responseString);
                ArgumentNullException.ThrowIfNull(deserializedRows);
                return deserializedRows;
            }

            return quotes;
        }

        /// <summary>
        /// Removes a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">A <see cref="Quote"/> row to delete.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task<Quote> RemoveAsync(Quote quote, CancellationToken cancellationToken = default)
        {
            using var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, $"fixture/quotes/{quote.AssetId}");
            httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(quote), Encoding.Default, "application/json");
            using var httpResponseMessage = await this.HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(true);
            httpResponseMessage.EnsureSuccessStatusCode();
            var responseString = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(true);
            var deserializedRow = JsonSerializer.Deserialize<Quote>(responseString);
            ArgumentNullException.ThrowIfNull(deserializedRow);
            return deserializedRow;
        }
    }

    /// <summary>
    /// A Model row.
    /// </summary>
    public class Model
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Model"/> class.
        /// </summary>
        public Model()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Model"/> class.
        /// </summary>
        /// /// <param name="model">The model.</param>
        public Model(Model model)
        {
            this.Accounts.UnionWith(model.Accounts);
            this.ModelId = model.ModelId;
            this.Name = model.Name;
            this.RowVersion = model.RowVersion;
        }

        /// <summary>
        /// Gets the child <see cref="Account"/> rows.
        /// </summary>
        [JsonIgnore]
        public HashSet<Account> Accounts { get; } = new HashSet<Account>();

        /// <summary>
        /// Gets or sets the ModelId.
        /// </summary>
        [JsonPropertyName("modelId")]
        public System.Guid ModelId { get; set; }

        /// <summary>
        /// Gets or sets the Name.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Deep copy of a <see cref="Model"/> row.
        /// </summary>
        /// <param name="model">The destination <see cref="Model"/> row.</param>
        public void CopyFrom(Model model)
        {
            this.Accounts.Clear();
            this.Accounts.UnionWith(model.Accounts);
            this.ModelId = model.ModelId;
            this.Name = model.Name;
            this.RowVersion = model.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Model other && this.ModelId == other.ModelId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.ModelId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Model"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Models(Fixture fixture) : IEnlistmentNotification, IEnumerable<Model>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<System.Guid, Model> dictionary = new Dictionary<System.Guid, Model>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private readonly ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Model"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Model> DeletedRows { get; } = new LinkedList<Model>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                if (asyncTransaction == null)
                {
                    return null;
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Model"/> row.
        /// </summary>
        /// <param name="model">The <see cref="Model"/> row.</param>
        /// <returns>The added <see cref="Model"/> row.</returns>
        public Task<Model> AddAsync(Model model)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var originalRow = new Model(model);
            this.fixture.RowVersion = model.RowVersion;
            this.dictionary.Add(model.ModelId, model);
            enlistmentState.RollbackActions.Add(() =>
            {
                model.CopyFrom(originalRow);
                this.dictionary.Remove(model.ModelId);
            });
            enlistmentState.CommitActions.Add(() =>
            {
                this.OnRowChanged(DataAction.Add, model);
            });
            return Task.FromResult(model);
        }

        /// <summary>
        /// Adds a collection of <see cref="Model"/> rows.
        /// </summary>
        /// <param name="models">The collection of <see cref="Model"/> rows.</param>
        /// <returns>The added <see cref="Model"/> rows.</returns>
        public Task<IEnumerable<Model>> AddAsync(IEnumerable<Model> models)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Model>();
            foreach (var model in models)
            {
                var originalRow = new Model(model);
                this.fixture.RowVersion = model.RowVersion;
                this.dictionary.Add(model.ModelId, model);
                enlistmentState.RollbackActions.Add(() =>
                {
                    model.CopyFrom(originalRow);
                    this.dictionary.Remove(model.ModelId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, model);
                });
                addedRows.Add(model);
            }

            return Task.FromResult<IEnumerable<Model>>(addedRows);
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var commitAction in enlistmentState.CommitActions)
            {
                commitAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Model"/> row using the unique key.
        /// </summary>
        /// <param name="modelId">The modelId.</param>
        /// <returns>The found <see cref="Model"/> row, or null if not found.</returns>
        public Model? Find(System.Guid modelId)
        {
            return this.dictionary.TryGetValue(modelId, out var model) ? model : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Model> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Model"/> rows.
        /// </summary>
        /// <param name="models">The collection of <see cref="Model"/> rows to load.</param>
        public void Load(IEnumerable<Model> models)
        {
            foreach (var model in models)
            {
                this.dictionary.Add(model.ModelId, model);
                this.fixture.RowVersion = model.RowVersion;
                this.OnRowChanged(DataAction.Add, model);
            }
        }

        /// <summary>
        /// Handles the <see cref="Model"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="model">The <see cref="Model"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Model model)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, model));
                }
                finally
                {
                }
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Model"/> rows.
        /// </summary>
        /// <param name="models">The collection of <see cref="Model"/> rows.</param>
        /// <returns>The patched <see cref="Model"/> rows.</returns>
        public async Task<(IEnumerable<Model> AddedRows, IEnumerable<Model> UpdatedRows)> PatchAsync(IEnumerable<Model> models)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Model>();
            var updatedRows = new List<Model>();
            foreach (var model in models)
            {
                if (this.dictionary.TryGetValue(model.ModelId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Model(foundRow);
                    foundRow.ModelId = model.ModelId;
                    foundRow.Name = model.Name;
                    foundRow.RowVersion = model.RowVersion;
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    var originalRow = new Model(model);
                    this.fixture.RowVersion = model.RowVersion;
                    this.dictionary.Add(model.ModelId, model);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        model.CopyFrom(originalRow);
                        this.dictionary.Remove(model.ModelId);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Add, model);
                    });
                    addedRows.Add(model);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Model"/> row.
        /// </summary>
        /// <param name="model">The <see cref="Model"/> row.</param>
        /// <returns>The added or updated <see cref="Model"/> row.</returns>
        public async Task<(Model? AddedRow, Model? UpdatedRow)> PutAsync(Model model)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(model.ModelId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Model(foundRow);
                foundRow.ModelId = model.ModelId;
                foundRow.Name = model.Name;
                foundRow.RowVersion = model.RowVersion;
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return (AddedRow: null, UpdatedRow: foundRow);
            }
            else
            {
                var originalRow = new Model(model);
                this.fixture.RowVersion = model.RowVersion;
                this.dictionary.Add(model.ModelId, model);
                enlistmentState.RollbackActions.Add(() =>
                {
                    model.CopyFrom(originalRow);
                    this.dictionary.Remove(model.ModelId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, model);
                });
                return (AddedRow: model, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Model"/> rows.
        /// </summary>
        /// <param name="models">A collection of <see cref="Model"/> rows.</param>
        /// <returns>The removed <see cref="Model"/> rows.</returns>
        public async Task<IEnumerable<Model>> RemoveAsync(IEnumerable<Model> models)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Model>();
            foreach (var model in models)
            {
                if (this.dictionary.TryGetValue(model.ModelId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    ConstraintException.ThrowIfTrue(foundRow.Accounts.Count != 0, "ModelAccountIndex");
                    var originalRow = new Model(foundRow);
                    foundRow.RowVersion = model.RowVersion;
                    this.dictionary.Remove(foundRow.ModelId);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        this.dictionary.Add(foundRow.ModelId, foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.DeletedRows.AddFirst(foundRow);
                        this.OnRowChanged(DataAction.Remove, foundRow);
                    });
                    removedRows.Add(foundRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Model"/> row.
        /// </summary>
        /// <param name="model">The <see cref="Model"/> row.</param>
        /// <returns>The removed <see cref="Model"/> row.</returns>
        public async Task<Model?> RemoveAsync(Model model)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(model.ModelId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                ConstraintException.ThrowIfTrue(foundRow.Accounts.Count != 0, "ModelAccountIndex");
                var originalRow = new Model(foundRow);
                foundRow.RowVersion = model.RowVersion;
                this.dictionary.Remove(foundRow.ModelId);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    this.dictionary.Add(foundRow.ModelId, foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.DeletedRows.AddFirst(foundRow);
                    this.OnRowChanged(DataAction.Remove, foundRow);
                });
                return foundRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var rollbackAction in enlistmentState.RollbackActions)
            {
                rollbackAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Model"/> row in the table.
        /// </summary>
        /// <param name="models">The model row.</param>
        public async Task<IEnumerable<Model>> UpdateAsync(IEnumerable<Model> models)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Model>();
            foreach (var model in models)
            {
                if (this.dictionary.TryGetValue(model.ModelId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Model(foundRow);
                    foundRow.ModelId = model.ModelId;
                    foundRow.Name = model.Name;
                    foundRow.RowVersion = model.RowVersion;
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Model"/> row in the table.
        /// </summary>
        /// <param name="model">The model row.</param>
        public async Task<Model> UpdateAsync(Model model)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(model.ModelId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Model(foundRow);
                foundRow.ModelId = model.ModelId;
                foundRow.Name = model.Name;
                foundRow.RowVersion = model.RowVersion;
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return foundRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// A Order row.
    /// </summary>
    public class Order
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Order"/> class.
        /// </summary>
        public Order()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Order"/> class.
        /// </summary>
        /// /// <param name="order">The order.</param>
        public Order(Order order)
        {
            this.Account = order.Account;
            this.AccountId = order.AccountId;
            this.Asset = order.Asset;
            this.AssetId = order.AssetId;
            this.Quantity = order.Quantity;
            this.RowVersion = order.RowVersion;
        }

        /// <summary>
        /// Gets or sets the parent <see cref="Account"/> row.
        /// </summary>
        [JsonIgnore]
        public Account? Account { get; set; }

        /// <summary>
        /// Gets or sets the AccountId.
        /// </summary>
        [JsonPropertyName("accountId")]
        public System.Guid AccountId { get; set; }

        /// <summary>
        /// Gets or sets the parent <see cref="Asset"/> row.
        /// </summary>
        [JsonIgnore]
        public Asset? Asset { get; set; }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Quantity.
        /// </summary>
        [JsonPropertyName("quantity")]
        public decimal Quantity { get; set; }

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Deep copy of a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The destination <see cref="Order"/> row.</param>
        public void CopyFrom(Order order)
        {
            this.Account = order.Account;
            this.AccountId = order.AccountId;
            this.Asset = order.Asset;
            this.AssetId = order.AssetId;
            this.Quantity = order.Quantity;
            this.RowVersion = order.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Order other && this.AccountId == other.AccountId && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AccountId.GetHashCode() + this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Order"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Orders(Fixture fixture) : IEnlistmentNotification, IEnumerable<Order>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<(System.Guid, System.Guid), Order> dictionary = new Dictionary<(System.Guid, System.Guid), Order>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private readonly ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Order"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Order> DeletedRows { get; } = new LinkedList<Order>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                if (asyncTransaction == null)
                {
                    return null;
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The <see cref="Order"/> row.</param>
        /// <returns>The added <see cref="Order"/> row.</returns>
        public async Task<Order> AddAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedAccount = this.fixture.Accounts.Find(order.AccountId);
            ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
            await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
            var addedAsset = this.fixture.Assets.Find(order.AssetId);
            ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
            await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
            var originalRow = new Order(order);
            order.Account = addedAccount;
            order.Asset = addedAsset;
            this.fixture.RowVersion = order.RowVersion;
            addedAccount.Orders.Add(order);
            addedAsset.Orders.Add(order);
            this.dictionary.Add((order.AccountId, order.AssetId), order);
            enlistmentState.RollbackActions.Add(() =>
            {
                order.CopyFrom(originalRow);
                addedAccount.Orders.Remove(order);
                addedAsset.Orders.Remove(order);
                this.dictionary.Remove((order.AccountId, order.AssetId));
            });
            enlistmentState.CommitActions.Add(() =>
            {
                this.OnRowChanged(DataAction.Add, order);
            });
            return order;
        }

        /// <summary>
        /// Adds a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The collection of <see cref="Order"/> rows.</param>
        /// <returns>The added <see cref="Order"/> rows.</returns>
        public async Task<IEnumerable<Order>> AddAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Order>();
            foreach (var order in orders)
            {
                var addedAccount = this.fixture.Accounts.Find(order.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                var addedAsset = this.fixture.Assets.Find(order.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Order(order);
                order.Account = addedAccount;
                order.Asset = addedAsset;
                this.fixture.RowVersion = order.RowVersion;
                addedAccount.Orders.Add(order);
                addedAsset.Orders.Add(order);
                this.dictionary.Add((order.AccountId, order.AssetId), order);
                enlistmentState.RollbackActions.Add(() =>
                {
                    order.CopyFrom(originalRow);
                    addedAccount.Orders.Remove(order);
                    addedAsset.Orders.Remove(order);
                    this.dictionary.Remove((order.AccountId, order.AssetId));
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, order);
                });
                addedRows.Add(order);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var commitAction in enlistmentState.CommitActions)
            {
                commitAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Order"/> row using the unique key.
        /// </summary>
        /// <param name="accountId">The accountId.</param>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Order"/> row, or null if not found.</returns>
        public Order? Find(System.Guid accountId, System.Guid assetId)
        {
            return this.dictionary.TryGetValue((accountId, assetId), out var order) ? order : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Order> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The collection of <see cref="Order"/> rows to load.</param>
        public void Load(IEnumerable<Order> orders)
        {
            foreach (var order in orders)
            {
                var account = this.fixture.Accounts.Find(order.AccountId);
                if (account == null)
                {
                    throw new ConstraintException("AccountOrderIndex");
                }

                account.Orders.Add(order);
                order.Account = account;
                var asset = this.fixture.Assets.Find(order.AssetId);
                if (asset == null)
                {
                    throw new ConstraintException("AssetOrderIndex");
                }

                asset.Orders.Add(order);
                order.Asset = asset;
                this.dictionary.Add((order.AccountId, order.AssetId), order);
                this.fixture.RowVersion = order.RowVersion;
                this.OnRowChanged(DataAction.Add, order);
            }
        }

        /// <summary>
        /// Handles the <see cref="Order"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="order">The <see cref="Order"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Order order)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, order));
                }
                finally
                {
                }
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">The collection of <see cref="Order"/> rows.</param>
        /// <returns>The patched <see cref="Order"/> rows.</returns>
        public async Task<(IEnumerable<Order> AddedRows, IEnumerable<Order> UpdatedRows)> PatchAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Order>();
            var updatedRows = new List<Order>();
            foreach (var order in orders)
            {
                if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                    ArgumentNullException.ThrowIfNull(removedAccount);
                    await removedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var addedAccount = this.fixture.Accounts.Find(order.AccountId);
                    ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
                    await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    var addedAsset = this.fixture.Assets.Find(order.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Order(foundRow);
                    foundRow.Account = addedAccount;
                    foundRow.AccountId = order.AccountId;
                    foundRow.Asset = addedAsset;
                    foundRow.AssetId = order.AssetId;
                    foundRow.Quantity = order.Quantity;
                    foundRow.RowVersion = order.RowVersion;
                    removedAccount.Orders.Remove(foundRow);
                    removedAsset.Orders.Remove(foundRow);
                    addedAccount.Orders.Add(foundRow);
                    addedAsset.Orders.Add(foundRow);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAccount.Orders.Add(foundRow);
                        removedAsset.Orders.Add(foundRow);
                        addedAccount.Orders.Remove(foundRow);
                        addedAsset.Orders.Remove(foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    var addedAccount = this.fixture.Accounts.Find(order.AccountId);
                    ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
                    await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    var addedAsset = this.fixture.Assets.Find(order.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Order(order);
                    order.Account = addedAccount;
                    order.Asset = addedAsset;
                    this.fixture.RowVersion = order.RowVersion;
                    addedAccount.Orders.Add(order);
                    addedAsset.Orders.Add(order);
                    this.dictionary.Add((order.AccountId, order.AssetId), order);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        order.CopyFrom(originalRow);
                        addedAccount.Orders.Remove(order);
                        addedAsset.Orders.Remove(order);
                        this.dictionary.Remove((order.AccountId, order.AssetId));
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Add, order);
                    });
                    addedRows.Add(order);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The <see cref="Order"/> row.</param>
        /// <returns>The added or updated <see cref="Order"/> row.</returns>
        public async Task<(Order? AddedRow, Order? UpdatedRow)> PutAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                ArgumentNullException.ThrowIfNull(removedAccount);
                await removedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var addedAccount = this.fixture.Accounts.Find(order.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                var addedAsset = this.fixture.Assets.Find(order.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Order(foundRow);
                foundRow.Account = addedAccount;
                foundRow.AccountId = order.AccountId;
                foundRow.Asset = addedAsset;
                foundRow.AssetId = order.AssetId;
                foundRow.Quantity = order.Quantity;
                foundRow.RowVersion = order.RowVersion;
                removedAccount.Orders.Remove(foundRow);
                removedAsset.Orders.Remove(foundRow);
                addedAccount.Orders.Add(foundRow);
                addedAsset.Orders.Add(foundRow);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAccount.Orders.Add(foundRow);
                    removedAsset.Orders.Add(foundRow);
                    addedAccount.Orders.Remove(foundRow);
                    addedAsset.Orders.Remove(foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return (AddedRow: null, UpdatedRow: foundRow);
            }
            else
            {
                var addedAccount = this.fixture.Accounts.Find(order.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                var addedAsset = this.fixture.Assets.Find(order.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Order(order);
                order.Account = addedAccount;
                order.Asset = addedAsset;
                this.fixture.RowVersion = order.RowVersion;
                addedAccount.Orders.Add(order);
                addedAsset.Orders.Add(order);
                this.dictionary.Add((order.AccountId, order.AssetId), order);
                enlistmentState.RollbackActions.Add(() =>
                {
                    order.CopyFrom(originalRow);
                    addedAccount.Orders.Remove(order);
                    addedAsset.Orders.Remove(order);
                    this.dictionary.Remove((order.AccountId, order.AssetId));
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, order);
                });
                return (AddedRow: order, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Order"/> rows.
        /// </summary>
        /// <param name="orders">A collection of <see cref="Order"/> rows.</param>
        /// <returns>The removed <see cref="Order"/> rows.</returns>
        public async Task<IEnumerable<Order>> RemoveAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Order>();
            foreach (var order in orders)
            {
                if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAccount = this.fixture.Accounts.Find(order.AccountId);
                    ArgumentNullException.ThrowIfNull(removedAccount);
                    await removedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAsset = this.fixture.Assets.Find(order.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Order(foundRow);
                    foundRow.Account = null;
                    foundRow.Asset = null;
                    foundRow.RowVersion = order.RowVersion;
                    removedAccount.Orders.Remove(foundRow);
                    removedAsset.Orders.Remove(foundRow);
                    this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAccount.Orders.Add(foundRow);
                        removedAsset.Orders.Add(foundRow);
                        this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.DeletedRows.AddFirst(foundRow);
                        this.OnRowChanged(DataAction.Remove, foundRow);
                    });
                    removedRows.Add(foundRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Order"/> row.
        /// </summary>
        /// <param name="order">The <see cref="Order"/> row.</param>
        /// <returns>The removed <see cref="Order"/> row.</returns>
        public async Task<Order?> RemoveAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAccount = this.fixture.Accounts.Find(order.AccountId);
                ArgumentNullException.ThrowIfNull(removedAccount);
                await removedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAsset = this.fixture.Assets.Find(order.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Order(foundRow);
                foundRow.Account = null;
                foundRow.Asset = null;
                foundRow.RowVersion = order.RowVersion;
                removedAccount.Orders.Remove(foundRow);
                removedAsset.Orders.Remove(foundRow);
                this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAccount.Orders.Add(foundRow);
                    removedAsset.Orders.Add(foundRow);
                    this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.DeletedRows.AddFirst(foundRow);
                    this.OnRowChanged(DataAction.Remove, foundRow);
                });
                return foundRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var rollbackAction in enlistmentState.RollbackActions)
            {
                rollbackAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Order"/> row in the table.
        /// </summary>
        /// <param name="orders">The order row.</param>
        public async Task<IEnumerable<Order>> UpdateAsync(IEnumerable<Order> orders)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Order>();
            foreach (var order in orders)
            {
                if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                    ArgumentNullException.ThrowIfNull(removedAccount);
                    await removedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var addedAccount = this.fixture.Accounts.Find(order.AccountId);
                    ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
                    await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    var addedAsset = this.fixture.Assets.Find(order.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Order(foundRow);
                    foundRow.Account = addedAccount;
                    foundRow.AccountId = order.AccountId;
                    foundRow.Asset = addedAsset;
                    foundRow.AssetId = order.AssetId;
                    foundRow.Quantity = order.Quantity;
                    foundRow.RowVersion = order.RowVersion;
                    removedAccount.Orders.Remove(foundRow);
                    removedAsset.Orders.Remove(foundRow);
                    addedAccount.Orders.Add(foundRow);
                    addedAsset.Orders.Add(foundRow);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAccount.Orders.Add(foundRow);
                        removedAsset.Orders.Add(foundRow);
                        addedAccount.Orders.Remove(foundRow);
                        addedAsset.Orders.Remove(foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Order"/> row in the table.
        /// </summary>
        /// <param name="order">The order row.</param>
        public async Task<Order> UpdateAsync(Order order)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((order.AccountId, order.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                ArgumentNullException.ThrowIfNull(removedAccount);
                await removedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var addedAccount = this.fixture.Accounts.Find(order.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountOrderIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                var addedAsset = this.fixture.Assets.Find(order.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetOrderIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Order(foundRow);
                foundRow.Account = addedAccount;
                foundRow.AccountId = order.AccountId;
                foundRow.Asset = addedAsset;
                foundRow.AssetId = order.AssetId;
                foundRow.Quantity = order.Quantity;
                foundRow.RowVersion = order.RowVersion;
                removedAccount.Orders.Remove(foundRow);
                removedAsset.Orders.Remove(foundRow);
                addedAccount.Orders.Add(foundRow);
                addedAsset.Orders.Add(foundRow);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAccount.Orders.Add(foundRow);
                    removedAsset.Orders.Add(foundRow);
                    addedAccount.Orders.Remove(foundRow);
                    addedAsset.Orders.Remove(foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return foundRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// A Position row.
    /// </summary>
    public class Position
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Position"/> class.
        /// </summary>
        public Position()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Position"/> class.
        /// </summary>
        /// /// <param name="position">The position.</param>
        public Position(Position position)
        {
            this.Account = position.Account;
            this.AccountId = position.AccountId;
            this.Asset = position.Asset;
            this.AssetId = position.AssetId;
            this.Quantity = position.Quantity;
            this.RowVersion = position.RowVersion;
        }

        /// <summary>
        /// Gets or sets the parent <see cref="Account"/> row.
        /// </summary>
        [JsonIgnore]
        public Account? Account { get; set; }

        /// <summary>
        /// Gets or sets the AccountId.
        /// </summary>
        [JsonPropertyName("accountId")]
        public System.Guid AccountId { get; set; }

        /// <summary>
        /// Gets or sets the parent <see cref="Asset"/> row.
        /// </summary>
        [JsonIgnore]
        public Asset? Asset { get; set; }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Quantity.
        /// </summary>
        [JsonPropertyName("quantity")]
        public decimal Quantity { get; set; }

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Deep copy of a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The destination <see cref="Position"/> row.</param>
        public void CopyFrom(Position position)
        {
            this.Account = position.Account;
            this.AccountId = position.AccountId;
            this.Asset = position.Asset;
            this.AssetId = position.AssetId;
            this.Quantity = position.Quantity;
            this.RowVersion = position.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Position other && this.AccountId == other.AccountId && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AccountId.GetHashCode() + this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Position"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Positions(Fixture fixture) : IEnlistmentNotification, IEnumerable<Position>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<(System.Guid, System.Guid), Position> dictionary = new Dictionary<(System.Guid, System.Guid), Position>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private readonly ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Position"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Position> DeletedRows { get; } = new LinkedList<Position>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                if (asyncTransaction == null)
                {
                    return null;
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The <see cref="Position"/> row.</param>
        /// <returns>The added <see cref="Position"/> row.</returns>
        public async Task<Position> AddAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedAccount = this.fixture.Accounts.Find(position.AccountId);
            ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
            await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
            var addedAsset = this.fixture.Assets.Find(position.AssetId);
            ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
            await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
            var originalRow = new Position(position);
            position.Account = addedAccount;
            position.Asset = addedAsset;
            this.fixture.RowVersion = position.RowVersion;
            addedAccount.Positions.Add(position);
            addedAsset.Positions.Add(position);
            this.dictionary.Add((position.AccountId, position.AssetId), position);
            enlistmentState.RollbackActions.Add(() =>
            {
                position.CopyFrom(originalRow);
                addedAccount.Positions.Remove(position);
                addedAsset.Positions.Remove(position);
                this.dictionary.Remove((position.AccountId, position.AssetId));
            });
            enlistmentState.CommitActions.Add(() =>
            {
                this.OnRowChanged(DataAction.Add, position);
            });
            return position;
        }

        /// <summary>
        /// Adds a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The collection of <see cref="Position"/> rows.</param>
        /// <returns>The added <see cref="Position"/> rows.</returns>
        public async Task<IEnumerable<Position>> AddAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Position>();
            foreach (var position in positions)
            {
                var addedAccount = this.fixture.Accounts.Find(position.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                var addedAsset = this.fixture.Assets.Find(position.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Position(position);
                position.Account = addedAccount;
                position.Asset = addedAsset;
                this.fixture.RowVersion = position.RowVersion;
                addedAccount.Positions.Add(position);
                addedAsset.Positions.Add(position);
                this.dictionary.Add((position.AccountId, position.AssetId), position);
                enlistmentState.RollbackActions.Add(() =>
                {
                    position.CopyFrom(originalRow);
                    addedAccount.Positions.Remove(position);
                    addedAsset.Positions.Remove(position);
                    this.dictionary.Remove((position.AccountId, position.AssetId));
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, position);
                });
                addedRows.Add(position);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var commitAction in enlistmentState.CommitActions)
            {
                commitAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Position"/> row using the unique key.
        /// </summary>
        /// <param name="accountId">The accountId.</param>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Position"/> row, or null if not found.</returns>
        public Position? Find(System.Guid accountId, System.Guid assetId)
        {
            return this.dictionary.TryGetValue((accountId, assetId), out var position) ? position : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Position> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The collection of <see cref="Position"/> rows to load.</param>
        public void Load(IEnumerable<Position> positions)
        {
            foreach (var position in positions)
            {
                var account = this.fixture.Accounts.Find(position.AccountId);
                if (account == null)
                {
                    throw new ConstraintException("AccountPositionIndex");
                }

                account.Positions.Add(position);
                position.Account = account;
                var asset = this.fixture.Assets.Find(position.AssetId);
                if (asset == null)
                {
                    throw new ConstraintException("AssetPositionIndex");
                }

                asset.Positions.Add(position);
                position.Asset = asset;
                this.dictionary.Add((position.AccountId, position.AssetId), position);
                this.fixture.RowVersion = position.RowVersion;
                this.OnRowChanged(DataAction.Add, position);
            }
        }

        /// <summary>
        /// Handles the <see cref="Position"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="position">The <see cref="Position"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Position position)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, position));
                }
                finally
                {
                }
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">The collection of <see cref="Position"/> rows.</param>
        /// <returns>The patched <see cref="Position"/> rows.</returns>
        public async Task<(IEnumerable<Position> AddedRows, IEnumerable<Position> UpdatedRows)> PatchAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Position>();
            var updatedRows = new List<Position>();
            foreach (var position in positions)
            {
                if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                    ArgumentNullException.ThrowIfNull(removedAccount);
                    await removedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var addedAccount = this.fixture.Accounts.Find(position.AccountId);
                    ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
                    await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    var addedAsset = this.fixture.Assets.Find(position.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Position(foundRow);
                    foundRow.Account = addedAccount;
                    foundRow.AccountId = position.AccountId;
                    foundRow.Asset = addedAsset;
                    foundRow.AssetId = position.AssetId;
                    foundRow.Quantity = position.Quantity;
                    foundRow.RowVersion = position.RowVersion;
                    removedAccount.Positions.Remove(foundRow);
                    removedAsset.Positions.Remove(foundRow);
                    addedAccount.Positions.Add(foundRow);
                    addedAsset.Positions.Add(foundRow);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAccount.Positions.Add(foundRow);
                        removedAsset.Positions.Add(foundRow);
                        addedAccount.Positions.Remove(foundRow);
                        addedAsset.Positions.Remove(foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    var addedAccount = this.fixture.Accounts.Find(position.AccountId);
                    ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
                    await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    var addedAsset = this.fixture.Assets.Find(position.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Position(position);
                    position.Account = addedAccount;
                    position.Asset = addedAsset;
                    this.fixture.RowVersion = position.RowVersion;
                    addedAccount.Positions.Add(position);
                    addedAsset.Positions.Add(position);
                    this.dictionary.Add((position.AccountId, position.AssetId), position);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        position.CopyFrom(originalRow);
                        addedAccount.Positions.Remove(position);
                        addedAsset.Positions.Remove(position);
                        this.dictionary.Remove((position.AccountId, position.AssetId));
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Add, position);
                    });
                    addedRows.Add(position);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The <see cref="Position"/> row.</param>
        /// <returns>The added or updated <see cref="Position"/> row.</returns>
        public async Task<(Position? AddedRow, Position? UpdatedRow)> PutAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                ArgumentNullException.ThrowIfNull(removedAccount);
                await removedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var addedAccount = this.fixture.Accounts.Find(position.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                var addedAsset = this.fixture.Assets.Find(position.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Position(foundRow);
                foundRow.Account = addedAccount;
                foundRow.AccountId = position.AccountId;
                foundRow.Asset = addedAsset;
                foundRow.AssetId = position.AssetId;
                foundRow.Quantity = position.Quantity;
                foundRow.RowVersion = position.RowVersion;
                removedAccount.Positions.Remove(foundRow);
                removedAsset.Positions.Remove(foundRow);
                addedAccount.Positions.Add(foundRow);
                addedAsset.Positions.Add(foundRow);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAccount.Positions.Add(foundRow);
                    removedAsset.Positions.Add(foundRow);
                    addedAccount.Positions.Remove(foundRow);
                    addedAsset.Positions.Remove(foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return (AddedRow: null, UpdatedRow: foundRow);
            }
            else
            {
                var addedAccount = this.fixture.Accounts.Find(position.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                var addedAsset = this.fixture.Assets.Find(position.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Position(position);
                position.Account = addedAccount;
                position.Asset = addedAsset;
                this.fixture.RowVersion = position.RowVersion;
                addedAccount.Positions.Add(position);
                addedAsset.Positions.Add(position);
                this.dictionary.Add((position.AccountId, position.AssetId), position);
                enlistmentState.RollbackActions.Add(() =>
                {
                    position.CopyFrom(originalRow);
                    addedAccount.Positions.Remove(position);
                    addedAsset.Positions.Remove(position);
                    this.dictionary.Remove((position.AccountId, position.AssetId));
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, position);
                });
                return (AddedRow: position, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Position"/> rows.
        /// </summary>
        /// <param name="positions">A collection of <see cref="Position"/> rows.</param>
        /// <returns>The removed <see cref="Position"/> rows.</returns>
        public async Task<IEnumerable<Position>> RemoveAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Position>();
            foreach (var position in positions)
            {
                if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAccount = this.fixture.Accounts.Find(position.AccountId);
                    ArgumentNullException.ThrowIfNull(removedAccount);
                    await removedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAsset = this.fixture.Assets.Find(position.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Position(foundRow);
                    foundRow.Account = null;
                    foundRow.Asset = null;
                    foundRow.RowVersion = position.RowVersion;
                    removedAccount.Positions.Remove(foundRow);
                    removedAsset.Positions.Remove(foundRow);
                    this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAccount.Positions.Add(foundRow);
                        removedAsset.Positions.Add(foundRow);
                        this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.DeletedRows.AddFirst(foundRow);
                        this.OnRowChanged(DataAction.Remove, foundRow);
                    });
                    removedRows.Add(foundRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Position"/> row.
        /// </summary>
        /// <param name="position">The <see cref="Position"/> row.</param>
        /// <returns>The removed <see cref="Position"/> row.</returns>
        public async Task<Position?> RemoveAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAccount = this.fixture.Accounts.Find(position.AccountId);
                ArgumentNullException.ThrowIfNull(removedAccount);
                await removedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAsset = this.fixture.Assets.Find(position.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Position(foundRow);
                foundRow.Account = null;
                foundRow.Asset = null;
                foundRow.RowVersion = position.RowVersion;
                removedAccount.Positions.Remove(foundRow);
                removedAsset.Positions.Remove(foundRow);
                this.dictionary.Remove((foundRow.AccountId, foundRow.AssetId));
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAccount.Positions.Add(foundRow);
                    removedAsset.Positions.Add(foundRow);
                    this.dictionary.Add((foundRow.AccountId, foundRow.AssetId), foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.DeletedRows.AddFirst(foundRow);
                    this.OnRowChanged(DataAction.Remove, foundRow);
                });
                return foundRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var rollbackAction in enlistmentState.RollbackActions)
            {
                rollbackAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Position"/> row in the table.
        /// </summary>
        /// <param name="positions">The position row.</param>
        public async Task<IEnumerable<Position>> UpdateAsync(IEnumerable<Position> positions)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Position>();
            foreach (var position in positions)
            {
                if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                    ArgumentNullException.ThrowIfNull(removedAccount);
                    await removedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var addedAccount = this.fixture.Accounts.Find(position.AccountId);
                    ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
                    await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                    var addedAsset = this.fixture.Assets.Find(position.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Position(foundRow);
                    foundRow.Account = addedAccount;
                    foundRow.AccountId = position.AccountId;
                    foundRow.Asset = addedAsset;
                    foundRow.AssetId = position.AssetId;
                    foundRow.Quantity = position.Quantity;
                    foundRow.RowVersion = position.RowVersion;
                    removedAccount.Positions.Remove(foundRow);
                    removedAsset.Positions.Remove(foundRow);
                    addedAccount.Positions.Add(foundRow);
                    addedAsset.Positions.Add(foundRow);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAccount.Positions.Add(foundRow);
                        removedAsset.Positions.Add(foundRow);
                        addedAccount.Positions.Remove(foundRow);
                        addedAsset.Positions.Remove(foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Position"/> row in the table.
        /// </summary>
        /// <param name="position">The position row.</param>
        public async Task<Position> UpdateAsync(Position position)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue((position.AccountId, position.AssetId), out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAccount = this.fixture.Accounts.Find(foundRow.AccountId);
                ArgumentNullException.ThrowIfNull(removedAccount);
                await removedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var addedAccount = this.fixture.Accounts.Find(position.AccountId);
                ConstraintException.ThrowIfNull(addedAccount, "AccountPositionIndex");
                await addedAccount.EnterWriteLockAsync().ConfigureAwait(true);
                var addedAsset = this.fixture.Assets.Find(position.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetPositionIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Position(foundRow);
                foundRow.Account = addedAccount;
                foundRow.AccountId = position.AccountId;
                foundRow.Asset = addedAsset;
                foundRow.AssetId = position.AssetId;
                foundRow.Quantity = position.Quantity;
                foundRow.RowVersion = position.RowVersion;
                removedAccount.Positions.Remove(foundRow);
                removedAsset.Positions.Remove(foundRow);
                addedAccount.Positions.Add(foundRow);
                addedAsset.Positions.Add(foundRow);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAccount.Positions.Add(foundRow);
                    removedAsset.Positions.Add(foundRow);
                    addedAccount.Positions.Remove(foundRow);
                    addedAsset.Positions.Remove(foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return foundRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }

    /// <summary>
    /// A Quote row.
    /// </summary>
    public class Quote
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// Initializes a new instance of the <see cref="Quote"/> class.
        /// </summary>
        public Quote()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Quote"/> class.
        /// </summary>
        /// /// <param name="quote">The quote.</param>
        public Quote(Quote quote)
        {
            this.Asset = quote.Asset;
            this.AssetId = quote.AssetId;
            this.Last = quote.Last;
            this.RowVersion = quote.RowVersion;
        }

        /// <summary>
        /// Gets or sets the parent <see cref="Asset"/> row.
        /// </summary>
        [JsonIgnore]
        public Asset? Asset { get; set; }

        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [JsonPropertyName("assetId")]
        public System.Guid AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Last.
        /// </summary>
        [JsonPropertyName("last")]
        public decimal Last { get; set; }

        /// <summary>
        /// Gets or sets the RowVersion.
        /// </summary>
        [JsonPropertyName("rowVersion")]
        public long RowVersion { get; set; }

        /// <summary>
        /// Deep copy of a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The destination <see cref="Quote"/> row.</param>
        public void CopyFrom(Quote quote)
        {
            this.Asset = quote.Asset;
            this.AssetId = quote.AssetId;
            this.Last = quote.Last;
            this.RowVersion = quote.RowVersion;
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    asyncTransaction.ReadLocks.Remove(this);
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            return obj is Quote other && this.AssetId == other.AssetId;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.AssetId.GetHashCode();
        }
    }

    /// <summary>
    /// A table of <see cref="Quote"/> rows.
    /// </summary>
    /// <param name="fixture">The data model.</param>
    public class Quotes(Fixture fixture) : IEnlistmentNotification, IEnumerable<Quote>
    {
        /// <summary>
        /// The reader writer lock.
        /// </summary>
        private readonly AsyncReaderWriterLock asyncReaderWriterLock = new AsyncReaderWriterLock();

        /// <summary>
        /// The primary index.
        /// </summary>
        private readonly Dictionary<System.Guid, Quote> dictionary = new Dictionary<System.Guid, Quote>();

        /// <summary>
        /// The enlistment states for all the concurrent transactions.
        /// </summary>
        private readonly ConcurrentDictionary<AsyncTransaction, EnlistmentState> enlistmentStates = new ConcurrentDictionary<AsyncTransaction, EnlistmentState>();

        /// <summary>
        /// The data model.
        /// </summary>
        private readonly Fixture fixture = fixture;

        /// <summary>
        /// Occurs when a <see cref="Quote"/> row has changed.
        /// </summary>
        public event EventHandler<RowChangedEventArgs>? RowChanged;

        /// <summary>
        /// Gets the list of deleted rows.
        /// </summary>
        public LinkedList<Quote> DeletedRows { get; } = new LinkedList<Quote>();

        /// <summary>
        /// Gets the enlistment state for the current task.
        /// </summary>
        private EnlistmentState? EnlistmentState
        {
            get
            {
                var asyncTransaction = AsyncTransaction.Current;
                if (asyncTransaction == null)
                {
                    return null;
                }

                this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
                return enlistmentState;
            }
        }

        /// <summary>
        /// Adds a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The <see cref="Quote"/> row.</param>
        /// <returns>The added <see cref="Quote"/> row.</returns>
        public async Task<Quote> AddAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedAsset = this.fixture.Assets.Find(quote.AssetId);
            ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
            await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
            var originalRow = new Quote(quote);
            quote.Asset = addedAsset;
            this.fixture.RowVersion = quote.RowVersion;
            addedAsset.Quotes.Add(quote);
            this.dictionary.Add(quote.AssetId, quote);
            enlistmentState.RollbackActions.Add(() =>
            {
                quote.CopyFrom(originalRow);
                addedAsset.Quotes.Remove(quote);
                this.dictionary.Remove(quote.AssetId);
            });
            enlistmentState.CommitActions.Add(() =>
            {
                this.OnRowChanged(DataAction.Add, quote);
            });
            return quote;
        }

        /// <summary>
        /// Adds a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The collection of <see cref="Quote"/> rows.</param>
        /// <returns>The added <see cref="Quote"/> rows.</returns>
        public async Task<IEnumerable<Quote>> AddAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                var addedAsset = this.fixture.Assets.Find(quote.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Quote(quote);
                quote.Asset = addedAsset;
                this.fixture.RowVersion = quote.RowVersion;
                addedAsset.Quotes.Add(quote);
                this.dictionary.Add(quote.AssetId, quote);
                enlistmentState.RollbackActions.Add(() =>
                {
                    quote.CopyFrom(originalRow);
                    addedAsset.Quotes.Remove(quote);
                    this.dictionary.Remove(quote.AssetId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, quote);
                });
                addedRows.Add(quote);
            }

            return addedRows;
        }

        /// <inheritdoc/>
        public void Commit(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var commitAction in enlistmentState.CommitActions)
            {
                commitAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Enters the lock in read mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterReadLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this) && !asyncTransaction.ReadLocks.ContainsKey(this))
            {
                await this.asyncReaderWriterLock.EnterReadLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                asyncTransaction.ReadLocks.Add(this, this.asyncReaderWriterLock);
                asyncTransaction.EnlistVolatile(this);
                this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
            }
        }

        /// <summary>
        /// Enters the lock in write mode asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
        public async Task EnterWriteLockAsync()
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            if (!asyncTransaction.WriteLocks.ContainsKey(this))
            {
                if (asyncTransaction.ReadLocks.ContainsKey(this))
                {
                    await this.asyncReaderWriterLock.UpgradeToWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.ReadLocks.Remove(this);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                }
                else
                {
                    await this.asyncReaderWriterLock.EnterWriteLockAsync(asyncTransaction.CancellationToken).ConfigureAwait(false);
                    asyncTransaction.WriteLocks.Add(this, this.asyncReaderWriterLock);
                    asyncTransaction.EnlistVolatile(this);
                    this.enlistmentStates.TryAdd(asyncTransaction, new EnlistmentState());
                }
            }
        }

        /// <summary>
        /// Finds a <see cref="Quote"/> row using the unique key.
        /// </summary>
        /// <param name="assetId">The assetId.</param>
        /// <returns>The found <see cref="Quote"/> row, or null if not found.</returns>
        public Quote? Find(System.Guid assetId)
        {
            return this.dictionary.TryGetValue(assetId, out var quote) ? quote : null;
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public IEnumerator<Quote> GetEnumerator()
        {
            return this.dictionary.Values.GetEnumerator();
        }

        /// <inheritdoc/>
        public void InDoubt(Enlistment enlistment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Load a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The collection of <see cref="Quote"/> rows to load.</param>
        public void Load(IEnumerable<Quote> quotes)
        {
            foreach (var quote in quotes)
            {
                var asset = this.fixture.Assets.Find(quote.AssetId);
                if (asset == null)
                {
                    throw new ConstraintException("AssetQuoteIndex");
                }

                asset.Quotes.Add(quote);
                quote.Asset = asset;
                this.dictionary.Add(quote.AssetId, quote);
                this.fixture.RowVersion = quote.RowVersion;
                this.OnRowChanged(DataAction.Add, quote);
            }
        }

        /// <summary>
        /// Handles the <see cref="Quote"/> row changed event.
        /// </summary>
        /// <param name="dataAction">The data action.</param>
        /// <param name="quote">The <see cref="Quote"/> row that changed.</param>
        private void OnRowChanged(DataAction dataAction, Quote quote)
        {
            if (this.RowChanged != null)
            {
                try
                {
                    this.RowChanged.Invoke(this, new RowChangedEventArgs(dataAction, quote));
                }
                finally
                {
                }
            }
        }

        /// <summary>
        /// Patches a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">The collection of <see cref="Quote"/> rows.</param>
        /// <returns>The patched <see cref="Quote"/> rows.</returns>
        public async Task<(IEnumerable<Quote> AddedRows, IEnumerable<Quote> UpdatedRows)> PatchAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var addedRows = new List<Quote>();
            var updatedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var addedAsset = this.fixture.Assets.Find(quote.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Quote(foundRow);
                    foundRow.Asset = addedAsset;
                    foundRow.AssetId = quote.AssetId;
                    foundRow.Last = quote.Last;
                    foundRow.RowVersion = quote.RowVersion;
                    removedAsset.Quotes.Remove(foundRow);
                    addedAsset.Quotes.Add(foundRow);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAsset.Quotes.Add(foundRow);
                        addedAsset.Quotes.Remove(foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    var addedAsset = this.fixture.Assets.Find(quote.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Quote(quote);
                    quote.Asset = addedAsset;
                    this.fixture.RowVersion = quote.RowVersion;
                    addedAsset.Quotes.Add(quote);
                    this.dictionary.Add(quote.AssetId, quote);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        quote.CopyFrom(originalRow);
                        addedAsset.Quotes.Remove(quote);
                        this.dictionary.Remove(quote.AssetId);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Add, quote);
                    });
                    addedRows.Add(quote);
                }
            }

            return (AddedRows: addedRows, UpdatedRows: updatedRows);
        }

        /// <inheritdoc/>
        public void Prepare(PreparingEnlistment preparingEnlistment)
        {
            preparingEnlistment.Prepared();
        }

        /// <summary>
        /// Puts a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The <see cref="Quote"/> row.</param>
        /// <returns>The added or updated <see cref="Quote"/> row.</returns>
        public async Task<(Quote? AddedRow, Quote? UpdatedRow)> PutAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var addedAsset = this.fixture.Assets.Find(quote.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Quote(foundRow);
                foundRow.Asset = addedAsset;
                foundRow.AssetId = quote.AssetId;
                foundRow.Last = quote.Last;
                foundRow.RowVersion = quote.RowVersion;
                removedAsset.Quotes.Remove(foundRow);
                addedAsset.Quotes.Add(foundRow);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAsset.Quotes.Add(foundRow);
                    addedAsset.Quotes.Remove(foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return (AddedRow: null, UpdatedRow: foundRow);
            }
            else
            {
                var addedAsset = this.fixture.Assets.Find(quote.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Quote(quote);
                quote.Asset = addedAsset;
                this.fixture.RowVersion = quote.RowVersion;
                addedAsset.Quotes.Add(quote);
                this.dictionary.Add(quote.AssetId, quote);
                enlistmentState.RollbackActions.Add(() =>
                {
                    quote.CopyFrom(originalRow);
                    addedAsset.Quotes.Remove(quote);
                    this.dictionary.Remove(quote.AssetId);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Add, quote);
                });
                return (AddedRow: quote, UpdatedRow: null);
            }
        }

        /// <summary>
        /// Removes a collection of <see cref="Quote"/> rows.
        /// </summary>
        /// <param name="quotes">A collection of <see cref="Quote"/> rows.</param>
        /// <returns>The removed <see cref="Quote"/> rows.</returns>
        public async Task<IEnumerable<Quote>> RemoveAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var removedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAsset = this.fixture.Assets.Find(quote.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Quote(foundRow);
                    foundRow.Asset = null;
                    foundRow.RowVersion = quote.RowVersion;
                    removedAsset.Quotes.Remove(foundRow);
                    this.dictionary.Remove(foundRow.AssetId);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAsset.Quotes.Add(foundRow);
                        this.dictionary.Add(foundRow.AssetId, foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.DeletedRows.AddFirst(foundRow);
                        this.OnRowChanged(DataAction.Remove, foundRow);
                    });
                    removedRows.Add(foundRow);
                }
            }

            return removedRows;
        }

        /// <summary>
        /// Removes a <see cref="Quote"/> row.
        /// </summary>
        /// <param name="quote">The <see cref="Quote"/> row.</param>
        /// <returns>The removed <see cref="Quote"/> row.</returns>
        public async Task<Quote?> RemoveAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAsset = this.fixture.Assets.Find(quote.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Quote(foundRow);
                foundRow.Asset = null;
                foundRow.RowVersion = quote.RowVersion;
                removedAsset.Quotes.Remove(foundRow);
                this.dictionary.Remove(foundRow.AssetId);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAsset.Quotes.Add(foundRow);
                    this.dictionary.Add(foundRow.AssetId, foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.DeletedRows.AddFirst(foundRow);
                    this.OnRowChanged(DataAction.Remove, foundRow);
                });
                return foundRow;
            }
            else
            {
                return null;
            }
        }

        /// <inheritdoc/>
        public void Rollback(Enlistment enlistment)
        {
            var asyncTransaction = AsyncTransaction.Current;
            ArgumentNullException.ThrowIfNull(asyncTransaction);
            this.enlistmentStates.TryGetValue(asyncTransaction, out var enlistmentState);
            ArgumentNullException.ThrowIfNull(enlistmentState);
            foreach (var rollbackAction in enlistmentState.RollbackActions)
            {
                rollbackAction();
            }

            this.enlistmentStates.TryRemove(asyncTransaction, out _);
            enlistment.Done();
        }

        /// <summary>
        /// Updates a <see cref="Quote"/> row in the table.
        /// </summary>
        /// <param name="quotes">The quote row.</param>
        public async Task<IEnumerable<Quote>> UpdateAsync(IEnumerable<Quote> quotes)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            var updatedRows = new List<Quote>();
            foreach (var quote in quotes)
            {
                if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
                {
                    await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                    var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                    ArgumentNullException.ThrowIfNull(removedAsset);
                    await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var addedAsset = this.fixture.Assets.Find(quote.AssetId);
                    ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
                    await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                    var originalRow = new Quote(foundRow);
                    foundRow.Asset = addedAsset;
                    foundRow.AssetId = quote.AssetId;
                    foundRow.Last = quote.Last;
                    foundRow.RowVersion = quote.RowVersion;
                    removedAsset.Quotes.Remove(foundRow);
                    addedAsset.Quotes.Add(foundRow);
                    enlistmentState.RollbackActions.Add(() =>
                    {
                        foundRow.CopyFrom(originalRow);
                        removedAsset.Quotes.Add(foundRow);
                        addedAsset.Quotes.Remove(foundRow);
                    });
                    enlistmentState.CommitActions.Add(() =>
                    {
                        this.OnRowChanged(DataAction.Update, foundRow);
                    });
                    updatedRows.Add(foundRow);
                }
                else
                {
                    throw new KeyNotFoundException();
                }
            }

            return updatedRows;
        }

        /// <summary>
        /// Updates a <see cref="Quote"/> row in the table.
        /// </summary>
        /// <param name="quote">The quote row.</param>
        public async Task<Quote> UpdateAsync(Quote quote)
        {
            var enlistmentState = this.EnlistmentState;
            ArgumentNullException.ThrowIfNull(enlistmentState);
            if (this.dictionary.TryGetValue(quote.AssetId, out var foundRow))
            {
                await foundRow.EnterWriteLockAsync().ConfigureAwait(true);
                var removedAsset = this.fixture.Assets.Find(foundRow.AssetId);
                ArgumentNullException.ThrowIfNull(removedAsset);
                await removedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var addedAsset = this.fixture.Assets.Find(quote.AssetId);
                ConstraintException.ThrowIfNull(addedAsset, "AssetQuoteIndex");
                await addedAsset.EnterWriteLockAsync().ConfigureAwait(true);
                var originalRow = new Quote(foundRow);
                foundRow.Asset = addedAsset;
                foundRow.AssetId = quote.AssetId;
                foundRow.Last = quote.Last;
                foundRow.RowVersion = quote.RowVersion;
                removedAsset.Quotes.Remove(foundRow);
                addedAsset.Quotes.Add(foundRow);
                enlistmentState.RollbackActions.Add(() =>
                {
                    foundRow.CopyFrom(originalRow);
                    removedAsset.Quotes.Add(foundRow);
                    addedAsset.Quotes.Remove(foundRow);
                });
                enlistmentState.CommitActions.Add(() =>
                {
                    this.OnRowChanged(DataAction.Update, foundRow);
                });
                return foundRow;
            }
            else
            {
                throw new KeyNotFoundException();
            }
        }
    }
}